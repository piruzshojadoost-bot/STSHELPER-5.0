{"file_contents":{"src/modules/search/localSearchWithFallback.ts":{"content":"\n// src/modules/search/localSearchWithFallback.ts\n// Lokal s√∂kmodul med s√§ker lemma, suffix, compounds och AI-fallback.\n// - Lokal s√∂kning f√∂ljer strikt prioritet: exact ‚Üí inflections ‚Üí alias ‚Üí suffix ‚Üí compound ‚Üí fuzzy\n// - Fuzzy √§r skyddad: samma f√∂rsta bokstav kr√§vs + max 1-2 distance + f√∂rhindrar \"ord-i-ord\"-tr√§ffar\n// - Renderar och returnerar kandidat(er) men √§ndrar aldrig originaltext automatiskt\n// - Exporterar: doLocalSearch(text), findCandidatesForToken(token), initLocalSearch(opts)\n\nimport { WordMapEntry, Sign } from '../../types';\nimport {\n  localLexiconMap,    // Map<string, Sign[]>\n  aliasMap,           // Map<string, string>\n  searchableLexicon,  // string[] (sorted list of keys)\n  inflectionMap,      // Map<string, string> (ordform -> lemma)\n  signInflectionMap,  // Map<string, string> (gloss variations -> base gloss)\n  localUserSigns,     // Map<string, Sign[]> (Anv√§ndarens egna/inl√§rda tecken)\n  learnedPreferences  // Map<string, Map<string, number>> (Anv√§ndarens preferenser f√∂r tecken)\n} from '../../state';\n\nimport { safeDistance } from '../../utils'; // valfri, men vi inkluderar fallback implementation nedan\n\ntype Candidate = {\n  signs: Sign[] | null;\n  base: string;                // the base word we matched (lemma or key)\n  method: string;              // rationale\n  isCompound?: boolean;\n  parts?: string[];            // if compound, parts\n};\n\ntype InitOptions = {\n  // Optionally provide an AI fallback function: async (token: string, context: string) => Candidate | null\n  aiFallback?: (token: string, context: string) => Promise<Candidate | null>;\n  // Optionally disable fuzzy\n  enableFuzzy?: boolean;\n  // Minimal fuzzy length\n  fuzzyMinLength?: number;\n};\n\nlet AI_FALLBACK: InitOptions['aiFallback'] | null = null;\nlet ENABLE_FUZZY = true;\nlet FUZZY_MIN_LENGTH = 4;\n\n// Lokal s√∂kcache f√∂r att undvika upprepade ber√§kningar (LRU strategy)\nconst localSearchCache = new Map<string, Candidate | null>();\nconst cacheAccessOrder: string[] = []; // Track access order for LRU\nconst MAX_CACHE_SIZE = 500; // Begr√§nsa cache-storlek\n\n// Export function to clear cache when lexicon/inflection map updates\nexport function clearLocalSearchCache() {\n    localSearchCache.clear();\n    cacheAccessOrder.length = 0;\n    console.log('üóëÔ∏è Local search cache cleared');\n}\n\n// ---------- Configuration / safe lists ----------\nconst SAFE_SUFFIXES = [\n  // order matters: longer suffixes first\n  'ningen', 'andet', 'elsen', // l√§ngsta f√∂rst\n  'ande', 'ende', 'arna', 'erna', 'orna', // plurals / participles\n  'aste', 'are', 'ers', 'ens',\n  'else', 'het', 'ade', 'ade', // NYTT: vanliga svenska suffix\n  // common short suffixes (be conservative)\n  'ar', 'er', 'or', 'en', 'et', 'na', 't', 'n', 's', 'a', 'as', 'es', 'ad', 'at', 'dd'\n].sort((a, b) => b.length - a.length); // ensure longer tried first\n\n// Prevent stripping if root would be too short\nconst MIN_ROOT_LENGTH = 2;\n\n// ---------- Normalization (preserve √•√§√∂) ----------\nfunction normalizeForLookup(s: string) {\n  // Lowercase using locale (sv) to preserve √•√§√∂ properly\n  return s.trim().toLowerCase();\n}\n\n// ---------- Levenshtein (fallback safeDistance) ----------\nfunction levenshtein(a: string, b: string): number {\n  const m = a.length, n = b.length;\n  if (m === 0) return n;\n  if (n === 0) return m;\n  const dp: number[] = Array(n + 1).fill(0).map((_, i) => i);\n  for (let i = 1; i <= m; i++) {\n    let prev = dp[0];\n    dp[0] = i;\n    for (let j = 1; j <= n; j++) {\n      const temp = dp[j];\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      dp[j] = Math.min(dp[j] + 1, dp[j - 1] + 1, prev + cost);\n      prev = temp;\n    }\n  }\n  return dp[n];\n}\n\n// safeDistance wrapper: prefer safeDistance util if available\nfunction _safeDistance(a: string, b: string): number {\n  try {\n    // if project provides safeDistance that respects diacritics, use it\n    // @ts-ignore\n    if (typeof safeDistance === 'function') return safeDistance(a, b);\n  } catch (e) { /* ignore */ }\n  return levenshtein(a, b);\n}\n\n// ---------- Fuzzy rules to avoid bad matches ----------\nfunction fuzzyAllowed(candidate: string, token: string, distance: number): boolean {\n  if (!candidate || !token) return false;\n  // Must share first letter exactly (diacritics included)\n  if (candidate[0] !== token[0]) return false;\n  // F√ñRB√ÑTTRAD LOGIK: F√∂r ord >= 4 tecken, om andra bokstaven skiljer sig, kr√§v exakt match (distance = 0)\n  if (token.length >= 4 && candidate.length >= 2) {\n    if (candidate[1] !== token[1]) {\n      return distance === 0; // Till√•t om perfekt match trots andra bokstav-skillnad\n    }\n  }\n  // prevent substring traps: do not accept candidate if candidate contains token or token contains candidate\n  // unless they are highly similar (distance 0 or 1) and lengths are similar\n  if ((candidate.includes(token) || token.includes(candidate)) && Math.abs(candidate.length - token.length) > 1) {\n    return false;\n  }\n  return true;\n}\n\n// ---------- Utility: sort signs by user preferences (tumme upp) ----------\nfunction sortSignsByPreference(signs: Sign[], lookupKey: string): Sign[] {\n  if (!learnedPreferences.has(lookupKey)) {\n    return signs; // Ingen preferens, returnera som de √§r\n  }\n  \n  const preferences = learnedPreferences.get(lookupKey)!;\n  const sorted = [...signs].sort((a, b) => {\n    const weightA = preferences.get(a.id) || 0;\n    const weightB = preferences.get(b.id) || 0;\n    return weightB - weightA; // H√∂gre weight f√∂rst\n  });\n  \n  return sorted;\n}\n\n// ---------- Utility: look in local lexicon map safely ----------\nfunction getSignsForKey(key: string): { signs: Sign[], isCompound?: boolean } | null {\n  const k = normalizeForLookup(key);\n  \n  // 1. Check user-defined/learned signs FIRST (This fixes the issue with \"det\" -> \"den\")\n  if (localUserSigns.has(k)) return localUserSigns.get(k)!;\n\n  // 2. Check standard lexicon\n  if (localLexiconMap.has(k)) return { signs: localLexiconMap.get(k)!, isCompound: false };\n  \n  return null;\n}\n\n// ---------- Main candidate finder for a single token ----------\nexport async function findCandidatesForToken(tokenRaw: string): Promise<Candidate | null> {\n  const token = normalizeForLookup(tokenRaw);\n  if (!token) return null;\n\n  // 0. If token is punctuation / whitespace: return null (handled by caller)\n  if (/^[\\s,.\"!?;:+\\-‚Äì‚Äî()]+$/.test(tokenRaw)) return null;\n  \n  // 0.5. Check cache first (with LRU update)\n  if (localSearchCache.has(token)) {\n    const cached = localSearchCache.get(token)!;\n    // Update access order for LRU\n    const idx = cacheAccessOrder.indexOf(token);\n    if (idx > -1) cacheAccessOrder.splice(idx, 1);\n    cacheAccessOrder.push(token);\n    return cached;\n  }\n\n  // 1Ô∏è‚É£ Exact match (highest priority)\n  const exactMatch = getSignsForKey(token);\n  if (exactMatch) {\n    // Sortera tecken baserat p√• anv√§ndarens preferenser (tumme upp)\n    const sortedSigns = sortSignsByPreference(exactMatch.signs, token);\n    const result = { signs: sortedSigns, base: token, method: 'Exakt match', isCompound: exactMatch.isCompound };\n    localSearchCache.set(token, result);\n    return result;\n  }\n\n  // 2Ô∏è‚É£ Lemma via inflectionMap (Swedish inflections)\n  if (inflectionMap) {\n    // Testa B√ÖDE token och lowercase version\n    const tokensToCheck = [token, token.toLowerCase()];\n    for (const checkToken of tokensToCheck) {\n      if (inflectionMap.has(checkToken)) {\n        const lemma = inflectionMap.get(checkToken)!;\n        const lemmaMatch = getSignsForKey(lemma);\n        if (lemmaMatch) {\n          // Sortera tecken baserat p√• anv√§ndarens preferenser\n          const sortedSigns = sortSignsByPreference(lemmaMatch.signs, lemma);\n          const result = { signs: sortedSigns, base: lemma, method: `Lemma (inflections) ${checkToken}‚Üí${lemma}`, isCompound: lemmaMatch.isCompound };\n          localSearchCache.set(token, result);\n          return result;\n        }\n        // NYTT: Om lemma finns men inget tecken hittades, returnera √§nd√• lemma (f√∂rhindrar felaktig orddelning)\n        // T.ex. \"f√∂rst√•r\" ‚Üí \"f√∂rst√•\" √§ven om \"f√∂rst√•\" inte finns i lexikon √§nnu\n        const result = { signs: null, base: lemma, method: `Lemma (inflections, inget tecken) ${checkToken}‚Üí${lemma}`, isCompound: false };\n        localSearchCache.set(token, result);\n        return result;\n      }\n    }\n  }\n\n  // 2.5Ô∏è‚É£ Sign language gloss variations (teckenspr√•ks-varianter)\n  if (signInflectionMap && signInflectionMap.has(token)) {\n    const baseGloss = signInflectionMap.get(token)!;\n    const glossMatch = getSignsForKey(baseGloss);\n    if (glossMatch) {\n      const sortedSigns = sortSignsByPreference(glossMatch.signs, baseGloss);\n      const result = { signs: sortedSigns, base: baseGloss, method: `Gloss variant (teckenspr√•k) ${token}‚Üí${baseGloss}`, isCompound: glossMatch.isCompound };\n      localSearchCache.set(token, result);\n      return result;\n    }\n  }\n\n  // 3Ô∏è‚É£ Alias / forkortning (local aliasMap contains mapping token -> targetKey)\n  if (aliasMap && aliasMap.has(token)) {\n    const aliasTarget = aliasMap.get(token)!;\n    const aliasMatch = getSignsForKey(aliasTarget);\n    if (aliasMatch) {\n      const sortedSigns = sortSignsByPreference(aliasMatch.signs, aliasTarget);\n      return { signs: sortedSigns, base: aliasTarget, method: `Alias (${token}‚Üí${aliasTarget})`, isCompound: aliasMatch.isCompound };\n    }\n  }\n\n  // 4Ô∏è‚É£ Suffix-strippning (try safe list)\n  for (const suf of SAFE_SUFFIXES) {\n    if (token.endsWith(suf) && token.length > suf.length + MIN_ROOT_LENGTH) {\n      const root = token.slice(0, -suf.length);\n      // ensure root fairly short? we already check MIN_ROOT_LENGTH\n      const rootMatch = getSignsForKey(root);\n      if (rootMatch) {\n        const sortedSigns = sortSignsByPreference(rootMatch.signs, root);\n        return { signs: sortedSigns, base: root, method: `Suffix-avklipp (-${suf})`, isCompound: rootMatch.isCompound };\n      }\n    }\n  }\n\n  // 5Ô∏è‚É£ Sammansatta ord (split heuristics) ‚Äî try longest left part first\n  // VIKTIGT: Hoppa √∂ver orddelning om ordet finns i inflectionMap (t.ex. \"f√∂rst√•r\" ska INTE bli \"f√∂rst+√•r\")\n  const hasInflection = inflectionMap && (inflectionMap.has(token) || inflectionMap.has(token.toLowerCase()));\n  if (!hasInflection) {\n    // We'll try split positions from longest left to shortest left but keep both parts >=2\n    for (let i = token.length - 2; i >= 2; i--) {\n      const left = token.slice(0, i);\n      const right = token.slice(i);\n      if (left.length < 2 || right.length < 2) continue;\n\n      // Check if both parts exist as keys\n      const leftMatch = getSignsForKey(left);\n      const rightMatch = getSignsForKey(right);\n      \n      if (leftMatch && rightMatch) {\n          // Sortera b√•da delarna baserat p√• preferenser\n          const sortedLeft = sortSignsByPreference(leftMatch.signs, left);\n          const sortedRight = sortSignsByPreference(rightMatch.signs, right);\n          // Return combination (both parts)\n          return { \n              signs: [...sortedLeft, ...sortedRight], \n              base: `${left}+${right}`, \n              method: 'Sammansatt ord', \n              isCompound: true, \n              parts: [left, right] \n          };\n      }\n    }\n  }\n\n\n  // 6Ô∏è‚É£ Fuzzy DISABLED - Testing without fuzzy matching for performance\n  // If fuzzy is needed, can be re-enabled by setting ENABLE_FUZZY = true\n  // This improves search performance significantly for correctly spelled words\n\n  // 7Ô∏è‚É£ Ingen lokal kandidat\n  localSearchCache.set(token, null);\n  cacheAccessOrder.push(token);\n  \n  // Begr√§nsa cache-storlek (LRU - ta bort minst nyligen anv√§nd)\n  if (localSearchCache.size > MAX_CACHE_SIZE && cacheAccessOrder.length > 0) {\n    const lruKey = cacheAccessOrder.shift();\n    if (lruKey) localSearchCache.delete(lruKey);\n  }\n  \n  return null;\n}\n\n// ---------- Top-level search: process text, keep whitespace & punctuation ----------\nexport async function doLocalSearch(text: string): Promise<WordMapEntry[]> {\n    if (text == null) text = '';\n    \n    // F√ñRB√ÑTTRAD NORMALISERING:\n    // 1. Ta bort extra whitespace\n    text = text.replace(/\\s+/g, ' ').trim();\n    // 2. Normalisera skiljetecken (mellanslag f√∂re/efter)\n    text = text.replace(/\\s*([.,!?;:])\\s*/g, '$1 ').trim();\n    \n    // Importera genuina tecken service\n    const { genuinaTeckenService } = await import('../genuina/genuinaTeckenService');\n    \n    const out: WordMapEntry[] = [];\n    const tokensAndDelimiters = text.split(/(\\s+|[.,!?;:\"()]+)/g).filter(Boolean);\n    const MAX_PHRASE_LENGTH = 4; // Max number of words to check for a phrase\n\n    let i = 0;\n    while (i < tokensAndDelimiters.length) {\n        const currentToken = tokensAndDelimiters[i];\n\n        // If it's a delimiter, just add it and move on.\n        if (/^[\\s\\.,!?:;\"()]+$/.test(currentToken)) {\n            out.push({ original: currentToken, base: currentToken, isWord: false, pos: 'PUNCT', signs: null });\n            i++;\n            continue;\n        }\n\n        let matchFound = false;\n        // Start checking for the longest possible multi-word phrase from the current position.\n        for (let phraseLen = MAX_PHRASE_LENGTH; phraseLen > 1; phraseLen--) {\n            const requiredTokensCount = (phraseLen * 2) - 1;\n            if (i + requiredTokensCount > tokensAndDelimiters.length) {\n                continue; // Not enough tokens to form this phrase length\n            }\n\n            const phraseTokens: string[] = [];\n            for (let j = 0; j < phraseLen; j++) {\n                phraseTokens.push(tokensAndDelimiters[i + j * 2]);\n            }\n            \n            const phraseKey = normalizeForLookup(phraseTokens.join(' '));\n            \n            // üîß PRIORITET: Kolla lexikonet F√ñRST (har alla video-IDn)\n            const lexikonSigns = getSignsForKey(phraseKey);\n            \n            if (lexikonSigns) {\n                const originalPhrase = tokensAndDelimiters.slice(i, i + requiredTokensCount).join('');\n                \n                // Kolla √§ven om det √§r ett genuint tecken (f√∂r badge/flagga)\n                const genuintTecken = genuinaTeckenService.find(phraseTokens.join(' '));\n                const isGenuine = genuintTecken && genuinaTeckenService.isLoaded();\n                \n                out.push({\n                    original: originalPhrase,\n                    base: phraseKey,\n                    isWord: true,\n                    pos: '',\n                    signs: lexikonSigns.signs,\n                    isCompound: lexikonSigns.isCompound || false,\n                    rationale: isGenuine ? `Genuint tecken + lexikon: ${phraseKey}` : `Frasmatch (${phraseKey})`,\n                    isGenuine: isGenuine,\n                    genuineTeckenId: genuintTecken?.id\n                });\n\n                i += requiredTokensCount;\n                matchFound = true;\n                break;\n            }\n            \n            // Om lexikonet inte har frasen, kolla genuina tecken som fallback\n            const genuintTecken = genuinaTeckenService.find(phraseTokens.join(' '));\n            if (genuintTecken && genuinaTeckenService.isLoaded()) {\n                const originalPhrase = tokensAndDelimiters.slice(i, i + requiredTokensCount).join('');\n                \n                out.push({\n                    original: originalPhrase,\n                    base: phraseKey,\n                    isWord: true,\n                    pos: '',\n                    signs: [{ id: genuintTecken.id, word: genuintTecken.tecken }],\n                    isCompound: false,\n                    rationale: `Genuint tecken: ${genuintTecken.tecken}`,\n                    isGenuine: true,\n                    genuineTeckenId: genuintTecken.id\n                });\n\n                i += requiredTokensCount;\n                matchFound = true;\n                break;\n            }\n            \n        }\n\n        // If no multi-word phrase was found, process the current single token.\n        if (!matchFound) {\n            const cand = await findCandidatesForToken(currentToken);\n            if (cand) {\n                out.push({\n                    original: currentToken,\n                    base: cand.base,\n                    isWord: true,\n                    pos: '',\n                    signs: cand.signs,\n                    isCompound: !!cand.isCompound,\n                    rationale: cand.method\n                });\n            } else {\n                 // Kontrollera om AI √§r aktiverat innan vi anv√§nder fallback\n                 const { appState } = await import('../../state');\n                 if (AI_FALLBACK && appState.aiEnabled) {\n                    try {\n                      const aiCand = await AI_FALLBACK(currentToken, text);\n                      if (aiCand) {\n                        out.push({\n                          original: currentToken, base: aiCand.base, isWord: true, pos: '',\n                          signs: aiCand.signs, isCompound: !!aiCand.isCompound, rationale: `AI-fallback: ${aiCand.method}`\n                        });\n                        i++; \n                        continue;\n                      }\n                    } catch (e) { console.warn('AI fallback error', e); }\n                 }\n                 out.push({ original: currentToken, base: normalizeForLookup(currentToken), isWord: true, pos: '', signs: null, isCompound: false, rationale: 'Ingen tr√§ff' });\n            }\n            i++;\n        }\n    }\n\n    return out;\n}\n\n\n// ---------- Initialization helper ----------\nexport function initLocalSearch(options?: InitOptions) {\n  if (!options) options = {};\n  AI_FALLBACK = options.aiFallback ?? null;\n  ENABLE_FUZZY = options.enableFuzzy ?? true;\n  FUZZY_MIN_LENGTH = options.fuzzyMinLength ?? 4;\n}\n\n// ---------- Small test helper (local quick test) ----------\nexport async function quickTestSample() {\n  const sample = 'Hur m√•r du? F√•glarna sjunger. Jag √§lskar att l√§ra ut b√∂cker.';\n  const res = await doLocalSearch(sample);\n  console.table(res.map(r => ({ original: r.original, base: r.base, rationale: r.rationale })));\n  return res;\n}\n\n// Export types (for consumer)\nexport type { Candidate };\n","path":null,"size_bytes":18186,"size_tokens":null},"src/styles/style.css":{"content":"/* --- RESPONSIVE DESIGN TOKENS --- */\n/* Fluid typography, spacing, and component sizing using clamp() */\n\n:root {\n    /* === TYPOGRAPHY - Fluid scaling === */\n    --text-xs: clamp(0.7rem, 0.65rem + 0.2vw, 0.8rem);\n    --text-sm: clamp(0.8rem, 0.75rem + 0.25vw, 0.9rem);\n    --text-base: clamp(0.9rem, 0.85rem + 0.3vw, 1rem);\n    --text-lg: clamp(1rem, 0.9rem + 0.4vw, 1.15rem);\n    --text-xl: clamp(1.15rem, 1rem + 0.5vw, 1.35rem);\n    --text-2xl: clamp(1.3rem, 1.1rem + 0.7vw, 1.6rem);\n    --text-3xl: clamp(1.5rem, 1.2rem + 1vw, 2rem);\n    \n    /* === SPACING - Fluid margins/padding === */\n    --space-xs: clamp(0.25rem, 0.2rem + 0.2vw, 0.4rem);\n    --space-sm: clamp(0.4rem, 0.35rem + 0.3vw, 0.6rem);\n    --space-md: clamp(0.6rem, 0.5rem + 0.5vw, 1rem);\n    --space-lg: clamp(1rem, 0.8rem + 0.8vw, 1.5rem);\n    --space-xl: clamp(1.5rem, 1.2rem + 1vw, 2.5rem);\n    \n    /* === COMPONENT SIZES === */\n    --btn-padding-x: clamp(0.75rem, 0.6rem + 0.5vw, 1.25rem);\n    --btn-padding-y: clamp(0.5rem, 0.4rem + 0.3vw, 0.75rem);\n    --btn-min-height: clamp(40px, 38px + 1vw, 48px);\n    --touch-target: clamp(44px, 40px + 1vw, 56px);\n    --icon-size: clamp(18px, 16px + 0.5vw, 24px);\n    --border-radius-responsive: clamp(8px, 6px + 0.5vw, 12px);\n    \n    /* === GRID/CARD SIZES === */\n    --card-min-width: clamp(100px, 90px + 5vw, 180px);\n    --card-gap: clamp(0.5rem, 0.4rem + 0.4vw, 1rem);\n    --modal-width: min(95vw, 600px);\n    --modal-padding: clamp(0.75rem, 0.6rem + 0.6vw, 1.5rem);\n    \n    /* === SAFE AREAS (for notched phones) === */\n    --safe-top: env(safe-area-inset-top, 0px);\n    --safe-bottom: env(safe-area-inset-bottom, 0px);\n    --safe-left: env(safe-area-inset-left, 0px);\n    --safe-right: env(safe-area-inset-right, 0px);\n}\n\n/* === GLOBAL RESPONSIVE BASE STYLES === */\nhtml {\n    font-size: 16px;\n    -webkit-text-size-adjust: 100%;\n    text-size-adjust: 100%;\n}\n\nbody {\n    font-size: var(--text-base);\n    padding-left: var(--safe-left);\n    padding-right: var(--safe-right);\n    min-height: 100svh; /* Use small viewport height for mobile */\n}\n\n/* Prevent horizontal scroll */\nhtml, body {\n    overflow-x: hidden;\n    max-width: 100vw;\n}\n\n/* === RESPONSIVE BUTTONS === */\n.btn {\n    padding: var(--btn-padding-y) var(--btn-padding-x);\n    min-height: var(--btn-min-height);\n    font-size: var(--text-sm);\n    border-radius: var(--border-radius-responsive);\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    gap: var(--space-sm);\n    touch-action: manipulation; /* Better touch handling */\n}\n\n.btn-sm {\n    padding: var(--space-xs) var(--space-sm);\n    min-height: 32px;\n    font-size: var(--text-xs);\n}\n\n.btn svg, .btn-sm svg {\n    width: var(--icon-size);\n    height: var(--icon-size);\n    flex-shrink: 0;\n}\n\n/* === RESPONSIVE MODALS === */\n.modal-content {\n    width: var(--modal-width);\n    max-width: 95vw;\n    max-height: calc(100svh - var(--safe-top) - var(--safe-bottom) - 2rem);\n    padding: var(--modal-padding);\n    margin: 1rem;\n    overflow-y: auto;\n}\n\n/* === ORIENTATION ADJUSTMENTS === */\n@media (orientation: landscape) and (max-height: 500px) {\n    :root {\n        --modal-padding: clamp(0.5rem, 0.4rem + 0.4vw, 1rem);\n        --space-lg: clamp(0.75rem, 0.6rem + 0.5vw, 1rem);\n    }\n    \n    .modal-content {\n        max-height: calc(100svh - 1rem);\n    }\n}\n\n/* --- INTERACTIONS, ANIMATIONS, AND THEME-SPECIFIC STYLES --- */\n\n/* AI Status Indicator */\n#aiStatusIndicator {\n    display: inline-block;\n    width: 8px;\n    height: 8px;\n    border-radius: 50%;\n    animation: pulse-status 2s infinite;\n}\n\n#aiStatusIndicator.ai-online {\n    background-color: #22c55e;\n    box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);\n}\n\n#aiStatusIndicator.ai-offline {\n    background-color: #ef4444;\n    box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);\n}\n\n#aiStatusIndicator.ai-loading {\n    background-color: #f59e0b;\n    box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);\n}\n\n@keyframes pulse-status {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.6; }\n}\n\n/* Clickable Word Spans - Subtle styling */\n.clickable-word-span { \n    transition: all var(--transition-fast) ease; \n    cursor: pointer; \n    padding: 0.1rem 0.2rem; \n    border-radius: var(--border-radius-sm);\n    border-bottom: 1px solid transparent;\n    color: var(--text-primary);\n}\n.clickable-word-span:hover { \n    background-color: var(--hover-bg);\n    border-bottom-color: var(--text-secondary);\n}\n.clickable-word-span.has-video { \n    color: var(--text-primary);\n    border-bottom: 1px dotted var(--text-secondary);\n}\n.clickable-word-span.has-video:hover {\n    border-bottom-style: solid;\n    border-bottom-color: var(--accent-cyan);\n}\n.clickable-word-span.is-spelled-out {\n    color: var(--text-secondary);\n    font-style: italic;\n    border-bottom: 1px dotted var(--text-tertiary);\n}\n.clickable-word-span.has-multiple-videos { \n    border-bottom-width: 2px;\n    border-bottom-style: dotted;\n}\n.clickable-word-span.is-compound { \n    border-bottom-style: dashed; \n}\n.clickable-word-span.no-video { \n    color: var(--text-tertiary); \n    opacity: 0.6;\n    border-bottom: none;\n}\n\n/* Modal Transitions - \"Soft Crystallize\" Animation */\n.modal {\n    background-color: rgba(0, 0, 0, 0.4); \n    backdrop-filter: blur(0px); /* Start clear */\n    -webkit-backdrop-filter: blur(0px);\n    opacity: 0; \n    /* Use the slower modal transition for smoothness */\n    transition: \n        opacity var(--transition-modal), \n        visibility var(--transition-modal),\n        backdrop-filter var(--transition-modal),\n        -webkit-backdrop-filter var(--transition-modal);\n}\n\n.modal.show { \n    opacity: 1; \n    backdrop-filter: blur(8px); /* Fade into blur */\n    -webkit-backdrop-filter: blur(8px);\n}\n\n.modal-content {\n    background-color: var(--bg-light); \n    border: 1px solid var(--glass-border);\n    box-shadow: var(--shadow-glass);\n    backdrop-filter: blur(20px);\n    -webkit-backdrop-filter: blur(20px);\n    opacity: 0; /* Start invisible */\n    transform: scale(0.92) translateY(25px); /* Start slightly smaller and lower */\n    /* Transform moves slower, opacity comes in slightly quicker */\n    transition: \n        transform var(--transition-modal),\n        opacity 0.4s ease-out;\n}\n\n.modal.show .modal-content { \n    opacity: 1;\n    transform: scale(1) translateY(0); /* Land softly */\n}\n\n.modal-close-btn { \n    transition: all var(--transition-fast) ease; \n    background-color: rgba(255, 255, 255, 0.05);\n    border: 1px solid var(--border-color);\n    color: var(--text-secondary);\n}\n.modal-close-btn:hover {\n    background-color: var(--red-vote);\n    border-color: var(--red-vote);\n    color: white;\n    transform: rotate(90deg);\n}\n\n/* Animations */\n@keyframes rotate {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}\n@keyframes glow-pulse { \n    0%, 100% { box-shadow: 0 0 5px var(--primary-blue); } \n    50% { box-shadow: 0 0 20px 2px var(--accent-cyan); } \n}\n.glow-attention { animation: glow-pulse 2s infinite; }\n\n@keyframes pulse { 50% { opacity: .5; } }\n#voiceInputBtn.is-listening {\n    color: var(--red-vote);\n    animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n}\n\n/* --- App Header & Logo --- */\n.app-header {\n    background-color: var(--header-bg);\n    border-color: var(--border-color);\n}\n.app-title {\n    background-image: var(--primary-gradient);\n    -webkit-background-clip: text;\n    color: transparent;\n}\n.footer-text {\n    color: var(--text-secondary);\n}\n\n.logo-circle {\n  position: relative;\n  border-radius: 50%;\n  width: 36px;\n  height: 36px;\n  flex-shrink: 0;\n  background: var(--primary-gradient);\n  box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);\n}\n\n.logo-crescent {\n  position: absolute;\n  border-radius: 50%;\n  right: -2px;\n  top: -2px;\n  width: 26px;\n  height: 26px;\n  background-color: var(--bg-body); /* Dynamic based on theme */\n  transition: transform 0.5s ease, background-color 0.3s;\n  transform: scale(1);\n}\n\nhtml[data-theme='light'] .logo-crescent {\n  transform: scale(0);\n}\n\n/* --- Animated Input Aurora Wrapper --- */\n.input-aurora-wrapper {\n    position: relative;\n    padding: 2px; /* Tunnare kant */\n    border-radius: calc(var(--border-radius-md) + 2px); \n    overflow: hidden;\n    background-color: var(--border-color); /* Default neutral border */\n    transition: background-color 0.3s ease;\n}\n\n.input-aurora-wrapper::before {\n    content: '';\n    position: absolute;\n    z-index: 0;\n    top: -150%; left: -150%; width: 400%; height: 400%; /* Ensure full coverage during rotation */\n    background: conic-gradient(\n        from 0deg, \n        transparent 0deg, \n        transparent 100deg,\n        var(--primary-blue) 140deg, \n        var(--accent-cyan) 180deg, \n        var(--primary-blue) 220deg,\n        transparent 260deg,\n        transparent 360deg\n    );\n    animation: rotate 3s linear infinite;\n    opacity: 0;\n    transition: opacity 0.5s ease;\n    pointer-events: none;\n}\n\n/* VIKTIGT: Animationen k√∂rs nu ENDAST n√§r klassen .is-searching finns */\n.input-aurora-wrapper.is-searching::before {\n    opacity: 1;\n}\n\n#originalTextDisplay {\n    position: relative;\n    z-index: 1;\n    border: none;\n    background-color: var(--bg-dark);\n}\n\n/* --- Video Cards --- */\n.video-card-title {\n    background: linear-gradient(to top, rgba(2, 6, 23, 0.95) 10%, transparent);\n    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);\n    color: #fff; /* Always white text on title for contrast */\n}\n\n/* --- Alphabet Grid - Compact layout for all letters visible at once --- */\n:root {\n    --alphabet-cell-size: 58px;\n    --alphabet-gap: 6px;\n}\n\n.video-grid-alphabet {\n    display: grid;\n    grid-template-columns: repeat(5, 1fr); /* 5 columns on mobile */\n    gap: var(--alphabet-gap);\n    padding: 0.25rem;\n    width: 100%;\n    box-sizing: border-box;\n}\n\n/* Tablet: 6 columns */\n@media (min-width: 420px) {\n    .video-grid-alphabet {\n        grid-template-columns: repeat(6, 1fr);\n    }\n}\n\n/* Desktop: 7-8 columns */\n@media (min-width: 600px) {\n    .video-grid-alphabet {\n        grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));\n        gap: 0.5rem;\n    }\n}\n\n.video-grid-alphabet .video-card {\n    width: 100% !important;\n    height: auto !important;\n    min-width: unset !important;\n    max-width: unset !important;\n    aspect-ratio: unset !important;\n    padding: 0 !important;\n    margin: 0 !important;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    background: var(--bg-light);\n    border-radius: 8px;\n    overflow: hidden;\n}\n\n.video-grid-alphabet .video-card video {\n    width: 100% !important;\n    height: auto !important;\n    aspect-ratio: 1 / 1;\n    object-fit: cover;\n    background: #1a1a2e; /* Dark blue instead of black */\n}\n\n.video-grid-alphabet .video-card-title {\n    font-size: 0.85rem !important;\n    padding: 0.15rem 0.25rem !important;\n    font-weight: bold;\n    text-align: center;\n    width: 100%;\n    background: transparent !important;\n}\n\n.video-grid-alphabet .video-card .variant-counter,\n.video-grid-alphabet .video-card .video-loader {\n    display: none !important;\n}\n\n/* Alphabet modal specific adjustments */\n.alphabet-modal-content {\n    width: 95vw !important;\n    max-width: 380px !important;\n    padding: 0.75rem !important;\n    margin: 0 auto;\n}\n\n@media (min-width: 420px) {\n    .alphabet-modal-content {\n        max-width: 450px !important;\n    }\n}\n\n@media (min-width: 600px) {\n    .alphabet-modal-content {\n        max-width: 550px !important;\n        padding: 1rem !important;\n    }\n}\n\n@media (min-width: 800px) {\n    .alphabet-modal-content {\n        max-width: 700px !important;\n    }\n}\n\n#videoGrid .video-card, #alphabetGrid .video-card {\n    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.3s, border-color 0.3s;\n    background-color: var(--bg-light);\n    border: 1px solid var(--border-color);\n}\n\n#videoGrid .video-card:hover, #alphabetGrid .video-card:hover {\n    transform: scale(1.03) translateY(-2px);\n    z-index: 10;\n    box-shadow: 0 20px 30px -5px rgba(0, 0, 0, 0.4);\n    border-color: rgba(255,255,255,0.4);\n}\n\n.video-card.is-selected {\n    border-color: var(--selection-yellow) !important;\n    box-shadow: var(--selection-glow) !important;\n    transform: scale(1.02);\n}\n\n/* Mobile Video Card Sizing - Portrait */\n@media (max-width: 640px) and (orientation: portrait) {\n    #videoGrid {\n        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)) !important;\n        gap: 0.75rem !important;\n    }\n    \n    #videoGrid .video-card, #alphabetGrid .video-card {\n        max-width: 150px;\n    }\n    \n    .video-card-player {\n        max-height: 150px;\n    }\n    \n    .video-card-title {\n        font-size: 0.85rem;\n        padding: 0.5rem;\n    }\n}\n\n/* Mobile Video Card Sizing - Landscape */\n@media (max-width: 640px) and (orientation: landscape) {\n    #videoGrid {\n        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) !important;\n        gap: 0.5rem !important;\n    }\n    \n    #videoGrid .video-card, #alphabetGrid .video-card {\n        max-width: 140px;\n    }\n    \n    .video-card-player {\n        max-height: 120px;\n    }\n    \n    .video-card-title {\n        font-size: 0.75rem;\n        padding: 0.25rem;\n    }\n}\n\n/* Mobile Controls */\n@media (max-width: 640px) {\n    #videoNavControls {\n        flex-wrap: wrap;\n        gap: 0.5rem !important;\n        justify-content: center;\n    }\n    \n    #videoNavControls button {\n        padding: 0.5rem 1rem;\n        font-size: 0.85rem;\n    }\n    \n    .modal-content {\n        width: 95vw;\n        max-width: 500px;\n        max-height: 85vh;\n        overflow-y: auto;\n    }\n    \n    .grid.grid-cols-3 {\n        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)) !important;\n    }\n}\n\n/* === RESPONSIVE HEADER === */\n.app-header {\n    padding-top: var(--safe-top);\n}\n\n.header-container {\n    padding-left: var(--space-md);\n    padding-right: var(--space-md);\n}\n\n.header-inner {\n    height: clamp(3rem, 2.5rem + 1.5vw, 4rem);\n}\n\n@media (orientation: landscape) and (max-height: 500px) {\n    .header-inner {\n        height: 2.75rem;\n    }\n}\n\n.app-header h1, .app-title {\n    font-size: var(--text-lg) !important;\n}\n\n@media (max-width: 400px) {\n    .app-header h1, .app-title {\n        font-size: var(--text-base) !important;\n    }\n}\n\n/* === ACTION BUTTONS GRID === */\n.action-buttons-grid {\n    display: grid;\n    grid-template-columns: repeat(3, 1fr);\n    gap: var(--space-sm);\n}\n\n@media (max-width: 360px) {\n    .action-buttons-grid {\n        grid-template-columns: 1fr 1fr;\n        gap: var(--space-xs);\n    }\n    \n    .action-buttons-grid .btn:last-child {\n        grid-column: span 2;\n    }\n}\n\n.action-buttons-grid .btn {\n    flex-direction: column;\n    gap: var(--space-xs);\n    padding: var(--space-sm);\n    font-size: var(--text-sm);\n}\n\n.action-buttons-grid .btn svg {\n    width: clamp(1.25rem, 1rem + 0.5vw, 1.5rem);\n    height: clamp(1.25rem, 1rem + 0.5vw, 1.5rem);\n}\n\n@media (min-width: 480px) {\n    .action-buttons-grid .btn {\n        flex-direction: row;\n        gap: var(--space-sm);\n    }\n}\n\n/* === RESPONSIVE MAIN LAYOUT === */\n.main-container, main {\n    padding-top: calc(3.5rem + var(--safe-top) + var(--space-md));\n    padding-bottom: calc(var(--safe-bottom) + var(--space-lg));\n    padding-left: var(--space-md);\n    padding-right: var(--space-md);\n    gap: var(--space-lg);\n}\n\n@media (min-width: 640px) {\n    .main-container, main {\n        padding-left: var(--space-lg);\n        padding-right: var(--space-lg);\n    }\n}\n\n/* Input action buttons - removed absolute positioning, now regular buttons */\n\n/* === RESPONSIVE INPUT AREA === */\n#originalTextDisplay {\n    font-size: var(--text-base);\n    padding: var(--space-md);\n    min-height: clamp(100px, 15vh, 180px);\n}\n\n.input-aurora-wrapper {\n    position: relative;\n}\n\n.input-aurora-wrapper button {\n    min-width: var(--touch-target);\n    min-height: var(--touch-target);\n    padding: var(--space-sm);\n}\n\n@media (max-width: 360px) {\n    .input-aurora-wrapper button {\n        min-width: 36px;\n        min-height: 36px;\n        padding: 0.25rem;\n    }\n    \n    .input-aurora-wrapper button svg {\n        width: 18px;\n        height: 18px;\n    }\n    \n    #imageInputBtn {\n        right: calc(36px + var(--space-sm));\n    }\n}\n\n@media (orientation: landscape) and (max-height: 500px) {\n    #originalTextDisplay {\n        min-height: 70px;\n        padding-bottom: calc(var(--space-sm) + 2rem);\n    }\n}\n\n/* === RESPONSIVE VIDEO GRID === */\n#videoGrid {\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(var(--card-min-width), 1fr));\n    gap: var(--card-gap);\n    padding: var(--space-sm);\n}\n\n#videoGrid .video-card {\n    padding: var(--space-xs);\n    border-radius: var(--border-radius-responsive);\n}\n\n.video-card-title {\n    font-size: var(--text-sm);\n    padding: var(--space-xs) var(--space-sm);\n}\n\n/* === RESPONSIVE CARD STYLING === */\n.card {\n    padding: var(--space-md);\n    border-radius: var(--border-radius-responsive);\n}\n\n/* === LANDSCAPE ORIENTATION SPECIFIC === */\n@media (orientation: landscape) and (max-height: 500px) {\n    main {\n        padding-top: calc(3rem + var(--safe-top) + var(--space-sm));\n        gap: var(--space-md);\n    }\n    \n    .app-header > div > div {\n        height: 2.75rem !important;\n    }\n    \n    #originalTextDisplay {\n        min-height: 80px;\n    }\n    \n    #videoGrid {\n        grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));\n    }\n    \n    .video-card-title {\n        font-size: var(--text-xs);\n        padding: 0.15rem 0.25rem;\n    }\n}\n\n/* === SETTINGS MODAL RESPONSIVE === */\n#settingsModal .modal-content {\n    width: min(95vw, 500px);\n}\n\n#settingsModal h4 {\n    font-size: var(--text-sm);\n}\n\n#settingsModal button {\n    padding: var(--space-sm) var(--space-md);\n}\n\n#settingsModal .text-base {\n    font-size: var(--text-sm);\n}\n\n#settingsModal .text-xs {\n    font-size: var(--text-xs);\n}\n\n/* === TOUCH-FRIENDLY IMPROVEMENTS === */\n@media (pointer: coarse) {\n    .btn {\n        min-height: var(--touch-target);\n    }\n    \n    .btn-sm {\n        min-height: 40px;\n    }\n    \n    input[type=\"checkbox\"] {\n        min-width: 20px;\n        min-height: 20px;\n    }\n    \n    .modal-close-btn {\n        min-width: var(--touch-target);\n        min-height: var(--touch-target);\n        font-size: 1.5rem;\n    }\n}\n\n/* Landscape Modal Adjustment */\n@media (max-width: 640px) and (orientation: landscape) {\n    .modal-content {\n        max-height: 90vh;\n    }\n}\n\n/* --- Bottom Navigation --- */\n#bottom-nav {\n    position: fixed;\n    bottom: 1.5rem;\n    left: 50%;\n    transform: translateX(-50%);\n    z-index: 40;\n    width: auto;\n}\n\n.bottom-nav-menu {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.5rem 0.75rem;\n    background-color: rgba(15, 23, 42, 0.7);\n    backdrop-filter: blur(16px);\n    -webkit-backdrop-filter: blur(16px);\n    border: 1px solid rgba(255, 255, 255, 0.15);\n    border-radius: 2rem;\n    box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);\n}\n\nhtml[data-theme='light'] .bottom-nav-menu {\n    background-color: rgba(255, 255, 255, 0.75);\n    border: 1px solid rgba(255, 255, 255, 0.6);\n    box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.1);\n}\n\n#bottom-nav .nav-btn {\n    width: 3.5rem;\n    height: 3.5rem;\n    border-radius: 50%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    color: var(--text-secondary);\n    transition: all 0.2s;\n    background: transparent;\n}\n\n#bottom-nav .nav-btn:hover:not(:disabled) {\n    background-color: rgba(255, 255, 255, 0.1);\n    color: var(--text-primary);\n    transform: translateY(-2px);\n}\n\nhtml[data-theme='light'] #bottom-nav .nav-btn:hover:not(:disabled) {\n    background-color: rgba(0, 0, 0, 0.05);\n}\n\n#bottom-nav .nav-btn-primary {\n    background: var(--primary-gradient);\n    color: white !important;\n    box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);\n}\n\n#bottom-nav .nav-btn-primary:hover:not(:disabled) {\n    box-shadow: 0 8px 25px rgba(99, 102, 241, 0.6);\n    transform: translateY(-4px) scale(1.05);\n}\n\n#bottom-nav .nav-text {\n    font-size: 0.65rem;\n    margin-top: 2px;\n    font-weight: 600;\n}\n\n#bottom-nav .nav-btn.glow-attention {\n    animation: feedback-glow 1.5s ease-in-out infinite;\n}\n\n@keyframes feedback-glow {\n    0%, 100% {\n        box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);\n    }\n    50% {\n        box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 30px rgba(59, 130, 246, 0.4);\n    }\n}\n\n#feedbackBadge {\n    position: absolute;\n    top: -2px;\n    right: -2px;\n    min-width: 18px;\n    height: 18px;\n    font-size: 0.65rem;\n    font-weight: 700;\n    border-radius: 50%;\n    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);\n    color: white;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.5);\n    animation: badge-pop 0.3s ease-out;\n}\n\n@keyframes badge-pop {\n    0% { transform: scale(0); }\n    50% { transform: scale(1.2); }\n    100% { transform: scale(1); }\n}\n\n/* Disabled GLOSA button for non-dev users */\n.disabled-for-users {\n    opacity: 0.4 !important;\n    cursor: not-allowed !important;\n    pointer-events: none !important;\n    background: linear-gradient(135deg, #4b5563 0%, #374151 100%) !important;\n}\n\n.disabled-for-users:hover {\n    transform: none !important;\n    box-shadow: none !important;\n}\n\n/* --- Progress Bars --- */\n.progress-bar-wrapper {\n    background-color: rgba(255, 255, 255, 0.1);\n    box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);\n}\n.progress-bar-inner {\n    background: var(--primary-gradient);\n    box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);\n}\n.progress-bar-inner.completed {\n    background: var(--green-vote);\n    box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);\n}\n\n/* Header Specific Progress */\n.progress-bar-wrapper-header {\n    background-color: rgba(255,255,255,0.15);\n}\n\n/* --- Chat Styling --- */\n.chat-bubble-user {\n    background: var(--primary-gradient);\n    color: white;\n    box-shadow: 0 4px 15px rgba(99, 102, 241, 0.2);\n    border: none;\n}\n\n.chat-bubble-ai {\n    background-color: var(--glass-bg);\n    border: 1px solid var(--glass-border);\n    color: var(--text-primary);\n    backdrop-filter: blur(8px);\n}\n\n/* --- Grammar Grid --- */\n.grammar-grid {\n    gap: var(--space-lg);\n}\n\n#grammarPlaceholder {\n    border: 2px dashed var(--border-color);\n    border-radius: var(--border-radius-lg);\n    color: var(--text-secondary);\n    background-color: rgba(255,255,255,0.02);\n}\n\n/* --- Theme Toggle --- */\n.theme-toggle-button {\n    background-color: var(--bg-light);\n    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), inset -2px -2px 5px rgba(255,255,255,0.05);\n}\nhtml[data-theme='light'] .theme-toggle-button {\n    box-shadow: inset 2px 2px 5px rgba(0,0,0,0.05), inset -2px -2px 5px rgba(255,255,255,0.8);\n}\ninput:checked ~ .theme-toggle-button {\n    box-shadow: 0 0 15px var(--primary-blue);\n}\n\n/* Tool Buttons */\n.tool-btn {\n    background-color: var(--bg-light);\n    border: 1px solid var(--border-color);\n    border-radius: 50%;\n    width: 3rem; height: 3rem;\n    display: flex; align-items: center; justify-content: center;\n    color: var(--text-secondary);\n    transition: all 0.2s;\n}\n.tool-btn:hover:not(:disabled) {\n    background-color: var(--hover-bg);\n    color: var(--text-primary);\n    transform: scale(1.1);\n    border-color: var(--text-secondary);\n}\n.tool-btn.active {\n    background: var(--primary-gradient);\n    border-color: transparent;\n    color: white !important;\n    box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);\n}\n.tool-btn.active svg { color: white !important; }\n","path":null,"size_bytes":23479,"size_tokens":null},"src/modules/features/wordInfo.ts":{"content":"import { fullLexiconMap } from '../../state';\nimport { buildVideoUrl, playVideo } from '../../services/media/videoService';\n\nexport function displayWordInfo(word: string) {\n    const wordInfoTitle = document.getElementById('wordInfoTitle');\n    const currentWordName = document.getElementById('currentWordName');\n    const examplesAndRelatedContainer = document.getElementById('examplesAndRelatedContainer');\n\n    if (!wordInfoTitle || !currentWordName) return;\n\n    const normalizedWord = word.toLowerCase();\n    const entries = fullLexiconMap.get(normalizedWord) || [];\n\n    // Clear previous content\n    if (examplesAndRelatedContainer) {\n        examplesAndRelatedContainer.classList.add('hidden');\n    }\n\n    if (entries.length === 0) return;\n\n    // Set title\n    currentWordName.textContent = word;\n    wordInfoTitle.style.display = 'block';\n    \n    // Add gloss/explanation if available\n    const entry = entries[0];\n    if (entry.gloss) {\n        const glossEl = document.createElement('p');\n        glossEl.className = 'text-sm text-gray-400 mb-4 italic';\n        glossEl.innerHTML = `<strong>F√∂rklaring:</strong> ${entry.gloss}`;\n        wordInfoTitle.parentElement?.insertBefore(glossEl, examplesAndRelatedContainer);\n    }\n}\n","path":null,"size_bytes":1240,"size_tokens":null},"src/modules/genuina/__tests__/genuinaHandlers.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as genuinaHandlers from '../genuinaHandlers';\n\ndescribe('genuinaHandlers module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(genuinaHandlers).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r genuinaHandlers-logik h√§r\n});\n","path":null,"size_bytes":420,"size_tokens":null},"scripts/check_video_links.js":{"content":"// Script: check_video_links.js\n// L√§ser lexikon fr√•n snabb-mapp, bygger videol√§nkar och testar om video finns\n// K√∂r: node scripts/check_video_links.js\n\nconst fs = require('fs');\nconst path = require('path');\nconst https = require('https');\n\n// Hitta alla lexikonfiler automatiskt i snabb-mappen\nconst SNABB_DIR = 'snabb';\nlet LEXICON_FILES = [];\ntry {\n  LEXICON_FILES = fs.readdirSync(path.resolve(SNABB_DIR))\n    .filter(f => f.startsWith('lexikon_sammanslagen_del_') && f.endsWith('.json'))\n    .map(f => path.join(SNABB_DIR, f));\n  if (LEXICON_FILES.length === 0) {\n    console.error('Inga lexikonfiler hittades i', SNABB_DIR);\n  }\n} catch (err) {\n  console.error('Kunde inte l√§sa mappen', SNABB_DIR, err);\n}\n\nfunction buildVideoUrl(word, id) {\n  const xx = id.substring(0, 2);\n  // Specialfall-mappning\n  const specialCases = {\n    'andraspr√•k': 'l2',\n    // L√§gg till fler specialfall h√§r vid behov\n  };\n  let wordForUrl;\n  if (specialCases[word.toLowerCase()]) {\n    wordForUrl = specialCases[word.toLowerCase()];\n  } else {\n    wordForUrl = word.toLowerCase()\n      .replace(/√•|√§/g, 'a')\n      .replace(/√∂/g, 'o');\n    // Ers√§tt alla sekvenser av mellanslag och bindestreck mellan siffror med ett bindestreck\n    wordForUrl = wordForUrl.replace(/\\s*[- ]\\s*/g, '-');\n    // Ta bort allt utom bokst√§ver, siffror och bindestreck\n    wordForUrl = wordForUrl.replace(/[^a-z0-9\\-]/g, '');\n    // Ta bort flera bindestreck i rad\n    wordForUrl = wordForUrl.replace(/-+/g, '-');\n    // Ta bort bindestreck i b√∂rjan/slut\n    wordForUrl = wordForUrl.replace(/^[-]+|[-]+$/g, '');\n  }\n  return `https://teckensprakslexikon.su.se/movies/${xx}/180x180/${wordForUrl}-${id}-tecken.mp4`;\n}\n\nfunction checkVideo(url) {\n  return new Promise(resolve => {\n    try {\n      https.get(url, res => {\n        resolve(res.statusCode === 200);\n      }).on('error', () => resolve(false));\n    } catch (err) {\n      resolve(false);\n    }\n  });\n}\n\nasync function main() {\n  let allEntries = [];\n  for (const file of LEXICON_FILES) {\n    try {\n      if (!fs.existsSync(path.resolve(file))) {\n        console.error('Lexikonfil saknas:', file);\n        continue;\n      }\n      const raw = fs.readFileSync(path.resolve(file), 'utf8');\n      const data = JSON.parse(raw);\n      if (!data.lexicon) {\n        console.error('Ingen lexicon-lista i:', file);\n        continue;\n      }\n      allEntries = allEntries.concat(data.lexicon);\n    } catch (err) {\n      console.error('Fel vid l√§sning/parsing av', file, err);\n    }\n  }\n  console.log(`Totalt ${allEntries.length} lexikonposter.`);\n    let found = [], missing = [];\n    const maxParallel = 10;\n    let index = 0;\n    async function runBatch() {\n      const batch = [];\n      for (let j = 0; j < maxParallel && index < allEntries.length; j++, index++) {\n        const { word, id } = allEntries[index];\n        const url = buildVideoUrl(word, id);\n        batch.push(\n          checkVideo(url).then(ok => {\n            if (ok) found.push(id);\n            else missing.push(id);\n            console.log(`${id}: ${ok ? 'OK' : 'saknas'} - ${url}`);\n          }).catch(err => {\n            console.error(`Fel vid test av video ${id}:`, err);\n          })\n        );\n      }\n      await Promise.all(batch);\n      if (index < allEntries.length) {\n        await runBatch();\n      }\n    }\n    await runBatch();\n  console.log(`\\nFungerande video-id: ${found.join(', ')}`);\n  console.log(`Saknade video-id: ${missing.join(', ')}`);\n  // Spara resultat till fil\n  const result = {\n    date: new Date().toISOString(),\n    found,\n    missing\n  };\n  fs.writeFileSync('video_check_results.json', JSON.stringify(result, null, 2), 'utf8');\n  console.log('Resultat sparat i video_check_results.json');\n}\n\nmain();\n","path":null,"size_bytes":3734,"size_tokens":null},"src/utils/textUtils.ts":{"content":"\nexport function markdownToHtml(text: string): string {\n    let safeText = text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&quot;\").replace(/'/g, \"&#039;\");\n    \n    // Handle Bold\n    safeText = safeText.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');\n    \n    // Handle Code Blocks with Copy Button\n    safeText = safeText.replace(/```(json)?\\n([\\s\\S]*?)\\n```/g, (match, lang, code) => {\n        return `\n        <div class=\"code-block-wrapper\">\n            <div class=\"code-block-header\">\n                <button class=\"code-copy-btn\" onclick=\"/* Event listener handled globally */\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\" />\n                    </svg>\n                    Kopiera\n                </button>\n            </div>\n            <code class=\"chat-code-block\">${code}</code>\n        </div>`;\n    });\n    \n    // Handle Inline Code\n    safeText = safeText.replace(/`([^`]+)`/g, '<code class=\"bg-gray-700 text-purple-300 px-1 py-0.5 rounded\">$1</code>');\n\n    // Handle Newlines\n    safeText = safeText.replace(/\\n/g, '<br>');\n\n    return safeText;\n}\n","path":null,"size_bytes":1371,"size_tokens":null},"src/modules/feedback/feedbackPreviewModal.ts":{"content":"\nimport { feedbackCollector, FeedbackItem } from './feedbackCollector';\nimport { showMessage } from '../../ui';\nimport { openModal, closeModal } from '../../components/modals/ModalSystem';\nimport { clearFeedbackData } from '../../components/modals';\nimport { updateFeedbackBadge } from '../../services/ui/feedbackNotificationService';\n\nlet modalElement: HTMLElement | null = null;\nlet googleFormsUrl: string = '';\n\nconst FORMS_URL_KEY = 'sts-google-forms-url';\nconst DEFAULT_FORMS_URL = 'https://docs.google.com/forms/d/e/1FAIpQLSc8XbRtth7AIBK_kn7LEYf1UG4KAbPexoa7d0vHgIYjpIO5zQ/viewform';\n\nexport function initFeedbackPreviewModal() {\n    loadFormsUrl();\n    createModalHtml();\n    setupEventListeners();\n}\n\nfunction loadFormsUrl() {\n    googleFormsUrl = localStorage.getItem(FORMS_URL_KEY) || DEFAULT_FORMS_URL;\n}\n\nfunction saveFormsUrl(url: string) {\n    googleFormsUrl = url;\n    localStorage.setItem(FORMS_URL_KEY, url);\n}\n\nfunction createModalHtml() {\n    const existingModal = document.getElementById('feedbackPreviewModal');\n    if (existingModal) {\n        existingModal.remove();\n    }\n    \n    const modal = document.createElement('div');\n    modal.id = 'feedbackPreviewModal';\n    modal.className = 'modal hidden';\n    modal.innerHTML = `\n        <div class=\"absolute inset-0 bg-black/40\" id=\"feedbackPreviewBackdrop\"></div>\n        <div class=\"modal-content\" style=\"max-width: 700px; max-height: 85vh; overflow-y: auto;\">\n            <div class=\"flex justify-between items-center mb-4\">\n                <h3 class=\"text-xl font-bold flex items-center gap-2\">\n                    <span>üìã</span>\n                    <span>Samlad Feedback</span>\n                    <span id=\"feedbackPreviewCount\" class=\"text-sm bg-blue-500 text-white px-2 py-0.5 rounded-full\">0</span>\n                </h3>\n                <button id=\"feedbackPreviewClose\" class=\"text-gray-400 hover:text-white text-2xl leading-none\">&times;</button>\n            </div>\n            \n            <div class=\"flex gap-2 items-center justify-between mb-3\">\n                <label class=\"text-sm font-semibold text-gray-300\">Feedbacktext:</label>\n                <button id=\"feedbackCopyBtn\" class=\"btn btn-secondary btn-sm flex items-center justify-center gap-1\">\n                    <svg class=\"h-3 w-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"></path></svg>\n                    Kopiera\n                </button>\n            </div>\n            \n            <div id=\"feedbackPreviewContent\" class=\"bg-gray-900 p-4 rounded border border-gray-700 text-sm font-mono whitespace-pre-wrap max-h-[40vh] overflow-y-auto mb-4\">\n                Ingen feedback √§nnu...\n            </div>\n            \n            <div class=\"space-y-4\">\n                <div class=\"flex gap-2\">\n                    <a id=\"feedbackSendBtn\" href=\"https://docs.google.com/forms/d/e/1FAIpQLSc8XbRtth7AIBK_kn7LEYf1UG4KAbPexoa7d0vHgIYjpIO5zQ/viewform\" target=\"_blank\" class=\"btn btn-primary flex-1 flex items-center justify-center gap-2\">\n                        <svg class=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\"></path></svg>\n                        √ñppna Google Forms\n                    </a>\n                </div>\n                \n                <div class=\"pt-4 border-t border-gray-700\">\n                    <button id=\"feedbackClearBtn\" class=\"text-red-400 hover:text-red-300 text-sm underline\">\n                        Rensa all feedback\n                    </button>\n                </div>\n            </div>\n        </div>\n    `;\n    \n    document.body.appendChild(modal);\n    modalElement = modal;\n}\n\nfunction setupEventListeners() {\n    if (!modalElement) return;\n    \n    const backdrop = modalElement.querySelector('#feedbackPreviewBackdrop');\n    const closeBtn = modalElement.querySelector('#feedbackPreviewClose');\n    const copyBtn = modalElement.querySelector('#feedbackCopyBtn');\n    const clearBtn = modalElement.querySelector('#feedbackClearBtn');\n    \n    backdrop?.addEventListener('click', () => closeFeedbackPreviewModal());\n    closeBtn?.addEventListener('click', () => closeFeedbackPreviewModal());\n    \n    copyBtn?.addEventListener('click', async () => {\n        const text = feedbackCollector.format();\n        try {\n            await navigator.clipboard.writeText(text);\n            showMessage('Kopierat till urklipp!', 'success');\n        } catch (e) {\n            showMessage('Kunde inte kopiera', 'error');\n        }\n    });\n    \n    clearBtn?.addEventListener('click', () => {\n        if (confirm('√Ñr du s√§ker p√• att du vill rensa all feedback?')) {\n            feedbackCollector.clear();\n            clearFeedbackData(); // Rensa √§ven alla feedback-maps (feedbackMap, positiveFeedbackMap, etc.)\n            updateFeedbackBadge(0); // Uppdatera badge till 0\n            updatePreviewContent();\n            showMessage('All feedback har rensats', 'success');\n        }\n    });\n}\n\nfunction updatePreviewContent() {\n    if (!modalElement) return;\n    \n    const content = modalElement.querySelector('#feedbackPreviewContent');\n    const countEl = modalElement.querySelector('#feedbackPreviewCount');\n    \n    const count = feedbackCollector.getCount();\n    \n    if (countEl) countEl.textContent = count.toString();\n    \n    if (content) {\n        if (count === 0) {\n            content.textContent = 'Ingen feedback √§nnu...\\n\\nAnv√§nd appen och ge feedback med:\\n- üëç/üëé p√• tecken\\n- üëç/üëé p√• meningar\\n- √Ñndra tecken\\n- Rapportera fel\\n\\nAllt samlas automatiskt h√§r!';\n        } else {\n            content.textContent = feedbackCollector.format();\n        }\n    }\n}\n\nexport function openFeedbackPreviewModal() {\n    if (!modalElement) {\n        initFeedbackPreviewModal();\n    }\n    updatePreviewContent();\n    openModal(modalElement!);\n}\n\nexport function closeFeedbackPreviewModal() {\n    if (modalElement) {\n        closeModal(modalElement);\n    }\n}\n","path":null,"size_bytes":6189,"size_tokens":null},"src/styles/features/robot-report.css":{"content":"\n/* --- ROBOT TEST REPORT LAYOUT --- */\n#robotTestReportModal .report-summary {\n    margin-bottom: 1.5rem;\n    padding-bottom: 1.5rem;\n    border-bottom: 1px solid var(--border-color);\n}\n#robotTestReportModal .report-progress-container {\n    height: 1.25rem;\n    border-radius: var(--border-radius-md);\n    overflow: hidden;\n    margin-top: 0.75rem;\n    background-color: var(--bg-dark);\n}\n#robotTestReportModal .report-details {\n    flex: 1;\n    overflow-y: auto;\n    padding-right: var(--space-sm); /* space for scrollbar */\n    margin-bottom: 1rem;\n}\n#robotTestReportModal .report-details summary {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    padding: var(--space-sm) var(--space-md);\n    border-radius: var(--border-radius-md);\n    cursor: pointer;\n}\n#robotTestReportModal .log-item {\n    padding-left: 2.5rem; /* Indent log details */\n    margin: var(--space-xs) 0;\n    padding-top: var(--space-xs);\n    padding-bottom: var(--space-xs);\n    border-left: 2px solid var(--border-color);\n    margin-left: 0.8rem;\n}\n","path":null,"size_bytes":1039,"size_tokens":null},"src/styles/components/navigation.css":{"content":"\n/* --- BOTTOM NAVIGATION --- */\n#bottom-nav {\n    position: fixed;\n    bottom: 1rem; /* Lowered position as footer is removed */\n    left: 0;\n    right: 0;\n    z-index: 20;\n    display: flex;\n    justify-content: center;\n    padding: 0 1rem;\n}\n\n.bottom-nav-menu {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    gap: 0.25rem; /* Made more compact */\n    padding: 0.5rem;\n    background-color: var(--bg-light);\n    border-radius: 1.25rem;\n    border: 1px solid var(--border-color);\n    box-shadow: var(--shadow-lg);\n}\n\n#bottom-nav .nav-btn {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: 0.125rem;\n    padding: 0.5rem;\n    border-radius: 0.75rem;\n    color: var(--text-secondary);\n    background-color: transparent;\n    border: none;\n    width: 64px; /* Made more compact */\n    height: 56px; /* Made more compact */\n    transition: all var(--transition-fast);\n}\n\n#bottom-nav .nav-btn:hover:not(:disabled):not(.nav-btn-primary) {\n    background-color: var(--border-light);\n    color: var(--text-primary);\n}\n\n#bottom-nav .nav-btn:disabled {\n    opacity: 0.4;\n    cursor: not-allowed;\n}\n\n#bottom-nav .nav-btn .nav-text {\n    font-size: 0.7rem;\n    font-weight: 500;\n    display: block;\n}\n\n#bottom-nav .nav-btn-primary {\n    background-color: var(--primary-blue);\n    color: white;\n}\n\n#bottom-nav .nav-btn-primary:hover:not(:disabled) {\n    background-color: var(--primary-blue-dark);\n}\n\n.nav-btn.glow-attention { \n    color: var(--primary-blue);\n    animation: glow-pulse 1.5s infinite;\n}\n","path":null,"size_bytes":1580,"size_tokens":null},"src/modules/feedback/feedbackCollector.ts":{"content":"\nimport { appState, feedbackMap, sentenceFeedbackMap, positiveFeedbackMap, negativeFeedbackMap, questionClarifications, learnedPreferences } from '../../state';\nimport { showMessage } from '../../ui';\n\nexport interface FeedbackItem {\n    type: 'thumbUp' | 'thumbDown' | 'changeSign' | 'newSignSuggestion' | 'reportError' | 'sentenceFeedback' | 'glosaCorrection' | 'appFeedback';\n    timestamp: number;\n    data: any;\n}\n\nexport interface FeedbackCollection {\n    thumbUp: Array<{ word: string; signId: string; count: number }>;\n    thumbDown: Array<{ word: string; signId: string; reason: string }>;\n    changeSign: Array<{ word: string; fromSignId: string; toSignId: string; toWord: string }>;\n    newSignSuggestion: Array<{ word: string; videoBlob?: Blob; note?: string }>;\n    reportError: Array<{ word: string; signId: string; comment: string }>;\n    sentenceFeedback: Array<{ sentence: string; glosa?: string; rating: 'up' | 'down'; comment?: string }>;\n    glosaCorrection: Array<{ swedish: string; aiGlosa: string; userGlosa: string }>;\n    appFeedback: { rating?: number; comment?: string };\n}\n\nconst STORAGE_KEY = 'sts-feedback-collection';\n\nlet feedbackItems: FeedbackItem[] = [];\nlet feedbackCount = 0;\nlet onFeedbackChange: (() => void) | null = null;\n\nexport function initFeedbackCollector() {\n    loadFromStorage();\n    updateFeedbackCount();\n}\n\nexport function setOnFeedbackChange(callback: () => void) {\n    onFeedbackChange = callback;\n}\n\nfunction loadFromStorage() {\n    try {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n            feedbackItems = JSON.parse(stored);\n        }\n    } catch (e) {\n        console.error('Failed to load feedback from storage:', e);\n        feedbackItems = [];\n    }\n}\n\nfunction saveToStorage() {\n    try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(feedbackItems));\n    } catch (e) {\n        console.error('Failed to save feedback to storage:', e);\n    }\n}\n\nfunction updateFeedbackCount() {\n    feedbackCount = feedbackItems.length;\n    if (onFeedbackChange) {\n        onFeedbackChange();\n    }\n}\n\nexport function getFeedbackCount(): number {\n    return feedbackCount;\n}\n\nexport function addFeedback(item: Omit<FeedbackItem, 'timestamp'>) {\n    const fullItem: FeedbackItem = {\n        ...item,\n        timestamp: Date.now()\n    };\n    feedbackItems.push(fullItem);\n    saveToStorage();\n    updateFeedbackCount();\n}\n\nexport function addThumbUp(word: string, signId: string) {\n    addFeedback({\n        type: 'thumbUp',\n        data: { word, signId }\n    });\n}\n\nexport function addThumbDown(word: string, signId: string, reason: string) {\n    addFeedback({\n        type: 'thumbDown',\n        data: { word, signId, reason }\n    });\n}\n\nexport function addChangeSign(word: string, fromSignId: string, toSignId: string, toWord: string) {\n    addFeedback({\n        type: 'changeSign',\n        data: { word, fromSignId, toSignId, toWord }\n    });\n}\n\nexport function addNewSignSuggestion(word: string, videoBlob?: Blob, note?: string) {\n    addFeedback({\n        type: 'newSignSuggestion',\n        data: { word, hasVideo: !!videoBlob, note }\n    });\n}\n\nexport function addReportError(word: string, signId: string, comment: string) {\n    addFeedback({\n        type: 'reportError',\n        data: { word, signId, comment }\n    });\n}\n\nexport function addSentenceFeedback(sentence: string, glosa: string | undefined, rating: 'up' | 'down', comment?: string) {\n    addFeedback({\n        type: 'sentenceFeedback',\n        data: { sentence, glosa, rating, comment }\n    });\n}\n\nexport function addGlosaCorrection(swedish: string, aiGlosa: string, userGlosa: string) {\n    addFeedback({\n        type: 'glosaCorrection',\n        data: { swedish, aiGlosa, userGlosa }\n    });\n}\n\nexport function addAppFeedback(rating: number, comment: string) {\n    addFeedback({\n        type: 'appFeedback',\n        data: { rating, comment }\n    });\n}\n\nexport function getAllFeedback(): FeedbackItem[] {\n    return [...feedbackItems];\n}\n\nexport function clearFeedback() {\n    feedbackItems = [];\n    saveToStorage();\n    updateFeedbackCount();\n}\n\nexport function formatFeedbackForForms(): string {\n    const now = new Date();\n    const dateStr = now.toISOString().split('T')[0];\n    const timeStr = now.toTimeString().split(' ')[0];\n    \n    const thumbUps = feedbackItems.filter(f => f.type === 'thumbUp');\n    const thumbDowns = feedbackItems.filter(f => f.type === 'thumbDown');\n    const changeSigns = feedbackItems.filter(f => f.type === 'changeSign');\n    const newSuggestions = feedbackItems.filter(f => f.type === 'newSignSuggestion');\n    const reportErrors = feedbackItems.filter(f => f.type === 'reportError');\n    const sentenceFeedbacks = feedbackItems.filter(f => f.type === 'sentenceFeedback');\n    const glosaCorrections = feedbackItems.filter(f => f.type === 'glosaCorrection');\n    const appFeedbacks = feedbackItems.filter(f => f.type === 'appFeedback');\n    \n    let output = `=== STS-helper Feedback ===\\n`;\n    output += `Datum: ${dateStr} ${timeStr}\\n`;\n    output += `Totalt: ${feedbackItems.length} feedback-poster\\n\\n`;\n    \n    if (thumbUps.length > 0) {\n        output += `üëç TUMME UPP (${thumbUps.length} st):\\n`;\n        thumbUps.forEach(f => {\n            output += `- ${f.data.word} (id: ${f.data.signId})\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (thumbDowns.length > 0) {\n        output += `üëé TUMME NER (${thumbDowns.length} st):\\n`;\n        thumbDowns.forEach(f => {\n            output += `- ${f.data.word} (id: ${f.data.signId}): \"${f.data.reason}\"\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (changeSigns.length > 0) {\n        output += `üîÑ √ÑNDRADE TECKEN (${changeSigns.length} st):\\n`;\n        changeSigns.forEach(f => {\n            output += `- \"${f.data.word}\" ‚Üí bytte fr√•n (id: ${f.data.fromSignId}) till ${f.data.toWord} (id: ${f.data.toSignId})\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (newSuggestions.length > 0) {\n        output += `üÜï F√ñRSLAG P√Ö NYA TECKEN (${newSuggestions.length} st):\\n`;\n        newSuggestions.forEach(f => {\n            output += `- Ord: \"${f.data.word}\"${f.data.hasVideo ? ' [VIDEO INSPELAD]' : ''}${f.data.note ? ` - \"${f.data.note}\"` : ''}\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (reportErrors.length > 0) {\n        output += `üí¨ RAPPORTERADE FEL (${reportErrors.length} st):\\n`;\n        reportErrors.forEach(f => {\n            output += `- ${f.data.word} (id: ${f.data.signId}): \"${f.data.comment}\"\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (sentenceFeedbacks.length > 0) {\n        output += `üìù MENINGS-FEEDBACK (${sentenceFeedbacks.length} st):\\n`;\n        sentenceFeedbacks.forEach(f => {\n            const icon = f.data.rating === 'up' ? 'üëç' : 'üëé';\n            output += `- \"${f.data.sentence}\" ‚Üí ${icon}`;\n            if (f.data.glosa) output += ` (GLOSA: ${f.data.glosa})`;\n            if (f.data.comment) output += ` - \"${f.data.comment}\"`;\n            output += '\\n';\n        });\n        output += '\\n';\n    }\n    \n    if (glosaCorrections.length > 0) {\n        output += `‚úèÔ∏è GLOSA-KORRIGERINGAR (${glosaCorrections.length} st):\\n`;\n        glosaCorrections.forEach(f => {\n            output += `- \"${f.data.swedish}\"\\n`;\n            output += `  AI: ${f.data.aiGlosa}\\n`;\n            output += `  R√§ttat: ${f.data.userGlosa}\\n`;\n        });\n        output += '\\n';\n    }\n    \n    if (appFeedbacks.length > 0) {\n        const latest = appFeedbacks[appFeedbacks.length - 1];\n        output += `‚≠ê APP-FEEDBACK:\\n`;\n        if (latest.data.rating) output += `Betyg: ${latest.data.rating}/5\\n`;\n        if (latest.data.comment) output += `Kommentar: \"${latest.data.comment}\"\\n`;\n    }\n    \n    return output;\n}\n\nexport function submitToGoogleForms(formsUrl: string): boolean {\n    const feedbackText = formatFeedbackForForms();\n    \n    try {\n        const formId = extractFormId(formsUrl);\n        if (!formId) {\n            showMessage('Ogiltig Google Forms-l√§nk', 'error');\n            return false;\n        }\n        \n        const prefilledUrl = `https://docs.google.com/forms/d/e/${formId}/viewform?usp=pp_url&entry.0=${encodeURIComponent(feedbackText)}`;\n        \n        window.open(prefilledUrl, '_blank');\n        \n        return true;\n    } catch (e) {\n        console.error('Failed to submit to Google Forms:', e);\n        showMessage('Kunde inte √∂ppna Google Forms', 'error');\n        return false;\n    }\n}\n\nfunction extractFormId(url: string): string | null {\n    const match = url.match(/\\/d\\/e\\/([a-zA-Z0-9_-]+)/);\n    if (match) return match[1];\n    \n    const match2 = url.match(/\\/d\\/([a-zA-Z0-9_-]+)/);\n    if (match2) return match2[1];\n    \n    return null;\n}\n\nexport const feedbackCollector = {\n    init: initFeedbackCollector,\n    setOnChange: setOnFeedbackChange,\n    getCount: getFeedbackCount,\n    getAll: getAllFeedback,\n    clear: clearFeedback,\n    format: formatFeedbackForForms,\n    submit: submitToGoogleForms,\n    addThumbUp,\n    addThumbDown,\n    addChangeSign,\n    addNewSignSuggestion,\n    addReportError,\n    addSentenceFeedback,\n    addGlosaCorrection,\n    addAppFeedback\n};\n","path":null,"size_bytes":9170,"size_tokens":null},"src/hooks/useDataEnrichment.ts":{"content":"\nimport { WordMapEntry } from '../types';\nimport { fullLexiconMap } from '../state';\n\nexport async function ensureWordDataEnriched(wordData: WordMapEntry): Promise<void> {\n    // If already enriched, or not a word, or no signs, we consider it \"done\" for display purposes.\n    // BUT, if we have signs and fullLexiconMap is EMPTY, we should NOT mark it as enriched.\n    // This allows the modal to retry enrichment later when the map is populated.\n    \n    if (wordData.isEnriched) return;\n    \n    if (!wordData.isWord || !wordData.signs || wordData.signs.length === 0) {\n        wordData.isEnriched = true;\n        return;\n    }\n    \n    if (fullLexiconMap.size === 0) {\n        // Database not loaded yet. Do not mark as enriched.\n        // Return early to allow retry.\n        return;\n    }\n    \n    const baseWord = wordData.base.toLowerCase();\n    const fullLexiconEntries = fullLexiconMap.get(baseWord);\n    \n    if (fullLexiconEntries) {\n        const primarySignId = String(wordData.signs[0].id);\n        \n        // F√∂rs√∂k hitta exakt matchning, eller matchning d√§r vi ignorerar ledande nollor\n        const fullEntry = fullLexiconEntries.find(entry => {\n             const entryId = String(entry.id);\n             \n             // 1. Exakt str√§ngmatchning\n             if (entryId === primarySignId) {\n                 return true;\n             }\n             \n             // 2. Numerisk matchning\n             const numEntry = Number(entryId);\n             const numPrimary = Number(primarySignId);\n             \n             if (!isNaN(numEntry) && !isNaN(numPrimary)) {\n                 return numEntry === numPrimary;\n             }\n             \n             return false;\n        });\n        \n        if (fullEntry) {\n            wordData.examples = fullEntry.examples;\n            wordData.related = fullEntry.related;\n            wordData.gloss = fullEntry.gloss;\n        }\n    }\n    wordData.isEnriched = true;\n}\n\nexport async function enrichWordMapDataInBackground(wordMap: WordMapEntry[]) {\n    // This runs without being awaited to not block the UI\n    if (fullLexiconMap.size === 0) {\n        // Can't enrich yet.\n        return;\n    }\n\n    for (const wordData of wordMap) {\n        if(wordData.isWord && wordData.signs && wordData.signs.length > 0) {\n           await ensureWordDataEnriched(wordData);\n        }\n    }\n}\n","path":null,"size_bytes":2350,"size_tokens":null},"src/modules/features/recorder.ts":{"content":"import { appState } from '../../state';\nimport { showMessage } from '../../ui';\nimport { openModal, closeModal } from '../../components/modals/ModalSystem';\n\nlet mediaStream: MediaStream | null = null;\nlet mediaRecorder: MediaRecorder | null = null;\nlet recordedChunks: Blob[] = [];\nlet timerInterval: number | null = null;\n\nfunction stopStream() {\n    if (mediaStream) {\n        mediaStream.getTracks().forEach(track => track.stop());\n        mediaStream = null;\n    }\n    if (timerInterval) {\n        clearInterval(timerInterval);\n        timerInterval = null;\n    }\n}\n\nfunction resetSuggestionModalUI() {\n    const modal = document.getElementById('suggestionModal');\n    if (!modal) return;\n    \n    const videoPreview = document.getElementById('suggestionVideoPreview') as HTMLVideoElement;\n    const statusText = document.getElementById('suggestionStatusText') as HTMLElement;\n    const timerDisplay = document.getElementById('timerDisplay') as HTMLElement;\n    \n    const uploadBtn = document.getElementById('uploadVideoButton') as HTMLButtonElement;\n    const recordBtn = document.getElementById('recordVideoButton') as HTMLButtonElement;\n    const stopBtn = document.getElementById('stopRecordingButton') as HTMLButtonElement;\n    const useBtn = document.getElementById('useVideoButton') as HTMLButtonElement;\n    const retakeBtn = document.getElementById('retakeVideoButton') as HTMLButtonElement;\n\n    stopStream();\n    \n    videoPreview.srcObject = null;\n    videoPreview.src = '';\n    videoPreview.classList.add('hidden');\n    statusText.classList.remove('hidden');\n    timerDisplay.classList.add('hidden');\n    statusText.textContent = 'V√§lj inspelning eller ladda upp.';\n    \n    uploadBtn.classList.remove('hidden');\n    recordBtn.classList.remove('hidden');\n    stopBtn.classList.add('hidden');\n    useBtn.classList.add('hidden');\n    retakeBtn.classList.add('hidden');\n    \n    appState.modalContexts.sendSuggestion = null;\n}\n\nfunction startRecording() {\n    const videoPreview = document.getElementById('suggestionVideoPreview') as HTMLVideoElement;\n    const statusText = document.getElementById('suggestionStatusText') as HTMLElement;\n    const timerDisplay = document.getElementById('timerDisplay') as HTMLElement;\n    const uploadBtn = document.getElementById('uploadVideoButton') as HTMLButtonElement;\n    const recordBtn = document.getElementById('recordVideoButton') as HTMLButtonElement;\n    const stopBtn = document.getElementById('stopRecordingButton') as HTMLButtonElement;\n\n    navigator.mediaDevices.getUserMedia({ video: true, audio: false })\n        .then(stream => {\n            mediaStream = stream;\n            videoPreview.srcObject = stream;\n            videoPreview.classList.remove('hidden');\n            videoPreview.play();\n            \n            statusText.classList.add('hidden');\n            uploadBtn.classList.add('hidden');\n            recordBtn.classList.add('hidden');\n            stopBtn.classList.remove('hidden');\n            timerDisplay.classList.remove('hidden');\n            \n            recordedChunks = [];\n            mediaRecorder = new MediaRecorder(stream);\n            \n            mediaRecorder.ondataavailable = (e) => {\n                if (e.data.size > 0) {\n                    recordedChunks.push(e.data);\n                }\n            };\n            \n            mediaRecorder.onstop = () => {\n                const blob = new Blob(recordedChunks, { type: 'video/webm' });\n                handleVideoReady(blob);\n            };\n            \n            mediaRecorder.start();\n            \n            let seconds = 0;\n            timerDisplay.textContent = \"00:00\";\n            timerInterval = window.setInterval(() => {\n                seconds++;\n                const m = Math.floor(seconds / 60).toString().padStart(2, '0');\n                const s = (seconds % 60).toString().padStart(2, '0');\n                timerDisplay.textContent = `${m}:${s}`;\n            }, 1000);\n        })\n        .catch(err => {\n            console.error(\"Kunde inte starta kamera:\", err);\n            showMessage(\"Kunde inte komma √•t kameran.\", \"error\");\n        });\n}\n\nfunction stopRecording() {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n        mediaRecorder.stop();\n        stopStream();\n    }\n}\n\nfunction handleVideoReady(blob: Blob) {\n    const videoPreview = document.getElementById('suggestionVideoPreview') as HTMLVideoElement;\n    const statusText = document.getElementById('suggestionStatusText') as HTMLElement;\n    const timerDisplay = document.getElementById('timerDisplay') as HTMLElement;\n    const stopBtn = document.getElementById('stopRecordingButton') as HTMLButtonElement;\n    const useBtn = document.getElementById('useVideoButton') as HTMLButtonElement;\n    const retakeBtn = document.getElementById('retakeVideoButton') as HTMLButtonElement;\n    \n    const url = URL.createObjectURL(blob);\n    videoPreview.srcObject = null;\n    videoPreview.src = url;\n    videoPreview.controls = true;\n    videoPreview.classList.remove('hidden');\n    \n    statusText.classList.add('hidden');\n    timerDisplay.classList.add('hidden');\n    stopBtn.classList.add('hidden');\n    \n    useBtn.classList.remove('hidden');\n    retakeBtn.classList.remove('hidden');\n    \n    if (appState.modalContexts.suggestion) {\n        appState.modalContexts.sendSuggestion = {\n            blob: blob,\n            context: appState.modalContexts.suggestion\n        };\n    }\n}\n\nfunction handleFileUpload(file: File) {\n    handleVideoReady(file);\n}\n\nexport function openSendSuggestionModal() {\n    const suggestionContext = appState.modalContexts.sendSuggestion;\n    if (!suggestionContext) return;\n    \n    const suggestionModal = document.getElementById('suggestionModal') as HTMLElement;\n    closeModal(suggestionModal);\n    \n    const sendModal = document.getElementById('sendSuggestionModal') as HTMLElement;\n    const preview = document.getElementById('sendSuggestionVideoPreview') as HTMLVideoElement;\n    const downloadBtn = document.getElementById('downloadSuggestionBtn') as HTMLAnchorElement;\n    const textArea = document.getElementById('sendSuggestionText') as HTMLTextAreaElement;\n    const copyBtn = document.getElementById('copySuggestionTextBtn') as HTMLButtonElement;\n    \n    if (!sendModal || !preview || !downloadBtn || !textArea) return;\n    \n    const blobUrl = URL.createObjectURL(suggestionContext.blob);\n    preview.src = blobUrl;\n    \n    downloadBtn.href = blobUrl;\n    downloadBtn.download = `teckenforslag_${suggestionContext.context.lookupKey}.webm`;\n    \n    const infoText = `NYTT TECKEN F√ñRSLAG\\n\\nOrd: ${suggestionContext.context.lookupKey.toUpperCase()}\\nKontext: \"${suggestionContext.context.fullOriginalPhrase}\"\\n\\n(Bifoga den nedladdade videofilen i mailet)`;\n    textArea.value = infoText;\n    \n    copyBtn.onclick = () => {\n        textArea.select();\n        document.execCommand('copy');\n        showMessage(\"Text kopierad till urklipp!\", \"success\");\n    };\n    \n    openModal(sendModal);\n}\n\nexport function initializeSuggestionModalEventListeners() {\n    const uploadBtn = document.getElementById('uploadVideoButton');\n    const fileInput = document.getElementById('videoUploadInput') as HTMLInputElement;\n    const recordBtn = document.getElementById('recordVideoButton');\n    const stopBtn = document.getElementById('stopRecordingButton');\n    const useBtn = document.getElementById('useVideoButton');\n    const retakeBtn = document.getElementById('retakeVideoButton');\n    \n    uploadBtn?.addEventListener('click', () => fileInput.click());\n    fileInput?.addEventListener('change', (e) => {\n        const file = (e.target as HTMLInputElement).files?.[0];\n        if (file) handleFileUpload(file);\n    });\n    \n    recordBtn?.addEventListener('click', startRecording);\n    stopBtn?.addEventListener('click', stopRecording);\n    \n    useBtn?.addEventListener('click', openSendSuggestionModal);\n    retakeBtn?.addEventListener('click', resetSuggestionModalUI);\n    \n    // Reset UI when modal closes\n    const suggestionModal = document.getElementById('suggestionModal');\n    if(suggestionModal) {\n         const observer = new MutationObserver((mutations) => {\n            mutations.forEach((mutation) => {\n                if (mutation.attributeName === 'class' && !suggestionModal.classList.contains('show')) {\n                    stopStream();\n                    resetSuggestionModalUI();\n                }\n            });\n        });\n        observer.observe(suggestionModal, { attributes: true });\n    }\n}\n\nexport function openSuggestionModal(context: NonNullable<typeof appState.modalContexts.improveSign>) {\n    const modal = document.getElementById('suggestionModal') as HTMLElement;\n    const title = document.getElementById('suggestionModalTitle') as HTMLElement;\n    if (!modal || !title) return;\n\n    appState.modalContexts.suggestion = {\n        phraseTokens: context.phraseTokens,\n        lookupKey: context.lookupKey,\n        fullOriginalPhrase: context.fullOriginalPhrase\n    };\n    title.textContent = `F√∂resl√• tecken f√∂r \"${context.fullOriginalPhrase}\"`;\n    openModal(modal, context.cardContainer);\n}","path":null,"size_bytes":9131,"size_tokens":null},"src/modules/sts-glossing/aiLearningSystem.ts":{"content":"/**\n * AI LEARNING SYSTEM - Appen l√§r sig fr√•n AI-resultat f√∂r att f√∂rb√§ttra offline-motorn\n * Varje AI-translation lagras s√• offline-motorn kan √•teranv√§nda det n√§sta g√•ng\n */\n\ninterface LearnedTranslation {\n  input: string;\n  output: string;\n  timestamp: number;\n  confidence: number; // 0-1, h√∂gt v√§rde = s√§ker\n  model: string; // 'puter-gpt-5.1', 'puter-claude', etc\n}\n\nclass AILearningSystem {\n  private learningCache: Map<string, LearnedTranslation> = new Map();\n  private STORAGE_KEY = 'sts_ai_learning_db';\n  private MAX_LEARNINGS = 1000; // Begr√§ns lagring\n\n  constructor() {\n    this.loadFromStorage();\n  }\n\n  /**\n   * Spara ett AI-resultat f√∂r framtida offline-anv√§ndning\n   */\n  public recordLearning(input: string, output: string, model: string = 'puter-gpt-5.1', confidence: number = 0.95) {\n    const key = this.normalizeKey(input);\n    \n    if (this.learningCache.size >= this.MAX_LEARNINGS) {\n      // Ta bort √§ldsta om vi n√•r gr√§nsen\n      const oldestKey = Array.from(this.learningCache.entries())\n        .sort((a, b) => a[1].timestamp - b[1].timestamp)[0][0];\n      this.learningCache.delete(oldestKey);\n    }\n\n    this.learningCache.set(key, {\n      input,\n      output,\n      model,\n      confidence,\n      timestamp: Date.now()\n    });\n\n    this.saveToStorage();\n    console.log(`üìö AI Learning recorded: \"${input.substring(0, 30)}...\" ‚Üí confidence: ${(confidence * 100).toFixed(0)}%`);\n  }\n\n  /**\n   * H√§mta tidigare AI-resultat f√∂r samma input\n   */\n  public getLearnedTranslation(input: string): LearnedTranslation | null {\n    const key = this.normalizeKey(input);\n    const learned = this.learningCache.get(key);\n    \n    if (learned) {\n      console.log(`‚úÖ AI Learning HIT: Found cached translation for \"${input.substring(0, 30)}...\"`);\n      return learned;\n    }\n\n    return null;\n  }\n\n  /**\n   * Kontrollera om vi har n√•got liknande sparad tidigare (fuzzy matching)\n   */\n  public findSimilarLearning(input: string, similarityThreshold: number = 0.7): LearnedTranslation | null {\n    const normalizedInput = this.normalizeKey(input);\n    let bestMatch: LearnedTranslation | null = null;\n    let bestScore = similarityThreshold;\n\n    for (const [, learning] of this.learningCache) {\n      const score = this.calculateSimilarity(normalizedInput, this.normalizeKey(learning.input));\n      if (score > bestScore) {\n        bestScore = score;\n        bestMatch = learning;\n      }\n    }\n\n    if (bestMatch) {\n      console.log(`üîç AI Learning FUZZY MATCH: Similarity ${(bestScore * 100).toFixed(0)}%`);\n      return bestMatch;\n    }\n\n    return null;\n  }\n\n  /**\n   * F√• statistik om vad appen har l√§rt sig\n   */\n  public getStats() {\n    return {\n      totalLearnings: this.learningCache.size,\n      models: Array.from(new Set(Array.from(this.learningCache.values()).map(l => l.model))),\n      avgConfidence: Array.from(this.learningCache.values()).reduce((sum, l) => sum + l.confidence, 0) / this.learningCache.size || 0\n    };\n  }\n\n  /**\n   * Rensa allt (om anv√§ndaren vill starta om)\n   */\n  public clear() {\n    this.learningCache.clear();\n    localStorage.removeItem(this.STORAGE_KEY);\n    console.log('üóëÔ∏è AI Learning system cleared');\n  }\n\n  /**\n   * Exportera all AI Learning data som JSON\n   * Du kan ladda ner detta och mata in senare\n   */\n  public exportData(): string {\n    const data = {\n      version: '1.0',\n      exportDate: new Date().toISOString(),\n      learnings: Array.from(this.learningCache.entries()).map(([key, value]) => ({\n        key,\n        ...value\n      }))\n    };\n    console.log(`üì• Exported ${data.learnings.length} AI learnings`);\n    return JSON.stringify(data, null, 2);\n  }\n\n  /**\n   * Importera AI Learning data fr√•n JSON\n   * Anv√§nd detta f√∂r att mata in tidigare sparad data\n   */\n  public importData(jsonString: string): boolean {\n    try {\n      const data = JSON.parse(jsonString);\n      if (!data.learnings || !Array.isArray(data.learnings)) {\n        throw new Error('Invalid data format');\n      }\n\n      let imported = 0;\n      for (const item of data.learnings) {\n        const { key, input, output, model, confidence, timestamp } = item;\n        if (key && input && output) {\n          this.learningCache.set(key, { input, output, model, confidence, timestamp });\n          imported++;\n        }\n      }\n\n      this.saveToStorage();\n      console.log(`üì§ Imported ${imported} AI learnings successfully`);\n      return true;\n    } catch (e) {\n      console.error('‚ùå Failed to import AI learning data:', e);\n      return false;\n    }\n  }\n\n  /**\n   * Ladda ner data som fil\n   */\n  public downloadAsFile(filename: string = 'ai-learning-backup.json') {\n    const jsonData = this.exportData();\n    const blob = new Blob([jsonData], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n    console.log(`üíæ Downloaded: ${filename}`);\n  }\n\n  // --- PRIVATA HJ√ÑLPFUNKTIONER ---\n\n  private normalizeKey(text: string): string {\n    return text.toLowerCase().trim().replace(/[.,!?;:]/g, '');\n  }\n\n  private calculateSimilarity(str1: string, str2: string): number {\n    // Enkel Levenshtein-liknande likhet (0-1)\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n\n    if (longer.length === 0) return 1.0;\n\n    const editDistance = this.levenshteinDistance(longer, shorter);\n    return (longer.length - editDistance) / longer.length;\n  }\n\n  private levenshteinDistance(s1: string, s2: string): number {\n    const costs: number[] = [];\n    for (let i = 0; i <= s1.length; i++) {\n      let lastValue = i;\n      for (let j = 0; j <= s2.length; j++) {\n        if (i === 0) {\n          costs[j] = j;\n        } else if (j > 0) {\n          let newValue = costs[j - 1];\n          if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {\n            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;\n          }\n          costs[j - 1] = lastValue;\n          lastValue = newValue;\n        }\n      }\n      if (i > 0) costs[s2.length] = lastValue;\n    }\n    return costs[s2.length];\n  }\n\n  private saveToStorage() {\n    try {\n      const data = Array.from(this.learningCache.entries());\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));\n      \n      // Trigga cloud-synk (debounced)\n      this.triggerCloudSync();\n    } catch (e) {\n      console.warn('Could not save AI learning to localStorage:', e);\n    }\n  }\n\n  private async triggerCloudSync() {\n    try {\n      const { puterCloudSync } = await import('../cloud/puterCloudSync');\n      puterCloudSync.scheduleSyncToCloud();\n    } catch (e) {\n      // Cloud sync not available, ignore\n    }\n  }\n\n  private loadFromStorage() {\n    try {\n      const data = localStorage.getItem(this.STORAGE_KEY);\n      if (data) {\n        const entries = JSON.parse(data);\n        this.learningCache = new Map(entries);\n        console.log(`üìö Loaded ${this.learningCache.size} AI learnings from storage`);\n      }\n    } catch (e) {\n      console.warn('Could not load AI learning from localStorage:', e);\n    }\n  }\n}\n\n// Singleton instance\nexport const aiLearningSystem = new AILearningSystem();\n","path":null,"size_bytes":7350,"size_tokens":null},"src/styles/components/modals.css":{"content":"\n/* --- MODALS & OVERLAYS --- REFINED */\n.modal {\n    position: fixed; inset: 0; z-index: 50; \n    display: flex;\n    align-items: center; \n    justify-content: center;\n    padding: var(--space-md);\n    visibility: hidden;\n}\n.modal.show { visibility: visible; }\n\n.modal-content {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    max-width: 700px; \n    min-width: 300px;\n    max-height: 90vh; \n    overflow-y: auto;\n    position: relative; \n    padding: var(--space-lg) var(--space-xl); /* Generous padding */\n    border-radius: var(--border-radius-lg);\n}\n\n.modal-close-btn {\n    position: absolute;\n    top: var(--space-md);\n    right: var(--space-md);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    width: 2.75rem; \n    height: 2.75rem;\n    font-size: 1.5rem;\n    z-index: 10;\n    border-radius: 50%;\n}\n\n#lexiconSuggestions, .suggestions-list {\n    position: absolute;\n    top: 100%;\n    left: 0;\n    right: 0;\n    z-index: 20;\n    max-height: 200px;\n    overflow-y: auto;\n    margin-top: -1px; /* Overlap border */\n}\n\n#tooltip {\n    position: fixed; \n    z-index: 10000; \n    visibility: hidden; \n    pointer-events: none;\n}\n","path":null,"size_bytes":1176,"size_tokens":null},"src/modules/dom/elements.ts":{"content":"\n// DOM Elements exported for other modules\nexport const originalTextDisplay = document.getElementById('originalTextDisplay') as HTMLElement;\nexport const voiceInputBtn = document.getElementById('voiceInputBtn') as HTMLButtonElement;\nexport const imageInputBtn = document.getElementById('imageInputBtn') as HTMLButtonElement;\nexport const imageInputFile = document.getElementById('imageInputFile') as HTMLInputElement;\n","path":null,"size_bytes":419,"size_tokens":null},"src/modules/core/init.ts":{"content":"\nimport { appState } from '../../state';\nimport { initializeLexicon } from '../../hooks/useLexicon';\nimport { initializeAI } from '../../hooks/useAI';\nimport { initializeSpeechRecognition } from '../../hooks/useSpeechRecognition';\nimport { initializeModals } from '../../components/modals';\nimport { updateButtonProgress } from '../../ui';\nimport { initLocalSearch } from '../search/localSearchWithFallback';\nimport { resetApp } from './reset';\n\n// Import UI Modules\nimport { updateHeaderLexiconProgress, updateDualLexiconProgressUI } from '../ui/progress';\nimport { initTheme } from '../ui/theme';\nimport { initializePlaceholder } from '../ui/textDisplay';\nimport { injectModals } from '../ui/modalTemplates';\n\n// Import Handlers\nimport { setupInputHandlers } from '../handlers/inputHandlers';\nimport { setupNavHandlers } from '../handlers/navHandlers';\nimport { setupSystemHandlers } from '../handlers/systemHandlers';\n\n// Import Genuina Tecken\nimport { setupGenuinaTecken } from '../genuina/genuinaHandlers';\n\n// Import Services\nimport { initLexiconStatusHeader } from '../../services/lexiconStatusHeader';\nimport { quotaTracker } from '../../services/quotaTracker';\n\n// Import Feedback System\nimport { feedbackCollector } from '../feedback/feedbackCollector';\nimport { initFeedbackPreviewModal } from '../feedback/feedbackPreviewModal';\nimport { updateFeedbackBadge } from '../../services/ui/feedbackNotificationService';\n\n// Import Dev Mode Service\nimport { initDevMode } from '../../services/system/devModeService';\n// ARCHIVED: initQuotaDisplay, initDotPercentage - moved to _archived/\n\nexport function initCore() {\n    // 0. Initialize Dev Mode (check URL for ?dev=hemlig)\n    initDevMode();\n    \n    // 0b. Initialize Quota Display\n    quotaTracker.updateUI();\n    \n    // 1. Inject Modals\n    injectModals();\n\n    // 1. UI & Theme Init\n    initTheme();\n    \n    // 2. Check AI Mode\n    const aiModeToggle = document.getElementById('aiModeToggle') as HTMLInputElement;\n    if (aiModeToggle) {\n        aiModeToggle.checked = appState.aiEnabled;\n        aiModeToggle.addEventListener('change', (e) => {\n            appState.aiEnabled = (e.target as HTMLInputElement).checked;\n            localStorage.setItem('aiEnabled', String(appState.aiEnabled));\n            const status = appState.aiEnabled ? 'aktiverat' : 'deaktiverat';\n            import('../../ui').then(m => m.showMessage(`AI-funktioner ${status}. Bara lokal s√∂kning anv√§nds nu.`, 'success'));\n        });\n    }\n    \n    // Initialize AI Status Indicator\n    const aiStatusIndicator = document.getElementById('aiStatusIndicator') as HTMLElement;\n    if (aiStatusIndicator) {\n        aiStatusIndicator.classList.add('ai-loading');\n        aiStatusIndicator.title = 'AI status: Loading...';\n    }\n\n    // 3. Check Dev Mode (handled in settings menu only)\n\n    // 3A. HF-API QUOTA BUTTON\n    const quotaBtn = document.getElementById('hf-api-quota') as HTMLButtonElement;\n    const quotaModal = document.getElementById('quota-modal') as HTMLElement;\n    const quotaModalClose = document.getElementById('quota-modal-close') as HTMLButtonElement;\n    const quotaModalBackdrop = document.getElementById('quota-modal-backdrop') as HTMLElement;\n\n    if (quotaBtn && quotaModal) {\n        quotaBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            quotaModal.classList.remove('hidden');\n        });\n    }\n\n    if (quotaModalClose && quotaModal) {\n        quotaModalClose.addEventListener('click', () => {\n            quotaModal.classList.add('hidden');\n        });\n    }\n\n    if (quotaModalBackdrop && quotaModal) {\n        quotaModalBackdrop.addEventListener('click', () => {\n            quotaModal.classList.add('hidden');\n        });\n    }\n\n    // 3B. GLOSA Beta Feature Toggle\n    const settingsBtn = document.getElementById('settingsBtn') as HTMLButtonElement;\n    const betaMenu = document.getElementById('betaFeaturesMenu') as HTMLElement;\n    const glosaToggle = document.getElementById('glosaToggle') as HTMLInputElement;\n    const glosaBtn = document.getElementById('glosaBtn') as HTMLButtonElement;\n\n    if (settingsBtn && betaMenu) {\n        settingsBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            betaMenu.classList.toggle('hidden');\n        });\n        \n        document.addEventListener('click', (e) => {\n            if (!settingsBtn.contains(e.target as Node) && !betaMenu.contains(e.target as Node)) {\n                betaMenu.classList.add('hidden');\n            }\n        });\n    }\n\n    if (glosaToggle && glosaBtn) {\n        // Set initial state from localStorage\n        const glosaEnabledSaved = localStorage.getItem('glosaEnabled') === 'true';\n        glosaToggle.checked = glosaEnabledSaved;\n        appState.glosaEnabled = glosaEnabledSaved;\n        glosaBtn.classList.toggle('hidden', !glosaEnabledSaved);\n        \n        // Listen for changes\n        glosaToggle.addEventListener('change', () => {\n            appState.glosaEnabled = glosaToggle.checked;\n            localStorage.setItem('glosaEnabled', String(glosaToggle.checked));\n            glosaBtn.classList.toggle('hidden', !glosaToggle.checked);\n            \n            const status = glosaToggle.checked ? 'aktiverad' : 'deaktiverad';\n            import('../../ui').then(m => m.showMessage(`üöÄ GLOSA Beta ${status}`, 'success'));\n        });\n    }\n\n    // 3B. Dev Mode Toggle - now handled by devModeService\n    const devModeToggle = document.getElementById('devModeToggle') as HTMLInputElement;\n    if (devModeToggle) {\n        import('../../services/system/devModeService').then(({ isDevMode, toggleDevMode }) => {\n            devModeToggle.checked = isDevMode();\n            \n            devModeToggle.addEventListener('change', () => {\n                toggleDevMode(devModeToggle.checked);\n                const status = devModeToggle.checked ? 'aktiverat' : 'inaktiverat';\n                import('../../ui').then(m => m.showMessage(`Dev Mode ${status}`, 'success'));\n            });\n        });\n    }\n\n    // 4. Observers\n    appState.alphabetObserver = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            const video = entry.target.querySelector('video') as HTMLVideoElement;\n            if (!video) return;\n            \n            // Lazy load video src if not already loaded\n            if (entry.isIntersecting && !video.src && video.dataset.src) {\n                video.src = video.dataset.src;\n                video.load();\n            }\n        });\n    }, { rootMargin: '50px', threshold: 0.1 });\n\n    // 5. Core Services Init\n    updateHeaderLexiconProgress();\n    initLocalSearch();\n    initLexiconStatusHeader();\n    // ARCHIVED: initQuotaDisplay, initDotPercentage\n    initializeAI(resetApp).catch(e => console.error(\"AI init failed:\", e));\n    \n    initializeLexicon(\n        () => { },\n        (progress) => { \n            appState.localLexiconProgress = progress;\n            updateHeaderLexiconProgress();\n            updateDualLexiconProgressUI();\n        },\n        (progress) => {\n            appState.onlineLexiconProgress = progress;\n            updateHeaderLexiconProgress();\n            updateDualLexiconProgressUI();\n        }\n    );\n    \n    initializeSpeechRecognition();\n    initializeModals();\n\n    // 6. Wiring Event Handlers\n    setupInputHandlers();\n    setupNavHandlers();\n    setupSystemHandlers();\n    \n    // 6a. Setup Genuina Tecken\n    setupGenuinaTecken().catch(e => console.error(\"Genuina tecken init failed:\", e));\n\n    // 6b. ARCHIVED: GLOSATranscription component moved to _archived/\n    // Sign Language Transcription Lexicon (GLOSA) is still integrated in main app through other means\n\n    // 7. Final UI Prep\n    initializePlaceholder();\n    import('../../ui').then(m => m.initializeTooltips());\n    updateButtonProgress('idle');\n    \n    // 8. Initialize Feedback System\n    feedbackCollector.init();\n    initFeedbackPreviewModal();\n    feedbackCollector.setOnChange(() => {\n        updateFeedbackBadge(feedbackCollector.getCount());\n    });\n    updateFeedbackBadge(feedbackCollector.getCount());\n\n    // F√∂rb√§ttrad inklistring\n    const textDiv = document.getElementById('originalTextDisplay');\n    if (textDiv) {\n        textDiv.addEventListener('paste', (e) => {\n            e.preventDefault();\n            const text = (e.clipboardData || (window as any).clipboardData).getData('text');\n            const clean = text.replace(/\\r?\\n/g, '<br>');\n            textDiv.innerHTML = clean;\n        });\n        textDiv.addEventListener('drop', (e) => {\n            e.preventDefault();\n        });\n    }\n}\n","path":null,"size_bytes":8607,"size_tokens":null},"src/vite-env.d.ts":{"content":"/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_HUGGINGFACE_TOKEN?: string;\n  readonly VITE_GOOGLE_AI_STUDIO_KEY?: string;\n  readonly VITE_MISTRAL_API_KEY?: string;\n  readonly VITE_DEEPAI_KEY?: string;\n  readonly VITE_OLLAMA_KEY?: string;\n  readonly VITE_LAOZHANG_API_KEY?: string;\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n","path":null,"size_bytes":374,"size_tokens":null},"src/App.tsx":{"content":"import { initCore } from './modules/core/init';\nimport GlosaSearch from './components/GlosaSearch';\n\n// Main entry point for the application logic\nexport function initializeApp() {\n    initCore();\n}\n\nfunction App() {\n  return (\n    <div>\n      {/* ...eventuellt annan layout... */}\n      <GlosaSearch />\n    </div>\n  );\n}\n","path":null,"size_bytes":322,"size_tokens":null},"src/styles/features/grammar.css":{"content":"\n/* --- GRAMMAR GRID STYLES --- */\n.grammar-grid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));\n    gap: var(--space-md);\n}\n\n#grammarPlaceholder {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    min-height: 10rem;\n    width: 100%;\n    grid-column: 1 / -1; /* Span all columns */\n}\n\n/* Updated for Video Cards in Grammar Grid */\n.grammar-badge {\n    position: absolute;\n    top: var(--space-sm);\n    left: var(--space-sm);\n    z-index: 10;\n    background-color: var(--bg-light);\n    color: var(--primary-blue);\n    font-size: 0.7rem;\n    font-weight: 700;\n    padding: 2px 8px;\n    border-radius: 12px;\n    border: 1px solid var(--primary-blue);\n    box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n}\n\n.grammar-card {\n    /* No longer used, replaced by video-card logic */\n    background-color: var(--bg-dark);\n    border: 1px solid var(--border-light);\n    border-radius: var(--border-radius-md);\n    padding: var(--space-md);\n    text-align: center;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: var(--space-xs);\n    transition: all var(--transition-fast);\n}\n\n.grammar-card:hover {\n    border-color: var(--primary-blue);\n    transform: translateY(-2px);\n}\n\n.grammar-original {\n    font-size: 0.8rem;\n    color: var(--text-secondary);\n    margin: 0;\n}\n\n.grammar-gloss {\n    font-size: 1.1rem;\n    font-weight: 700;\n    color: var(--clickable-has-video-text);\n    margin: 0;\n    line-height: 1.2;\n}\n\n.grammar-pos {\n    display: inline-block;\n    font-size: 0.75rem;\n    color: var(--text-tertiary);\n    background-color: rgba(255, 255, 255, 0.1);\n    padding: 2px 8px;\n    border-radius: 12px;\n    margin-top: 4px;\n}\n","path":null,"size_bytes":1739,"size_tokens":null},"src/services/lexiconStatusHeader.ts":{"content":"export function initLexiconStatusHeader() {\n    const localBar = document.getElementById('local-progress-bar-header');\n    const onlineBar = document.getElementById('online-progress-bar-header');\n    const localPct = document.getElementById('local-pct-header');\n    const onlinePct = document.getElementById('online-pct-header');\n    \n    window.addEventListener('lexicon-progress', ((e: any) => {\n        const { local, online } = e.detail || {};\n        if (local !== undefined && localBar && localPct) {\n            localBar.style.width = local + '%';\n            localPct.textContent = local + '%';\n        }\n        if (online !== undefined && onlineBar && onlinePct) {\n            onlineBar.style.width = online + '%';\n            onlinePct.textContent = online + '%';\n        }\n    }) as EventListener);\n}\n","path":null,"size_bytes":813,"size_tokens":null},"src/__tests__/utils.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as utils from '../utils';\n\ndescribe('utils module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(utils).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r utility-funktioner h√§r\n});\n","path":null,"size_bytes":377,"size_tokens":null},"src/modules/genuina/phraseHighlighter.ts":{"content":"// Real-time phrase highlighting f√∂r genuina tecken\n\nimport { genuinaTeckenService, type PhraseMatch } from './genuinaTeckenService';\n\nexport class PhraseHighlighter {\n    private container: HTMLElement;\n    private lastText: string = '';\n    private highlightTimeout: number | null = null;\n\n    constructor(container: HTMLElement) {\n        this.container = container;\n    }\n\n    /**\n     * Applicera highlights p√• text (debounced f√∂r prestanda)\n     */\n    highlight(immediate = false) {\n        if (this.highlightTimeout) {\n            clearTimeout(this.highlightTimeout);\n        }\n\n        const delay = immediate ? 0 : 300; // 300ms debounce\n        this.highlightTimeout = window.setTimeout(() => {\n            this.applyHighlights();\n        }, delay);\n    }\n\n    /**\n     * Applicera highlights direkt\n     */\n    private applyHighlights() {\n        const text = this.container.textContent || '';\n        \n        // Ingen √§ndring = skippa\n        if (text === this.lastText) return;\n        this.lastText = text;\n\n        // Inga genuina tecken laddade √§n\n        if (!genuinaTeckenService.isLoaded()) return;\n\n        // Hitta alla matches\n        const matches = genuinaTeckenService.findMatches(text);\n        \n        if (matches.length === 0) {\n            // Ta bort alla highlights om inga matches\n            this.removeAllHighlights();\n            return;\n        }\n\n        // Spara cursor position\n        const selection = window.getSelection();\n        const cursorOffset = this.getCursorOffset();\n\n        // Applicera highlights genom att wrappa matchade fraser\n        const highlightedHTML = this.wrapMatches(text, matches);\n        this.container.innerHTML = highlightedHTML;\n\n        // √Öterst√§ll cursor position\n        if (cursorOffset !== null) {\n            this.restoreCursorOffset(cursorOffset);\n        }\n    }\n\n    /**\n     * Wrap matchade fraser med highlight markup\n     */\n    private wrapMatches(text: string, matches: PhraseMatch[]): string {\n        let result = '';\n        let lastIndex = 0;\n\n        for (const match of matches) {\n            // L√§gg till text f√∂re matchen\n            result += this.escapeHTML(text.substring(lastIndex, match.startIndex));\n            \n            // L√§gg till highlightad fras\n            const phraseText = this.escapeHTML(match.phrase);\n            const synonymsText = match.synonymer.length > 0 ? \n                match.synonymer.join(', ') : 'Genuint tecken';\n            \n            result += `<mark class=\"genuine-phrase\" data-tecken-id=\"${match.teckenId}\" data-phrase=\"${this.escapeHTML(match.phrase)}\" title=\"${this.escapeHTML(synonymsText)}\">${phraseText}</mark>`;\n            \n            lastIndex = match.endIndex;\n        }\n\n        // L√§gg till resten av texten\n        result += this.escapeHTML(text.substring(lastIndex));\n\n        return result;\n    }\n\n    /**\n     * Ta bort alla highlights\n     */\n    private removeAllHighlights() {\n        const marks = this.container.querySelectorAll('mark.genuine-phrase');\n        marks.forEach(mark => {\n            const text = document.createTextNode(mark.textContent || '');\n            mark.parentNode?.replaceChild(text, mark);\n        });\n        \n        // Normalisera text nodes\n        this.container.normalize();\n    }\n\n    /**\n     * H√§mta cursor offset i text (f√∂r att √•terst√§lla senare)\n     */\n    private getCursorOffset(): number | null {\n        const selection = window.getSelection();\n        if (!selection || selection.rangeCount === 0) return null;\n\n        const range = selection.getRangeAt(0);\n        const preCaretRange = range.cloneRange();\n        preCaretRange.selectNodeContents(this.container);\n        preCaretRange.setEnd(range.endContainer, range.endOffset);\n\n        return preCaretRange.toString().length;\n    }\n\n    /**\n     * √Öterst√§ll cursor position fr√•n offset\n     */\n    private restoreCursorOffset(offset: number) {\n        const selection = window.getSelection();\n        if (!selection) return;\n\n        const range = document.createRange();\n        let currentOffset = 0;\n        let found = false;\n\n        const walk = (node: Node): boolean => {\n            if (node.nodeType === Node.TEXT_NODE) {\n                const textLength = node.textContent?.length || 0;\n                if (currentOffset + textLength >= offset) {\n                    range.setStart(node, offset - currentOffset);\n                    range.collapse(true);\n                    found = true;\n                    return true;\n                }\n                currentOffset += textLength;\n            } else {\n                for (let i = 0; i < node.childNodes.length; i++) {\n                    if (walk(node.childNodes[i])) return true;\n                }\n            }\n            return false;\n        };\n\n        walk(this.container);\n\n        if (found) {\n            selection.removeAllRanges();\n            selection.addRange(range);\n        }\n    }\n\n    /**\n     * Escape HTML f√∂r s√§kerhet\n     */\n    private escapeHTML(text: string): string {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    /**\n     * Cleanup\n     */\n    destroy() {\n        if (this.highlightTimeout) {\n            clearTimeout(this.highlightTimeout);\n        }\n    }\n}\n","path":null,"size_bytes":5311,"size_tokens":null},"src/hooks/useLexicon.ts":{"content":"\nimport { Sign, LearningData, PositiveFeedbackEntry, NegativeFeedbackEntry, FeedbackEntry, LexiconMetadata } from '../types';\nimport { appState, localLexiconMap, idToWordMap, alphabetSignsMap, searchableLexicon, learnedPreferences, feedbackMap, sentenceFeedbackMap, positiveFeedbackMap, negativeFeedbackMap, homonymMap, latestSignsFromLexicon, localUserSigns, localVideoMap, fullLexiconMap, questionClarifications, aliasMap, inflectionMap, updateLatestFeedbackJson } from '../state';\nimport { showMessage, updateButtonProgress, isDevMode, ICON_LOADING_SVG } from '../ui';\nimport { closeModal as closeModalSystem, clearFeedbackData } from '../components/modals';\nimport { delay } from '../utils';\nimport { convertSummaryToJsonAI } from './useAI';\nimport { updateHeaderLexiconProgress } from '../modules/ui/progress';\n\n// ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è VARNING / WARNING ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è\n// R√ñR ALDRIG LEXIKON FILER: ABSOLUT ALDRIG!\n// NEVER TOUCH LEXICON FILES: ABSOLUTELY NEVER!\n// Modifiering kan skada hela appen / Modification can break the entire app\n// ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è\n\n// --- LEXICON CONFIGURATION ---\nconst MAX_LOCAL_LEXICON_PARTS = 6; // Fast search (del 1-6 offline/snabb)\nconst MAX_FULL_LEXICON_PARTS = 10;  // Full details + videos (del 1-10 offline/full)\n\n// Paths to local lexicon files for fast search (offline/snabb: del 1-6)\nconst LOCAL_SEARCH_LEXICON_PATHS = Array.from({ length: MAX_LOCAL_LEXICON_PARTS }, (_, i) => `/data/lexikon/offline/snabb/lexikon_sammanslagen_del_${i + 1}.json`);\n\n// Paths to local full lexicon files (offline/full: del 1-10)\nconst FULL_LEXICON_LOCAL_PATHS = Array.from({ length: MAX_FULL_LEXICON_PARTS }, (_, i) => `/data/lexikon/offline/full/lexikon_sammanslagen_del_${i + 1}.json`);\n\n// Paths to online lexicon files (fallback for full details + videos)\nconst FULL_LEXICON_GIST_URLS: string[] = [\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/b48b3821120fd6b56e3ee929c0f9fc24/raw/6025b0d401a1d580208849b62bb7030d2e26d211/1',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/d9703e6bc919b14b77f957858f930f15/raw/4c71bedc135998a50e9eaee4a1e9f950b4bf0cb0/2',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/bdfe8a5dad4367b3ea85fd81fce3525b/raw/28b840c1d33a59b8cf516b4962914541babe5a98/3',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/21a9b60e6dcae7b29883d943af025fe0/raw/2df6b65934494a71804954148b4f1cd2d9681fa6/4',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/af515a52e0e98d7cd49f511c78f5f039/raw/1221422e680ea194e16b0f01119584cb4a8ec982/5',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/de746b18123cd668d766998ae4c1c856/raw/771dae32aca37e148e2b16aef0904cd88430e3bc/6',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/cff170b7b45d859dbb2acf92ddcd45b7/raw/bf34e02a8723919784b1dcdb763f51b9f39631fd/7',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/51d3a6137887808633d8de03d044409f/raw/0ffe263b55029b4e3157cf82aefc317ef92b041d/8',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/99cba6e622a31061bea08408d033ac3c/raw/f6180565532e41377bca85fde5ca08ea29ce06eb/9',\n    'https://gist.githubusercontent.com/piruzshojadoost-bot/ef70c4798aef4656c02fc3fb36666dac/raw/f3ef150c6bbdfbb8250deea17d1be16c9cf85e1b/10'\n];\n\nconst ALIAS_PATH = '/data/user/aliases.json';\nconst INFLECTIONS_PATH = '/data/user/inflections.json';\nconst LEARNING_DATA_PATH = '/data/user/learning-data.json';\n\n\nconst DB_NAME = 'TeckensprakslexikonDB';\nconst DB_VERSION = 6; \nconst LEXICON_STORE_NAME = 'lexicon';\nconst USER_DATA_STORE_NAME = 'userData'; \n\nlet db: IDBDatabase | null = null;\nlet lexiconWorker: Worker | null = null;\n\nconst WORKER_SCRIPT = `\nconst DB_NAME = 'TeckensprakslexikonDB';\nconst DB_VERSION = 6;\nconst LEXICON_STORE_NAME = 'lexicon';\nconst USER_DATA_STORE_NAME = 'userData';\n\nlet db;\n\nfunction openDB() {\n    return new Promise((resolve, reject) => {\n        const request = indexedDB.open(DB_NAME, DB_VERSION);\n        request.onupgradeneeded = (event) => {\n            const dbInstance = event.target.result;\n            if (!dbInstance.objectStoreNames.contains(LEXICON_STORE_NAME)) {\n                dbInstance.createObjectStore(LEXICON_STORE_NAME, { keyPath: 'key' });\n            }\n            if (!dbInstance.objectStoreNames.contains(USER_DATA_STORE_NAME)) {\n                dbInstance.createObjectStore(USER_DATA_STORE_NAME, { keyPath: 'key' });\n            }\n        };\n        request.onsuccess = (event) => {\n            db = event.target.result;\n            resolve(db);\n        };\n        request.onerror = (event) => reject('Worker DB Error');\n    });\n}\n\nfunction mapToEntries(map) {\n    if (!map) return [];\n    // Handle Maps (which have entries() method)\n    if (typeof map.entries === 'function') {\n        return Array.from(map.entries());\n    }\n    // Handle plain objects (which might result from structured cloning or JSON parsing)\n    return Object.entries(map);\n}\n\nfunction entriesToMap(entries) {\n    return new Map(entries);\n}\n\nself.onmessage = async (event) => {\n    const { action, data } = event.data;\n    \n    try {\n        if (!db) await openDB();\n        \n        if (action === 'processInitialSearchData') {\n            const { lexiconParts, aliasData, inflectionsData } = data;\n            \n            postMessage({ status: 'progress', type: 'local', message: 'Bygger s√∂kindex...' });\n\n            const newLocalLexiconMap = new Map();\n            const newIdToWordMap = new Map();\n            const newAlphabetSignsMap = new Map();\n            const newAliasMap = new Map();\n            const newInflectionMap = new Map();\n\n            lexiconParts.forEach(part => {\n                const actualLexiconData = part.lexicon && Array.isArray(part.lexicon) ? part.lexicon : part;\n                if (actualLexiconData && Array.isArray(actualLexiconData)) {\n                    actualLexiconData.forEach(entry => {\n                        const word = entry.word || entry.o; \n                        if (!word || !entry.id || !Array.isArray(entry.id) && !entry.id) return;\n\n                        const entryIds = Array.isArray(entry.id) ? entry.id : [entry.id]; \n                        \n                        entryIds.forEach(rawId => {\n                            let id = String(rawId).trim();\n                            if (/^\\\\d+$/.test(id)) { \n                                id = id.padStart(5, '0');\n                            }\n                            \n                            const key = word.toLowerCase();\n                            if (!newLocalLexiconMap.has(key)) {\n                                newLocalLexiconMap.set(key, []);\n                            }\n\n                            const signEntry = { id, word: word }; \n                            \n                            if (!newLocalLexiconMap.get(key).some(s => s.id === id)) {\n                                newLocalLexiconMap.get(key).push(signEntry);\n                            }\n\n                            if (!newIdToWordMap.has(id)) {\n                                newIdToWordMap.set(id, word);\n                            }\n\n                            if (word.length === 1 && /^[a-zA-Z√•√§√∂√Ö√Ñ√ñ]$/.test(word)) {\n                                const letter = word.toLowerCase();\n                                if (!newAlphabetSignsMap.has(letter)) {\n                                    newAlphabetSignsMap.set(letter, []);\n                                }\n                                if (!newAlphabetSignsMap.get(letter).some(s => s.id === id)) {\n                                    newAlphabetSignsMap.get(letter).push(signEntry);\n                                }\n                            }\n                        });\n                    });\n                }\n            });\n\n            if (aliasData) {\n                for (const key in aliasData) {\n                    newAliasMap.set(key, aliasData[key]);\n                }\n            }\n\n            if (inflectionsData && inflectionsData.inflections) {\n                for (const key in inflectionsData.inflections) {\n                    newInflectionMap.set(key, inflectionsData.inflections[key]);\n                }\n            }\n\n            const transaction = db.transaction(LEXICON_STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(LEXICON_STORE_NAME);\n\n            const initialItems = [\n                { key: 'localLexiconMap', value: mapToEntries(newLocalLexiconMap) },\n                { key: 'idToWordMap', value: mapToEntries(newIdToWordMap) },\n                { key: 'alphabetSignsMap', value: mapToEntries(newAlphabetSignsMap) },\n                { key: 'aliasMap', value: mapToEntries(newAliasMap) },\n                { key: 'inflectionMap', value: mapToEntries(newInflectionMap) }\n            ];\n\n            await Promise.all(initialItems.map(item => new Promise( (res, rej) => {\n                const req = store.put(item);\n                req.onsuccess = res;\n                req.onerror = rej;\n            })));\n\n            postMessage({ status: 'initialSearchDataDone', type: 'local', data: {\n                localLexiconMap: mapToEntries(newLocalLexiconMap),\n                idToWordMap: mapToEntries(newIdToWordMap),\n                alphabetSignsMap: mapToEntries(newAlphabetSignsMap),\n                aliasMap: mapToEntries(newAliasMap),\n                inflectionMap: mapToEntries(newInflectionMap),\n            }});\n        } else if (action === 'processFullLexiconData') {\n            const { fullLexiconParts, totalParts } = data;\n            \n            postMessage({ status: 'progress', type: 'online', message: 'Bearbetar detaljer (' + totalParts + ' delar)...' });\n\n            const newFullLexiconMap = new Map();\n            \n            fullLexiconParts.forEach(part => {\n                const actualLexiconData = part.lexicon && Array.isArray(part.lexicon) ? part.lexicon : part;\n                if (actualLexiconData && Array.isArray(actualLexiconData)) {\n                    actualLexiconData.forEach(entry => {\n                        const word = entry.o; \n                        if (!word || !entry.v || !Array.isArray(entry.v)) return;\n\n                        const key = word.toLowerCase();\n\n                        if (!newFullLexiconMap.has(key)) {\n                            newFullLexiconMap.set(key, []);\n                        }\n\n                        entry.v.forEach(variant => {\n                            const rawId = variant.i; \n                            if (!rawId) return;\n\n                            let id = String(rawId).trim();\n                            if (/^\\\\d+$/.test(id)) { \n                                id = id.padStart(5, '0');\n                            }\n                            \n                            if (!newFullLexiconMap.get(key).some(e => e.id === id)) {\n                                const rawGloss = entry.g || \"\";\n                                const rawExamples = variant.e || [];\n                                const rawRelated = variant.r || [];\n                                \n                                const normalizedEntry = {\n                                    id: id,\n                                    word: word,\n                                    gloss: rawGloss,\n                                    examples: rawExamples.map(ex => ({\n                                        sentence: ex.m, \n                                        phraseNumber: ex.f, \n                                        id: id, \n                                        word: word\n                                    })),\n                                    related: rawRelated.map(rel => ({\n                                        sentence: rel.m,\n                                        relatedId: rel.ri,\n                                        phraseNumber: rel.f,\n                                        originalId: id,\n                                        originalWord: word,\n                                        relatedWord: rel.rw || ''\n                                    }))\n                                };\n                                newFullLexiconMap.get(key).push(normalizedEntry);\n                            }\n                        });\n                    });\n                }\n            });\n            \n            const transaction = db.transaction(LEXICON_STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(LEXICON_STORE_NAME);\n\n            await new Promise( (res, rej) => {\n                const req = store.put({ key: 'fullLexiconMap', value: mapToEntries(newFullLexiconMap) });\n                req.onsuccess = res;\n                req.onerror = rej;\n            });\n            postMessage({ status: 'fullLexiconDataDone', type: 'online', data: {\n                fullLexiconMap: mapToEntries(newFullLexiconMap)\n            }});\n\n        } else if (action === 'saveUserData') {\n            const transaction = db.transaction(USER_DATA_STORE_NAME, 'readwrite');\n            const store = transaction.objectStore(USER_DATA_STORE_NAME);\n            const userState = data.userState;\n\n            const itemsToSave = [\n                { key: 'learnedPreferences', value: mapToEntries(userState.learnedPreferences) },\n                { key: 'localUserSigns', value: mapToEntries(userState.localUserSigns) },\n                { key: 'homonymMap', value: mapToEntries(userState.homonymMap) },\n                { key: 'feedbackMap', value: mapToEntries(userState.feedbackMap) },\n                { key: 'sentenceFeedbackMap', value: mapToEntries(userState.sentenceFeedbackMap) },\n                { key: 'positiveFeedbackMap', value: mapToEntries(userState.positiveFeedbackMap).map(([key, innerMap]) => [key, mapToEntries(innerMap)]) },\n                { key: 'negativeFeedbackMap', value: mapToEntries(userState.negativeFeedbackMap).map(([key, innerMap]) => [key, mapToEntries(innerMap)]) },\n                { key: 'questionClarifications', value: mapToEntries(userState.questionClarifications) },\n                { key: 'appStateOnlineLearningData', value: userState.appStateOnlineLearningData }\n            ];\n            await Promise.all(itemsToSave.map(item => new Promise( (res, rej) => {\n                const req = store.put(item);\n                req.onsuccess = res;\n                req.onerror = rej;\n            })));\n            postMessage({ status: 'userDataSaved' });\n\n        } else if (action === 'loadUserData') {\n            const transaction = db.transaction(USER_DATA_STORE_NAME, 'readonly');\n            const store = transaction.objectStore(USER_DATA_STORE_NAME);\n            const loadedData = {};\n\n            const keys = [\n                'learnedPreferences', 'localUserSigns', 'homonymMap', 'feedbackMap', \n                'sentenceFeedbackMap', 'positiveFeedbackMap', 'negativeFeedbackMap', 'questionClarifications', 'appStateOnlineLearningData'\n            ];\n            \n            await Promise.all(keys.map(key => new Promise( (res, rej) => {\n                const req = store.get(key);\n                req.onsuccess = () => {\n                    if (req.result) {\n                         // Return raw value (Array of entries for Maps, Object for appStateOnlineLearningData)\n                        loadedData[key] = req.result.value;\n                    } else {\n                        loadedData[key] = null;\n                    }\n                    res();\n                };\n                req.onerror = rej;\n            })));\n            postMessage({ status: 'userDataLoaded', data: loadedData });\n        }\n\n    } catch (error) {\n        console.error('Worker Error:', error);\n        postMessage({ status: 'error', error: error.message });\n    }\n};\n`;\n\nif (typeof Worker !== 'undefined') {\n    const workerBlob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n    lexiconWorker = new Worker(URL.createObjectURL(workerBlob));\n} else {\n    console.warn(\"Web Workers are not supported in this environment.\");\n}\n\nlet isFullLexiconLoading = false;\nlet fullLexiconLoadPromise: Promise<boolean> | null = null;\n\nfunction entriesToMap<K, V>(entries: [K, V][] | undefined): Map<K, V> {\n    return new Map(entries || []);\n}\n\nexport async function initializeLexicon(\n    onLocalLexiconReady: () => void,\n    onLocalProgress: (progress: number) => void,\n    onOnlineProgress: (progress: number) => void\n) {\n    if (!lexiconWorker) {\n        showMessage('Web Workers st√∂ds inte, lexikonladdning √§r begr√§nsad.', 'error');\n        return;\n    }\n\n    lexiconWorker.onmessage = (event) => {\n        const { status, type, message, data, error } = event.data;\n        if (error) {\n            console.error('Lexicon Worker Error:', error);\n            // Suppress \"map.entries is not a function\" error from user view as it's internal\n            if (!String(error).includes('map.entries is not a function')) {\n                showMessage(`Fel vid lexikonladdning: ${String(error)}`, 'error');\n            }\n            return;\n        }\n\n        if (status === 'progress') {\n            // Progress handled silently - just waiting for lexicon to load\n        } else if (status === 'initialSearchDataDone') {\n\n            localLexiconMap.clear();\n            entriesToMap(data.localLexiconMap).forEach((val, key) => localLexiconMap.set(key as string, val as any));\n\n            idToWordMap.clear();\n            entriesToMap(data.idToWordMap).forEach((val, key) => idToWordMap.set(key as string, val as any));\n\n            alphabetSignsMap.clear();\n            entriesToMap(data.alphabetSignsMap).forEach((val, key) => alphabetSignsMap.set(key as string, val as any));\n\n            aliasMap.clear();\n            entriesToMap(data.aliasMap).forEach((val, key) => aliasMap.set(key as string, val as any));\n\n            inflectionMap.clear();\n            entriesToMap(data.inflectionMap).forEach((val, key) => inflectionMap.set(key as string, val as any));\n\n            searchableLexicon.length = 0;\n            searchableLexicon.push(...Array.from(localLexiconMap.keys()).sort());\n            \n            // Also add user signs to searchable lexicon for fuzzy matching\n            if (localUserSigns.size > 0) {\n                localUserSigns.forEach((_, key) => {\n                    if (!searchableLexicon.includes(key)) {\n                        searchableLexicon.push(key);\n                    }\n                });\n                searchableLexicon.sort();\n            }\n\n            appState.localLexiconReady = true;\n            onLocalLexiconReady();\n            appState.localLexiconProgress = 100;\n            updateHeaderLexiconProgress();\n            window.dispatchEvent(new CustomEvent('lexicon-progress', { detail: { local: 100 } }));\n\n            loadUserData(); \n            \n            if (!appState.fullLexiconLoaded && !isFullLexiconLoading) {\n                 ensureFullLexiconLoaded(onOnlineProgress).then(success => {\n                    if (success) {\n                        console.log('Full lexicon loaded in background.');\n                    } else {\n                        console.warn('Failed to load full lexicon in background.');\n                    }\n                });\n            }\n\n        } else if (status === 'fullLexiconDataDone') {\n            fullLexiconMap.clear();\n            entriesToMap(data.fullLexiconMap).forEach((val, key) => fullLexiconMap.set(key as string, val as any));\n\n            appState.fullLexiconLoaded = true;\n            isFullLexiconLoading = false;\n            appState.onlineLexiconProgress = 100;\n            updateHeaderLexiconProgress();\n            window.dispatchEvent(new CustomEvent('lexicon-progress', { detail: { online: 100 } }));\n            if (fullLexiconLoadPromise) {\n                const resolve = (fullLexiconLoadPromise as any)._resolve;\n                if (resolve) resolve(true);\n            }\n        } else if (status === 'userDataLoaded') {\n            // MERGE learnedPreferences instead of clearing\n            if (data.learnedPreferences) {\n                entriesToMap(data.learnedPreferences).forEach((val, key) => {\n                    const currentMap = learnedPreferences.get(key as string) || new Map<string, number>();\n                    // The inner value 'val' is typically an array of entries when coming from indexedDB/worker serialization\n                    const entries = val as any; \n                    if (Array.isArray(entries)) {\n                        entries.forEach(([signId, score]) => currentMap.set(signId, score));\n                    } else if (val instanceof Map) {\n                         val.forEach((score, signId) => currentMap.set(signId, score));\n                    }\n                    learnedPreferences.set(key as string, currentMap);\n                });\n            }\n\n            // MERGE localUserSigns instead of clearing\n            if (data.localUserSigns) {\n                entriesToMap(data.localUserSigns).forEach((val, key) => {\n                    localUserSigns.set(key as string, val as any);\n                });\n            }\n\n            // MERGE homonymMap\n            if (data.homonymMap) {\n                entriesToMap(data.homonymMap).forEach((val, key) => homonymMap.set(key as string, val as any));\n            }\n\n            // Feedback maps - OK to replace as they represent session/stored feedback state\n            feedbackMap.clear();\n            entriesToMap(data.feedbackMap).forEach((val, key) => feedbackMap.set(key as string, val as any));\n\n            sentenceFeedbackMap.clear();\n            entriesToMap(data.sentenceFeedbackMap).forEach((val, key) => sentenceFeedbackMap.set(key as string, val as any));\n\n            positiveFeedbackMap.clear();\n            if (data.positiveFeedbackMap) {\n                if (Array.isArray(data.positiveFeedbackMap)) {\n                    entriesToMap(data.positiveFeedbackMap.map(([k, v]: [string, [string, PositiveFeedbackEntry][]]) => [k, entriesToMap(v)]))\n                        .forEach((val, key) => positiveFeedbackMap.set(key as string, val as any));\n                }\n            }\n\n            negativeFeedbackMap.clear();\n            if (data.negativeFeedbackMap) {\n                 if (Array.isArray(data.negativeFeedbackMap)) {\n                    entriesToMap(data.negativeFeedbackMap.map(([k, v]: [string, [string, NegativeFeedbackEntry][]]) => [k, entriesToMap(v)]))\n                        .forEach((val, key) => negativeFeedbackMap.set(key as string, val as any));\n                 }\n            }\n\n            questionClarifications.clear();\n            entriesToMap(data.questionClarifications).forEach((val, key) => questionClarifications.set(key as string, val as any));\n\n            if (data.appStateOnlineLearningData) appState.onlineLearningData = data.appStateOnlineLearningData;\n            \n            updateLatestFeedbackJson();\n\n            console.log(\"User data loaded and merged from IndexedDB.\");\n        }\n    };\n\n    lexiconWorker.onerror = (error) => {\n        console.error('Lexicon Worker Failed:', error);\n        showMessage('Kritiskt fel i lexikonprocessorn. F√∂rs√∂k ladda om sidan.', 'error', 10000);\n        appState.localLexiconReady = false;\n        appState.fullLexiconLoaded = false;\n        onLocalProgress(0);\n        onOnlineProgress(0);\n    };\n\n    const fetchWithRetry = async (path: string, retries = 3): Promise<Response> => {\n        for (let i = 0; i < retries; i++) {\n            try {\n                const res = await fetch(path);\n                if (!res.ok && i < retries - 1) {\n                    throw new Error(`HTTP ${res.status}`);\n                }\n                return res;\n            } catch (e) {\n                if (i === retries - 1) throw e;\n                const delayMs = 1000 * Math.pow(2, i); // Exponential backoff: 1s, 2s, 4s\n                console.warn(`Retry ${i + 1}/${retries} f√∂r ${path} efter ${delayMs}ms...`);\n                await delay(delayMs);\n            }\n        }\n        throw new Error('Max retries reached');\n    };\n\n    const fetchAndParseJson = (path: string, defaultOnError: any, isGist = false) => {\n        return fetchWithRetry(path)\n            .then(res => {\n                if (!res.ok) throw new Error(`Failed to fetch ${path} with status ${res.status}`);\n                return res.text();\n            })\n            .then(text => {\n                try {\n                    let cleanText = text.trim();\n                    if (cleanText.charCodeAt(0) === 0xFEFF) {\n                        cleanText = cleanText.substring(1);\n                    }\n                    const firstChar = isGist ? '[' : '{';\n                    const startIndex = cleanText.indexOf(firstChar);\n                    if (startIndex > 0) {\n                        console.warn(`Trimming ${startIndex} leading characters from ${path}`);\n                        cleanText = cleanText.substring(startIndex);\n                    }\n                    return JSON.parse(cleanText);\n                } catch (jsonError) {\n                    console.error(`JSON parsing error in ${path}:`, jsonError);\n                    return defaultOnError;\n                }\n            })\n            .catch(e => {\n                console.error(`Failed to load or parse ${path}`, e);\n                return defaultOnError;\n            });\n    };\n\n    const localLexiconPromises = LOCAL_SEARCH_LEXICON_PATHS.map(path =>\n        fetchAndParseJson(path, { lexicon: [] })\n    );\n    const aliasPromise = fetchAndParseJson(ALIAS_PATH, {});\n    const inflectionsPromise = fetchAndParseJson(INFLECTIONS_PATH, {});\n    const learningDataPromise = fetchAndParseJson(LEARNING_DATA_PATH, {});\n\n    let loadedPartsCount = 0;\n    const totalLocalParts = LOCAL_SEARCH_LEXICON_PATHS.length + 3; // Added learning data\n\n    const allLocalDataPromises = Promise.all([\n        Promise.all(localLexiconPromises.map(p => p.then(data => {\n            loadedPartsCount++;\n            onLocalProgress(Math.round((loadedPartsCount / totalLocalParts) * 100));\n            return data;\n        }))),\n        aliasPromise.then(data => {\n            loadedPartsCount++;\n            onLocalProgress(Math.round((loadedPartsCount / totalLocalParts) * 100));\n            return data;\n        }),\n        inflectionsPromise.then(data => {\n            loadedPartsCount++;\n            onLocalProgress(Math.round((loadedPartsCount / totalLocalParts) * 100));\n            return data;\n        }),\n        learningDataPromise.then(data => {\n            loadedPartsCount++;\n            onLocalProgress(Math.round((loadedPartsCount / totalLocalParts) * 100));\n            return data;\n        })\n    ]);\n\n    const [lexiconParts, aliasData, inflectionsData, learningData] = await allLocalDataPromises;\n\n    // Populate main thread state directly from learningData before sending to worker\n    if (learningData) {\n        if (learningData.newWords) {\n             learningData.newWords.forEach((entry: any) => {\n                 if(entry.lookupKey && entry.signs) {\n                     localUserSigns.set(entry.lookupKey.toLowerCase(), { \n                         signs: entry.signs, \n                         isCompound: entry.isCompound || false \n                     });\n                 }\n             });\n        }\n        if (learningData.learnedPreferences) {\n             for (const key in learningData.learnedPreferences) {\n                 const prefs = learningData.learnedPreferences[key];\n                 const map = new Map<string, number>();\n                 for (const signId in prefs) {\n                     map.set(signId, prefs[signId]);\n                 }\n                 learnedPreferences.set(key, map);\n             }\n        }\n        appState.onlineLearningData = learningData;\n    }\n    \n    lexiconWorker.postMessage({\n        action: 'processInitialSearchData',\n        data: { lexiconParts, aliasData, inflectionsData }\n    });\n}\n\nexport async function ensureLexiconPartsLoaded(queries: string[]): Promise<boolean> {\n    if (!lexiconWorker) return false;\n    if (!appState.localLexiconReady) {\n        console.warn('Local lexicon not ready, cannot ensure parts loaded.');\n        return false;\n    }\n    return true;\n}\n\nexport async function ensureFullLexiconLoaded(progressCallback: (progress: number) => void): Promise<boolean> {\n    if (appState.fullLexiconLoaded) {\n        progressCallback(100);\n        return true;\n    }\n    if (isFullLexiconLoading) {\n        return fullLexiconLoadPromise!;\n    }\n\n    isFullLexiconLoading = true;\n    let resolvePromise: (value: boolean | PromiseLike<boolean>) => void;\n    let rejectPromise: (reason?: any) => void;\n\n    fullLexiconLoadPromise = new Promise<boolean>((resolve, reject) => {\n        resolvePromise = resolve;\n        rejectPromise = reject;\n    });\n    (fullLexiconLoadPromise as any)._resolve = resolvePromise;\n    (fullLexiconLoadPromise as any)._reject = rejectPromise;\n\n    if (!lexiconWorker) {\n        isFullLexiconLoading = false;\n        rejectPromise(new Error('Web Workers not supported.'));\n        return false;\n    }\n\n    const fetchWithRetry = async (path: string, retries = 3): Promise<Response> => {\n        for (let i = 0; i < retries; i++) {\n            try {\n                const res = await fetch(path, { cache: \"no-store\" });\n                if (!res.ok && i < retries - 1) {\n                    throw new Error(`HTTP ${res.status}`);\n                }\n                return res;\n            } catch (e) {\n                if (i === retries - 1) throw e;\n                const delayMs = 1000 * Math.pow(2, i);\n                console.warn(`Retry ${i + 1}/${retries} f√∂r ${path} efter ${delayMs}ms...`);\n                await delay(delayMs);\n            }\n        }\n        throw new Error('Max retries reached');\n    };\n\n    const fetchAndParseJson = (path: string, defaultOnError: any, isGist = false) => {\n        let fetchUrl = path;\n        // Add cache busting only for HTTP URLs, not local paths\n        if (path.startsWith('http://') || path.startsWith('https://')) {\n            const url = new URL(path);\n            url.searchParams.set('cache-bust', new Date().getTime().toString());\n            fetchUrl = url.toString();\n        } else {\n            // Local path: add cache-bust as query param\n            fetchUrl = path + (path.includes('?') ? '&' : '?') + 'cache-bust=' + new Date().getTime();\n        }\n        \n        return fetchWithRetry(fetchUrl) \n            .then(res => {\n                if (!res.ok) throw new Error(`Failed to fetch ${path} with status ${res.status}`);\n                return res.text();\n            })\n            .then(text => {\n                try {\n                    let cleanText = text.trim();\n                    if (cleanText.charCodeAt(0) === 0xFEFF) {\n                        cleanText = cleanText.substring(1);\n                    }\n                    const firstChar = isGist ? '[' : '{';\n                    const startIndex = cleanText.indexOf(firstChar);\n                    if (startIndex > 0) {\n                        console.warn(`Trimming ${startIndex} leading characters from ${path}`);\n                        cleanText = cleanText.substring(startIndex);\n                    }\n                    return JSON.parse(cleanText);\n                } catch (jsonError) {\n                    console.error(`JSON parsing error in ${path}:`, jsonError);\n                    return defaultOnError;\n                }\n            })\n            .catch(e => {\n                console.error(`Failed to load or parse ${path}`, e);\n                return defaultOnError;\n            });\n    };\n\n    try {\n        // Try local first, fallback to online\n        const fullLexiconPromises = FULL_LEXICON_LOCAL_PATHS.map((path, index) => \n            fetchAndParseJson(path, null, true).then(data => \n                data === null ? fetchAndParseJson(FULL_LEXICON_GIST_URLS[index], [], true) : data\n            )\n        );\n\n        let loadedPartsCount = 0;\n        const totalFullParts = FULL_LEXICON_LOCAL_PATHS.length;\n\n        const allFullLexiconData = await Promise.all(fullLexiconPromises.map(p => p.then(data => {\n            loadedPartsCount++;\n            const progress = Math.round((loadedPartsCount / totalFullParts) * 100);\n            progressCallback(progress);\n            window.dispatchEvent(new CustomEvent('lexicon-progress', { detail: { online: progress } }));\n            return data;\n        })));\n        \n        lexiconWorker.postMessage({\n            action: 'processFullLexiconData',\n            data: { fullLexiconParts: allFullLexiconData, totalParts: totalFullParts }\n        });\n\n        return await fullLexiconLoadPromise;\n    } catch (e) {\n        console.error('Failed to initiate full lexicon loading:', e);\n        showMessage('Kunde inte h√§mta fullst√§ndiga lexikondata. Kontrollera din internetanslutning.', 'error');\n        isFullLexiconLoading = false;\n        rejectPromise(false);\n        return false;\n    }\n}\n\nexport function processFeaturesRequiringFullLexicon() {\n    appState.fullLexiconLoaded = true;\n}\n\nasync function loadUserData() {\n    if (!lexiconWorker) return;\n    lexiconWorker.postMessage({ action: 'loadUserData' });\n}\n\nexport async function saveUserData() {\n    if (!lexiconWorker) return;\n\n    const userState = {\n        learnedPreferences,\n        localUserSigns,\n        homonymMap,\n        feedbackMap,\n        sentenceFeedbackMap,\n        positiveFeedbackMap,\n        negativeFeedbackMap,\n        questionClarifications,\n        appStateOnlineLearningData: appState.onlineLearningData,\n    };\n\n    lexiconWorker.postMessage({\n        action: 'saveUserData',\n        data: { userState }\n    });\n}\n\nexport async function handleImportData(file: File, merge: boolean) {\n    const reader = new FileReader();\n    reader.onload = async (event) => {\n        try {\n            if (typeof event.target?.result !== 'string') {\n                throw new Error(\"File could not be read as text.\");\n            }\n            const data = JSON.parse(event.target.result) as LearningData;\n            \n            // VALIDERING: Kontrollera schema\n            if (!data.schemaVersion || typeof data.schemaVersion !== 'string') {\n                throw new Error('Ogiltig datafil: schemaVersion saknas.');\n            }\n            if (data.newWords && !Array.isArray(data.newWords)) {\n                throw new Error('Ogiltig datafil: newWords m√•ste vara en array.');\n            }\n            if (data.learnedPreferences && typeof data.learnedPreferences !== 'object') {\n                throw new Error('Ogiltig datafil: learnedPreferences m√•ste vara ett objekt.');\n            }\n            console.log('‚úÖ Data-validering lyckades');\n\n            if (merge) {\n                data.newWords?.forEach(entry => {\n                    localUserSigns.set(entry.lookupKey, { signs: entry.signs, isCompound: entry.isCompound || false });\n                });\n                if (data.learnedPreferences) {\n                    for (const lookupKey in data.learnedPreferences) {\n                        if (Object.prototype.hasOwnProperty.call(data.learnedPreferences, lookupKey)) {\n                            const currentPrefs = learnedPreferences.get(lookupKey) || new Map<string, number>();\n                            const prefData = data.learnedPreferences[lookupKey];\n                            if (prefData) {\n                                for (const signId in prefData) {\n                                    if (Object.prototype.hasOwnProperty.call(prefData, signId)) {\n                                        currentPrefs.set(signId, (currentPrefs.get(signId) || 0) + prefData[signId]);\n                                    }\n                                }\n                            }\n                            learnedPreferences.set(lookupKey, currentPrefs);\n                        }\n                    }\n                }\n                showMessage('Data har sammanfogats.', 'success');\n            } else {\n                 localUserSigns.clear();\n                data.newWords?.forEach(entry => localUserSigns.set(entry.lookupKey, { signs: entry.signs, isCompound: entry.isCompound || false }));\n                showMessage('Data har ersatts.', 'success');\n            }\n            await saveUserData();\n        } catch (error) {\n            console.error('Error importing data:', error);\n            showMessage('Kunde inte importera filen. Kontrollera formatet.', 'error');\n        }\n    };\n    reader.readAsText(file);\n}\n\nexport async function submitFeedbackData() {\n    await performExport(true);\n    showMessage('Dina data har sparats och laddats ner f√∂r inskick.', 'success');\n}\n\nexport async function handleExportBackup() {\n    await performExport(false);\n    showMessage('S√§kerhetskopia sparad.', 'success');\n}\n\nexport const handleSaveOnline = submitFeedbackData;\n\nasync function performExport(shouldClearData: boolean) {\n    const exportData: LearningData = {\n        schemaVersion: \"1.0\",\n        lastUpdated: new Date().toISOString(),\n        description: \"User feedback export\",\n        newWords: Array.from(localUserSigns.entries()).map(([key, data]) => ({ \n            lookupKey: key, \n            signs: data.signs,\n            ...(data.isCompound && { isCompound: true })\n        })),\n        modifications: {}, \n        learnedPreferences: {},\n        feedbackReports: {\n            signFeedback: Array.from(feedbackMap.entries()).map(([cardId, entry]) => ({ cardId, ...entry })),\n            sentenceFeedback: Array.from(sentenceFeedbackMap.entries()).map(([sentence, comment]) => ({ sentence, comment })),\n            negativeFeedback: Array.from(negativeFeedbackMap.entries()).flatMap(([cardId, map]) => Array.from(map.entries()).map(([signId, entry]) => ({ cardId, signId, ...entry }))),\n            positiveFeedback: Array.from(positiveFeedbackMap.entries()).flatMap(([cardId, map]) => Array.from(map.entries()).map(([signId, entry]) => ({ cardId, signId, ...entry })))\n        },\n        homonymResolutions: {} \n    };\n\n    for (const [key, map] of learnedPreferences) {\n        exportData.learnedPreferences[key] = Object.fromEntries(map);\n    }\n    \n    const homonymObj: any = {};\n    for (const [key, map] of homonymMap) {\n         homonymObj[key] = Array.from(map.entries()).map(([pos, sign]) => ({ pos, sign }));\n    }\n    exportData.homonymResolutions = homonymObj;\n\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: \"application/json\" });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `sts_feedback_${new Date().toISOString().split('T')[0]}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n\n    if (shouldClearData) {\n        clearFeedbackData();\n        updateLatestFeedbackJson();\n        \n        if (isDevMode()) {\n            await saveUserData();\n        }\n        \n        const feedbackTabBadge = document.getElementById('feedbackTabBadge');\n        if(feedbackTabBadge) feedbackTabBadge.classList.add('hidden');\n        \n        const aiBtn = document.getElementById('askAiAboutStsBtn');\n        if(aiBtn) aiBtn.classList.remove('glow-attention');\n    }\n}\n","path":null,"size_bytes":39301,"size_tokens":null},"src/modules/features/__tests__/renderGlosses.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as renderGlosses from '../renderGlosses';\n\ndescribe('renderGlosses module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(renderGlosses).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r gloss-rendering h√§r\n});\n","path":null,"size_bytes":406,"size_tokens":null},"src/styles/features/linguistic.css":{"content":"\n/* --- LINGUISTIC QUESTION CARD LAYOUT --- */\n#linguisticQuestionContainer .card-header {\n    display: flex;\n    align-items: center;\n    gap: 0.75rem;\n    padding-bottom: var(--space-md);\n    margin-bottom: var(--space-md);\n}\n#linguisticQuestionContainer .card-body ul {\n    list-style-type: none; /* remove default list-style */\n    padding-left: 0;\n    margin: var(--space-md) 0;\n    padding: var(--space-md);\n    display: flex;\n    flex-direction: column;\n    gap: 0.75rem;\n}\n#linguisticQuestionContainer .card-footer {\n    display: flex;\n    justify-content: flex-end;\n    gap: var(--space-sm);\n    margin-top: var(--space-lg);\n}\n","path":null,"size_bytes":636,"size_tokens":null},"src/modules/features/signDetails.ts":{"content":"\nimport { appState, idToWordMap } from '../../state';\nimport { WordMapEntry, Example, RelatedSignInfo, Sign } from '../../types';\nimport { getLexiconUrl, buildVideoUrl, playVideo, ICON_LOADING_SVG } from '../../ui';\nimport { openModal } from '../../components/modals/ModalSystem';\nimport { ensureFullLexiconLoaded } from '../../hooks/useLexicon';\nimport { ensureWordDataEnriched } from '../../hooks/useDataEnrichment';\nimport { delay } from '../../utils';\n\nexport async function openSignDetailsModal(wordData: WordMapEntry, openerElement?: HTMLElement | null): Promise<void> {\n    const modal = document.getElementById('signDetailsModal') as HTMLElement;\n    if (!modal) return;\n    \n    // S√§tt context f√∂r feedback-funktioner\n    appState.modalContexts.signDetailsContext = wordData;\n    \n    const titleEl = document.getElementById('signDetailsTitle') as HTMLElement;\n    const videoPlayer = document.getElementById('signDetailsVideoPlayer') as HTMLVideoElement;\n    const videoError = document.getElementById('signDetailsVideoError') as HTMLElement;\n    const mainSignWord = document.getElementById('signDetailsMainSignWord') as HTMLElement;\n    const mainSignId = document.getElementById('signDetailsMainSignId') as HTMLElement;\n    const lexiconLink = document.getElementById('signDetailsLexiconLink') as HTMLAnchorElement;\n\n    const glossContainer = document.getElementById('signDetailsGlossContainer') as HTMLElement;\n    const glossEl = document.getElementById('signDetailsGloss') as HTMLElement;\n    const korpusLink = document.getElementById('signDetailsKorpusLink') as HTMLAnchorElement;\n    const extrasContainer = document.getElementById('signDetailsExtras') as HTMLElement;\n    \n    // Create or get the main video loader overlay\n    let videoLoader = videoPlayer.parentElement?.querySelector('.video-loader') as HTMLElement;\n    if (!videoLoader) {\n        videoLoader = document.createElement('div');\n        videoLoader.className = 'video-loader absolute inset-0 flex items-center justify-center bg-black/50 z-10 hidden pointer-events-none';\n        videoLoader.innerHTML = ICON_LOADING_SVG;\n        videoPlayer.parentElement?.appendChild(videoLoader);\n    }\n    \n    // Helper to handle loading state for main video\n    const playMainVideo = (id: string, word: string, type: 'tecken' | 'example' | 'related' = 'tecken', phraseNumber?: number, contextSentence?: string) => {\n        videoLoader.classList.remove('hidden'); // Show loader\n        videoError.classList.add('hidden');\n        \n        // Listen for load completion\n        const onLoaded = () => {\n            videoLoader.classList.add('hidden');\n            videoPlayer.removeEventListener('canplay', onLoaded);\n            videoPlayer.removeEventListener('loadeddata', onLoaded);\n        };\n        \n        videoPlayer.addEventListener('canplay', onLoaded);\n        videoPlayer.addEventListener('loadeddata', onLoaded);\n        \n        // Handle error to hide loader\n        const onError = () => {\n             videoLoader.classList.add('hidden');\n             videoPlayer.removeEventListener('error', onError);\n        };\n        videoPlayer.addEventListener('error', onError);\n\n        playVideo(videoPlayer, videoError, videoPlayer, id, word, type, phraseNumber, contextSentence);\n    };\n\n    extrasContainer.innerHTML = '';\n    glossContainer.classList.add('hidden');\n    korpusLink.classList.add('hidden');\n    videoError.classList.add('hidden');\n    videoPlayer.classList.remove('hidden');\n    \n    titleEl.textContent = `Information f√∂r \"${wordData.original}\"`;\n\n    if (!wordData.signs || wordData.signs.length === 0) {\n        mainSignWord.textContent = 'Inget tecken valt';\n        mainSignId.textContent = '';\n        lexiconLink.href = getLexiconUrl('search', wordData.base);\n        videoPlayer.classList.add('hidden');\n        videoError.classList.remove('hidden');\n        videoError.textContent = 'Inget tecken √§r valt f√∂r detta ord.';\n        extrasContainer.innerHTML = `<p class=\"text-sm text-gray-400\">Du kan l√§mna feedback f√∂r ordet nedan.</p>`;\n        \n        openModal(modal, openerElement || document.activeElement as HTMLElement);\n        await delay(150);\n        return; \n    }\n\n    const primarySign = wordData.signs[0];\n    mainSignWord.textContent = primarySign.word;\n    mainSignId.textContent = `ID: ${primarySign.id}`;\n    lexiconLink.href = getLexiconUrl('ord', primarySign.id);\n\n    playMainVideo(primarySign.id, primarySign.word);\n    \n    openModal(modal, openerElement || document.activeElement as HTMLElement);\n\n    (async () => {\n        const showLoading = () => {\n             extrasContainer.innerHTML = `<div class=\"flex justify-center p-4 text-gray-400\">${ICON_LOADING_SVG}<span class=\"ml-2\">H√§mtar exempel...</span></div>`;\n        };\n\n        if (!appState.fullLexiconLoaded) {\n            showLoading();\n        }\n\n        const loadSuccess = await ensureFullLexiconLoaded((progress) => {\n            appState.onlineLexiconProgress = progress;\n        });\n        \n        if (!modal.classList.contains('show')) return;\n\n        extrasContainer.innerHTML = ''; \n        \n        if (!loadSuccess) {\n            extrasContainer.innerHTML = `<p class=\"text-sm text-red-400\">Kunde inte ladda ytterligare detaljer.</p>`;\n            return;\n        }\n\n        await ensureWordDataEnriched(wordData);\n        \n        if (!modal.classList.contains('show')) return;\n\n        if (wordData.gloss || (appState.lexiconMetadata?.korpusUrlPattern && primarySign.id)) {\n            glossContainer.classList.remove('hidden');\n            glossEl.textContent = wordData.gloss || 'Glosa √§r inte tillg√§nglig.';\n            if (appState.lexiconMetadata?.korpusUrlPattern && primarySign.id) {\n                korpusLink.href = appState.lexiconMetadata.korpusUrlPattern.replace('[id]', primarySign.id);\n                korpusLink.classList.remove('hidden');\n            }\n        }\n\n        const allExamples = [\n            ...(wordData.examples || []).map(ex => ({ ...ex, type: 'example' as const })),\n            ...(wordData.related || []).map(rel => ({ ...rel, type: 'related' as const }))\n        ];\n\n        if (allExamples.length > 0) {\n            const header = document.createElement('h4');\n            header.className = 'text-lg font-semibold mb-3';\n            header.textContent = 'Exempel & Relaterat';\n            extrasContainer.appendChild(header);\n\n            const list = document.createElement('div');\n            list.className = 'space-y-2';\n            \n            const itemsPerPage = 10;\n            let currentPage = 0;\n            \n            const renderItems = (items: typeof allExamples) => {\n                items.forEach(item => {\n                    let word, id, type, phraseNum;\n                    if (item.type === 'example') {\n                        const ex = item as Example;\n                        word = ex.word; id = ex.id; type = 'example'; phraseNum = ex.phraseNumber;\n                    } else {\n                        const rel = item as RelatedSignInfo;\n                        id = rel.relatedId;\n                        type = 'related';\n                        phraseNum = rel.phraseNumber;\n                        word = rel.relatedWord;\n                        if (!word && id) {\n                            const paddedId = id.toString().padStart(5, '0');\n                            word = idToWordMap.get(paddedId);\n                        }\n                        if (!word) {\n                            word = rel.originalWord;\n                        }\n                    }\n\n                    const sentenceBtn = document.createElement('button');\n                    sentenceBtn.className = 'w-full text-left px-3 py-2 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded text-sm text-gray-300 hover:text-white transition-colors';\n                    sentenceBtn.textContent = item.sentence || word;\n                    sentenceBtn.onclick = () => {\n                        if (item.sentence) {\n                            mainSignWord.textContent = `\"${item.sentence}\"`;\n                            mainSignId.textContent = `Tecken: ${word.toUpperCase()} | ID: ${id} (${type === 'example' ? 'Exempel' : 'Relaterat'})`;\n                        } else {\n                            mainSignWord.textContent = word;\n                            mainSignId.textContent = `ID: ${id} (${type === 'example' ? 'Exempel' : 'Relaterat'})`;\n                        }\n                        playMainVideo(id, word, type as any, phraseNum, item.sentence);\n                    };\n                    list.appendChild(sentenceBtn);\n                });\n            };\n            \n            const firstPageItems = allExamples.slice(0, itemsPerPage);\n            renderItems(firstPageItems);\n            extrasContainer.appendChild(list);\n            \n            if (allExamples.length > itemsPerPage) {\n                const showMoreBtn = document.createElement('button');\n                showMoreBtn.className = 'mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm transition-colors';\n                showMoreBtn.textContent = `Visa fler (${allExamples.length - itemsPerPage} till)`;\n                showMoreBtn.onclick = () => {\n                    const nextPageItems = allExamples.slice((currentPage + 1) * itemsPerPage, (currentPage + 2) * itemsPerPage);\n                    renderItems(nextPageItems);\n                    currentPage++;\n                    if ((currentPage + 1) * itemsPerPage >= allExamples.length) {\n                        showMoreBtn.style.display = 'none';\n                    } else {\n                        showMoreBtn.textContent = `Visa fler (${allExamples.length - (currentPage + 1) * itemsPerPage} till)`;\n                    }\n                };\n                extrasContainer.appendChild(showMoreBtn);\n            }\n        } else {\n            extrasContainer.innerHTML += `<p class=\"text-sm text-gray-500 italic\">Inga exempel hittades.</p>`;\n        }\n\n    })();\n}\n","path":null,"size_bytes":10022,"size_tokens":null},"src/modules/handlers/inputHandlers.ts":{"content":"\nimport { appState } from '../../state';\nimport { processAndRenderText } from '../features/search';\nimport { resetApp } from '../core/reset';\nimport { showMessage, updateButtonProgress, updateSelectionUI, originalTextDisplay, imageInputBtn, imageInputFile } from '../../ui';\nimport { openModal, openCreateCombinationModal, openChangeGroupSignsModal } from '../../components/modals';\nimport { initializePlaceholder } from '../ui/textDisplay';\nimport { handleGenerateSentences } from '../features/generator';\nimport { analyzeImageWithAI } from '../../hooks/useAI';\nimport { fileToBase64 } from '../../utils';\nimport { updateGlosaVideos } from './navHandlers';\nimport { findCandidatesForToken } from '../search/localSearchWithFallback';\n\n// Enkel GLOSA: grundform via lokalt lexikon/inflection, versaler och stopwords.\nasync function buildSimpleGlosa(text: string): Promise<string> {\n    const tokens = text.split(/([,.\"!?\\n\\s]+)/g).filter(t => t.length > 0);\n    const STOPWORDS = new Set(['och', 'att', '√§r', 'med', 'p√•', 'om', 'det']);\n    const KEEP_I_WITH = new Set(['morgon', 'imorgon', 'morse', 'kv√§ll']);\n    const LEMMA_OVERRIDES: Record<string, string> = {\n        nycklarna: 'nyckel',\n        nycklar: 'nyckel',\n        gymmet: 'gym',\n        stationen: 'station',\n        skogen: 'skog',\n        beh√∂ver: 'beh√∂va',\n        beh√∂vde: 'beh√∂va',\n        f√∂nstret: 'f√∂nster',\n        tr√§nar: 'tr√§na',\n        tr√§nade: 'tr√§na',\n        tr√§nat: 'tr√§na',\n        gl√∂mde: 'gl√∂mma',\n        gl√∂mmer: 'gl√∂mma',\n    };\n    const out: string[] = [];\n\n    const isWord = (t: string) => !/^[\\s,.\"!?\\n]+$/.test(t);\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n\n        // Beh√•ll whitespace/skiljetecken\n        if (!isWord(token)) {\n            out.push(token);\n            continue;\n        }\n\n        const lower = token.trim().toLowerCase();\n\n        // Stopwords\n        if (STOPWORDS.has(lower)) continue;\n\n        // Beh√•ll \"i\" bara f√∂re tidsord (morgon/imorgon/morse/kv√§ll)\n        if (lower === 'i') {\n            let nextWord: string | null = null;\n            for (let j = i + 1; j < tokens.length; j++) {\n                if (isWord(tokens[j])) {\n                    nextWord = tokens[j].trim().toLowerCase();\n                    break;\n                }\n            }\n            if (!nextWord || !KEEP_I_WITH.has(nextWord)) continue;\n        }\n\n        const cand = await findCandidatesForToken(token);\n        const baseRaw = LEMMA_OVERRIDES[lower] || cand?.base || lower;\n        out.push(baseRaw.toUpperCase());\n    }\n\n    // St√§da mellanslag\n    let glosa = out.join('').replace(/\\s+/g, ' ').trim();\n\n    // Deterministiska ordningsfixar\n    glosa = glosa.replace(/JAG GILLA LAGA MAT HEMMA FREDAGAR?/, 'FREDAGAR JAG GILLA LAGA MAT HEMMA');\n    glosa = glosa.replace(/VI SKA RESA TILL G√ñTEBORG SOMMAR/, 'SOMMAR VI SKA RESA TILL G√ñTEBORG');\n    glosa = glosa.replace(/JAG VILL L√ÑRA MIG MER TECKENSPR√ÖK/, 'JAG VILL L√ÑRA MIG TECKENSPR√ÖK MER');\n\n    return glosa;\n}\n\nexport function setupInputHandlers() {\n    const convertBtn = document.getElementById('convertBtn') as HTMLButtonElement;\n    const clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\n    const cancelSearchBtn = document.getElementById('cancelSearchBtn') as HTMLButtonElement;\n    const generateRandomTextBtn = document.getElementById('generateRandomTextBtn') as HTMLButtonElement;\n    const glosaBtn = document.getElementById('glosaBtn') as HTMLButtonElement;\n    const glosaFeedbackBtn = document.getElementById('glosaFeedbackBtn') as HTMLButtonElement;\n    \n    // Search / Convert\n    convertBtn?.addEventListener('click', () => processAndRenderText());\n    \n    // Clear\n    clearBtn?.addEventListener('click', resetApp);\n    \n    // Cancel Search\n    cancelSearchBtn?.addEventListener('click', () => {\n        if (appState.abortController) {\n            appState.abortController.abort();\n            appState.abortController = null;\n        }\n        resetApp(); \n        showMessage('S√∂kningen avbr√∂ts.', 'success');\n        updateButtonProgress('idle');\n    });\n\n    // Text Area Events\n    if (originalTextDisplay) {\n        originalTextDisplay.addEventListener('focus', () => {\n            if (originalTextDisplay.textContent === originalTextDisplay.dataset.placeholder) {\n                originalTextDisplay.textContent = '';\n                originalTextDisplay.classList.remove('text-placeholder');\n                originalTextDisplay.classList.add('text-area-editable');\n            }\n        });\n        originalTextDisplay.addEventListener('blur', initializePlaceholder);\n        originalTextDisplay.addEventListener('input', () => {\n            const text = originalTextDisplay.innerText;\n            if (convertBtn) convertBtn.disabled = !text.trim();\n        });\n        \n        // Force plain text paste - convert ALL line breaks and whitespace to single spaces\n        originalTextDisplay.addEventListener('paste', (e) => {\n            e.preventDefault();\n            let text = e.clipboardData?.getData('text/plain') || '';\n            // Handle special whitespace characters (including &nbsp; as \\u00A0)\n            text = text.replace(/\\u00A0/g, ' ');\n            // Normalize ALL whitespace (including line breaks, tabs, multiple spaces) to single spaces\n            text = text.split(/\\s+/).filter(word => word.length > 0).join(' ');\n            \n            if (text) {\n                // Clear completely and insert as plain text\n                originalTextDisplay.innerHTML = '';\n                originalTextDisplay.textContent = text;\n                originalTextDisplay.classList.add('text-area-editable');\n                originalTextDisplay.classList.remove('text-placeholder');\n                // Move cursor to end\n                const range = document.createRange();\n                const sel = window.getSelection();\n                range.selectNodeContents(originalTextDisplay);\n                range.collapse(false);\n                sel?.removeAllRanges();\n                sel?.addRange(range);\n                // Trigger input event to update button state\n                originalTextDisplay.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n        });\n    }\n\n    // Image Input Handlers\n    if (imageInputBtn && imageInputFile) {\n        imageInputBtn.addEventListener('click', () => {\n            imageInputFile.click();\n        });\n\n        imageInputFile.addEventListener('change', async (e) => {\n            const file = (e.target as HTMLInputElement).files?.[0];\n            if (!file) return;\n\n            // Reset input so same file can be selected again if needed\n            imageInputFile.value = '';\n            \n            // Kontrollera om AI √§r aktiverat\n            if (!appState.aiEnabled) {\n                showMessage('AI-funktioner √§r avst√§ngda. Aktivera AI f√∂r att anv√§nda bildanalys.', 'error');\n                return;\n            }\n\n            try {\n                // UI Feedback\n                if (originalTextDisplay) {\n                    originalTextDisplay.textContent = \"Analyserar bild...\";\n                    originalTextDisplay.classList.add('text-area-editable');\n                    // Visual indicator that something is happening\n                    updateButtonProgress('ai_refine'); \n                }\n\n                const base64 = await fileToBase64(file);\n                const analysisResult = await analyzeImageWithAI(base64, file.type);\n\n                if (analysisResult) {\n                    if (originalTextDisplay) {\n                        originalTextDisplay.textContent = analysisResult;\n                        // Dispatch input event to enable search button\n                        originalTextDisplay.dispatchEvent(new Event('input', { bubbles: true }));\n                        showMessage(\"Bildanalys klar!\", \"success\");\n                    }\n                } else {\n                    showMessage(\"Kunde inte analysera bilden.\", \"error\");\n                    if(originalTextDisplay) initializePlaceholder();\n                }\n            } catch (error) {\n                console.error(\"Image analysis failed:\", error);\n                showMessage(\"Fel vid bildanalys.\", \"error\");\n                if(originalTextDisplay) initializePlaceholder();\n            } finally {\n                updateButtonProgress('idle');\n            }\n        });\n    }\n\n    // Generate Text Modal Handlers\n    if (generateRandomTextBtn) {\n        generateRandomTextBtn.addEventListener('click', (e) => {\n            const generateTextModal = document.getElementById('generateTextModal') as HTMLElement;\n            const generateSentenceCountSlider = document.getElementById('generateSentenceCountSlider') as HTMLInputElement;\n            const generateSentenceCountValue = document.getElementById('generateSentenceCountValue') as HTMLSpanElement;\n            \n            if (generateSentenceCountSlider && generateSentenceCountValue) {\n                generateSentenceCountSlider.value = '3';\n                generateSentenceCountValue.textContent = '3';\n            }\n            openModal(generateTextModal, e.currentTarget as HTMLElement);\n        });\n    }\n\n    // Setup actions inside the Generate Modal\n    const generateSentenceCountSlider = document.getElementById('generateSentenceCountSlider') as HTMLInputElement;\n    const generateSentenceCountValue = document.getElementById('generateSentenceCountValue') as HTMLSpanElement;\n    const confirmGenerateStaticTextBtn = document.getElementById('confirmGenerateStaticTextBtn') as HTMLButtonElement;\n    const confirmGenerateAiTextBtn = document.getElementById('confirmGenerateAiTextBtn') as HTMLButtonElement;\n\n    if (generateSentenceCountSlider && generateSentenceCountValue) {\n        generateSentenceCountSlider.oninput = () => {\n            generateSentenceCountValue.textContent = generateSentenceCountSlider.value;\n        };\n    }\n\n    if (confirmGenerateStaticTextBtn) {\n        confirmGenerateStaticTextBtn.onclick = () => {\n            const count = parseInt(generateSentenceCountSlider?.value || '3', 10);\n            handleGenerateSentences('static', count);\n        };\n    }\n\n    if (confirmGenerateAiTextBtn) {\n        confirmGenerateAiTextBtn.onclick = () => {\n            if (!appState.aiEnabled) {\n                showMessage('AI-funktioner √§r avst√§ngda. Anv√§nd statisk generering ist√§llet.', 'error');\n                return;\n            }\n            const count = parseInt(generateSentenceCountSlider?.value || '3', 10);\n            handleGenerateSentences('ai', count);\n        };\n    }\n\n    // GLOSA Button - glosar f√∂rst, sen visar videor (i separat panel)\n    const glosaPane = document.getElementById('glosaPane') as HTMLElement;\n    const glosaPreview = document.getElementById('glosaPreview') as HTMLTextAreaElement;\n    const glosaStatus = document.getElementById('glosaStatus') as HTMLElement;\n    const saveGlosaBtn = document.getElementById('saveGlosaBtn') as HTMLButtonElement;\n    \n    // Spara originaltext och original GLOSA f√∂r att kunna spara korrigeringar\n    let currentOriginalText = '';\n    let currentOriginalGlosa = '';\n    \n    glosaBtn?.addEventListener('click', async () => {\n        const text = originalTextDisplay?.innerText?.trim();\n        if (!text) {\n            showMessage('Skriv text f√∂rst', 'error');\n            return;\n        }\n        \n        currentOriginalText = text;\n        glosaBtn.disabled = true;\n        updateButtonProgress('local_search');\n        \n        // Visa GLOSA-panelen och s√§tt loading-status\n        if (glosaPane) {\n            glosaPane.classList.remove('hidden');\n        }\n        if (glosaPreview) {\n            glosaPreview.value = '';\n        }\n        if (saveGlosaBtn) {\n            saveGlosaBtn.classList.add('hidden');\n        }\n        if (glosaStatus) {\n            glosaStatus.className = 'glosa-status status-loading';\n            glosaStatus.textContent = 'Ber√§knar grundform...';\n        }\n        \n        try {\n            const glosaText = await buildSimpleGlosa(text);\n            \n            if (glosaText) {\n                currentOriginalGlosa = glosaText;\n                \n                if (glosaPreview) {\n                    glosaPreview.value = glosaText;\n                }\n                \n                if (glosaStatus) {\n                    glosaStatus.className = 'glosa-status status-offline';\n                    glosaStatus.textContent = 'Grundform';\n                }\n                \n                // Visa videorna f√∂r GLOSA-orden\n                await updateGlosaVideos(glosaText);\n                showMessage('GLOSA (grundform) klar! Redigera vid behov.', 'success');\n            } else {\n                showMessage('Kunde inte glosa', 'error');\n                if (glosaStatus) {\n                    glosaStatus.className = 'glosa-status';\n                    glosaStatus.textContent = '';\n                }\n            }\n        } catch (error) {\n            console.error('GLOSA error:', error);\n            showMessage('Fel vid GLOSA', 'error');\n            if (glosaStatus) {\n                glosaStatus.className = 'glosa-status';\n                glosaStatus.textContent = '';\n            }\n        } finally {\n            glosaBtn.disabled = false;\n            updateButtonProgress('idle');\n        }\n    });\n    \n    // Auto-resize GLOSA textarea och visa spara-knapp n√§r anv√§ndaren redigerar\n    const autoResizeGlosa = () => {\n        if (glosaPreview) {\n            glosaPreview.style.height = 'auto';\n            glosaPreview.style.height = glosaPreview.scrollHeight + 'px';\n        }\n    };\n    \n    glosaPreview?.addEventListener('input', () => {\n        autoResizeGlosa();\n        if (glosaPreview.value !== currentOriginalGlosa) {\n            saveGlosaBtn?.classList.remove('hidden');\n        } else {\n            saveGlosaBtn?.classList.add('hidden');\n        }\n    });\n    \n    glosaPreview?.addEventListener('focus', autoResizeGlosa);\n    \n    // Initial resize f√∂r n√§r GLOSA visas f√∂rsta g√•ngen\n    const glosaObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\n                const target = mutation.target as HTMLElement;\n                if (!target.classList.contains('hidden') && glosaPreview) {\n                    setTimeout(autoResizeGlosa, 50);\n                }\n            }\n        });\n    });\n    \n    if (glosaPane) {\n        glosaObserver.observe(glosaPane, { attributes: true });\n    }\n    \n    // Spara korrigering till aiLearningSystem\n    saveGlosaBtn?.addEventListener('click', async () => {\n        const correctedGlosa = glosaPreview?.value?.trim();\n        if (!correctedGlosa || !currentOriginalText) {\n            showMessage('Ingen korrigering att spara', 'error');\n            return;\n        }\n        \n        try {\n            // Importera aiLearningSystem dynamiskt\n            const { aiLearningSystem } = await import('../sts-glossing/aiLearningSystem');\n            \n            // Spara korrigeringen med h√∂g prioritet (1.0)\n            aiLearningSystem.recordLearning(\n                currentOriginalText,\n                correctedGlosa.replace(/\\n/g, ' '), // Ta bort radbrytningar f√∂r lagring\n                'user-correction',\n                1.0\n            );\n            \n            // Spara till feedbackCollector f√∂r Google Forms\n            const { feedbackCollector } = await import('../feedback/feedbackCollector');\n            feedbackCollector.addGlosaCorrection(\n                currentOriginalText,\n                currentOriginalGlosa.replace(/\\n/g, ' '), // AI:s ursprungliga GLOSA\n                correctedGlosa.replace(/\\n/g, ' ') // Anv√§ndarens korrigerade GLOSA\n            );\n            \n            // Uppdatera status\n            currentOriginalGlosa = correctedGlosa;\n            saveGlosaBtn.classList.add('hidden');\n            \n            // Uppdatera videorna med korrigerad GLOSA\n            await updateGlosaVideos(correctedGlosa.replace(/\\n/g, ' '));\n            \n            showMessage('Korrigering sparad! Systemet l√§r sig.', 'success');\n        } catch (error) {\n            console.error('Fel vid sparande av korrigering:', error);\n            showMessage('Kunde inte spara korrigering', 'error');\n        }\n    });\n\n    // GLOSA Modal Close\n    const glosaFeedbackModal = document.getElementById('glosaFeedbackModal') as HTMLElement;\n    const glosaFeedbackClose = document.getElementById('glosaFeedbackClose') as HTMLButtonElement;\n    const glosaFeedbackBackdrop = document.getElementById('glosaFeedbackBackdrop') as HTMLElement;\n    \n    const closeGlosaModal = () => {\n        glosaFeedbackModal?.classList.add('hidden');\n    };\n    \n    glosaFeedbackClose?.addEventListener('click', closeGlosaModal);\n    glosaFeedbackBackdrop?.addEventListener('click', closeGlosaModal);\n    \n    // GLOSA Copy Feedback\n    const glosaFeedbackCopy = document.getElementById('glosaFeedbackCopy') as HTMLButtonElement;\n    glosaFeedbackCopy?.addEventListener('click', () => {\n        const swedish = document.getElementById('glosaFeedbackSwedish')?.textContent || '';\n        const aiGlosa = document.getElementById('glosaFeedbackAI')?.textContent || '';\n        const userGlosa = (document.getElementById('glosaFeedbackUser') as HTMLTextAreaElement)?.value || '';\n        \n        const feedbackText = `GLOSA FEEDBACK:\\nSvenska: ${swedish}\\nAI GLOSA: ${aiGlosa}\\nMin GLOSA: ${userGlosa}`;\n        navigator.clipboard.writeText(feedbackText).then(() => {\n            showMessage('Feedback kopierad!', 'success');\n        }).catch(() => {\n            showMessage('Kunde inte kopiera', 'error');\n        });\n    });\n\n    setupTools();\n}\n\nconst tools = [\n    { id: 'thumb-up', icon: `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333V17a1 1 0 001 1h6.364a1 1 0 00.942-.673l1.858-6.47A1.5 1.5 0 0014.28 8H11V5.167a2.5 2.5 0 00-5 0v5.166z\" /></svg>`, tooltip: 'Ge tumme upp', color: 'var(--green-vote)' },\n    { id: 'thumb-down', icon: `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667V3a1 1 0 00-1-1H6.636a1 1 0 00-.942.673l-1.858 6.47A1.5 1.5 0 005.72 12H9v4.833a2.5 2.5 0 005 0V9.667z\" /></svg>`, tooltip: 'Ge tumme ner', color: 'var(--red-vote)' },\n    { id: 'change', icon: `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 4 0 000-2.828z\" /><path fill-rule=\"evenodd\" d=\"M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z\" clip-rule=\"evenodd\" /></svg>`, tooltip: 'Byt, f√∂resl√•, rapportera', color: 'var(--purple-multiple)' },\n];\n\nfunction setupTools() {\n    const toolsContainer = document.getElementById('tools-container') as HTMLElement;\n    const videoGrid = document.getElementById('videoGrid') as HTMLElement;\n    const alphabetGrid = document.getElementById('alphabetGrid') as HTMLElement;\n\n    if (!toolsContainer) return;\n    toolsContainer.innerHTML = '';\n    const fragment = document.createDocumentFragment();\n\n    tools.forEach(tool => {\n        const button = document.createElement('button');\n        button.className = 'tool-btn';\n        button.dataset.tool = tool.id;\n        button.setAttribute('aria-label', tool.tooltip);\n        button.dataset.tooltipText = tool.tooltip;\n        button.innerHTML = tool.icon;\n        (button.firstElementChild as HTMLElement).style.color = tool.color;\n        button.disabled = true;\n\n        button.addEventListener('click', () => {\n            const currentTool = videoGrid.dataset.activeTool;\n            const newTool = currentTool === tool.id ? 'none' : tool.id;\n            \n            appState.selection = [];\n            appState.combinationSelection = [];\n            updateSelectionUI();\n            \n            videoGrid.dataset.activeTool = newTool;\n            if (alphabetGrid) alphabetGrid.dataset.activeTool = newTool;\n            \n            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));\n            if (newTool !== 'none') {\n                button.classList.add('active');\n            }\n        });\n        fragment.appendChild(button);\n    });\n    toolsContainer.appendChild(fragment);\n    \n    const multiSelectToolContainer = document.getElementById('multiSelectToolContainer') as HTMLElement;\n    if (multiSelectToolContainer && !document.getElementById('multiSelectToolBtn')) {\n        const selectBtn = document.createElement('button');\n        selectBtn.id = 'multiSelectToolBtn';\n        selectBtn.className = 'tool-btn';\n        selectBtn.dataset.tool = 'select';\n        selectBtn.dataset.tooltipText = 'V√§lj flera tecken f√∂r att ge gemensam feedback eller kombinera.';\n        selectBtn.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6\" viewBox=\"0 0 24 24\" fill=\"currentColor\" style=\"color: var(--selection-yellow);\"><rect x=\"3\" y=\"3\" width=\"7\" height=\"7\" fill=\"var(--selection-yellow)\" opacity=\"0.8\"/><rect x=\"14\" y=\"3\" width=\"7\" height=\"7\" fill=\"var(--selection-yellow)\" opacity=\"0.8\"/><rect x=\"3\" y=\"14\" width=\"7\" height=\"7\" fill=\"var(--selection-yellow)\" opacity=\"0.8\"/><rect x=\"14\" y=\"14\" width=\"7\" height=\"7\" fill=\"var(--selection-yellow)\" opacity=\"0.8\"/></svg>`;\n        selectBtn.disabled = true;\n        selectBtn.addEventListener('click', () => {\n            const currentTool = videoGrid.dataset.activeTool;\n            const newTool = currentTool === 'select' ? 'none' : 'select';\n            videoGrid.dataset.activeTool = newTool;\n            if (alphabetGrid) alphabetGrid.dataset.activeTool = newTool;\n            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));\n            if (newTool !== 'none') {\n                selectBtn.classList.add('active');\n            }\n        });\n        multiSelectToolContainer.appendChild(selectBtn);\n    }\n    \n    // Create unified action button for combination and advanced actions\n    const selectionActionContainer = document.getElementById('selectionActionContainer') as HTMLElement;\n    const combinationActionContainer = document.getElementById('combinationActionContainer') as HTMLElement;\n    \n    if (combinationActionContainer && !document.getElementById('actionMenuBtn')) {\n        const actionMenuBtn = document.createElement('button');\n        actionMenuBtn.id = 'actionMenuBtn';\n        actionMenuBtn.className = 'btn btn-primary btn-sm p-2';\n        actionMenuBtn.dataset.tooltipText = '√Ötg√§rder: Kombinera eller ge avancerad feedback';\n        actionMenuBtn.innerHTML = `<svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z\"></path></svg>`;\n        actionMenuBtn.addEventListener('click', (e) => {\n            const menuDiv = document.getElementById('actionMenu');\n            if (menuDiv) {\n                menuDiv.classList.toggle('hidden');\n            }\n        });\n        combinationActionContainer.appendChild(actionMenuBtn);\n        \n        // Create dropdown menu\n        const menuDiv = document.createElement('div');\n        menuDiv.id = 'actionMenu';\n        menuDiv.className = 'hidden absolute bg-gray-800 border border-gray-700 rounded shadow-lg mt-1 min-w-48 z-50';\n        menuDiv.style.bottom = '100%';\n        menuDiv.style.right = '0';\n        menuDiv.style.marginBottom = '0.5rem';\n        \n        // Kombinera option\n        const combineOption = document.createElement('button');\n        combineOption.className = 'w-full text-left px-4 py-2 hover:bg-gray-700 border-b border-gray-700 flex items-center gap-2 transition-colors';\n        combineOption.innerHTML = `<svg class=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17 14v6m-3-3h6M6 10h2a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v2a2 2 0 002 2zM16 10h2a2 2 0 002-2V6a2 2 0 00-2-2h-2a2 2 0 00-2 2v2a2 2 0 002 2zM6 20h2a2 2 0 002-2v-2a2 2 0 00-2-2H6a2 2 0 00-2 2v2a2 2 0 002 2z\"></path></svg> <span>Kombinera Tecken</span>`;\n        combineOption.addEventListener('click', () => {\n            appState.combinationSelection = appState.selection.map(cardId => {\n                const cardData = appState.cardIdDataMap.get(cardId);\n                const sign = cardData?.phraseTokens?.[0]?.signs?.[0];\n                return { cardId, sign: sign! };\n            }).filter(item => item.sign);\n            openCreateCombinationModal(actionMenuBtn);\n            menuDiv.classList.add('hidden');\n        });\n        menuDiv.appendChild(combineOption);\n        \n        // √Ñndra option\n        const changeOption = document.createElement('button');\n        changeOption.className = 'w-full text-left px-4 py-2 hover:bg-gray-700 flex items-center gap-2 transition-colors';\n        changeOption.innerHTML = `<svg class=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h5M20 20v-5h-5M4 9a9 9 0 0114.65-5.22M20 15a9 9 0 01-14.65 5.22\"></path></svg> <span>√Ñndra tecken</span>`;\n        changeOption.addEventListener('click', () => {\n            openChangeGroupSignsModal(actionMenuBtn);\n            menuDiv.classList.add('hidden');\n        });\n        menuDiv.appendChild(changeOption);\n        \n        combinationActionContainer.style.position = 'relative';\n        combinationActionContainer.appendChild(menuDiv);\n        \n        // Close menu when clicking outside\n        document.addEventListener('click', (e) => {\n            if (!combinationActionContainer.contains(e.target as Node)) {\n                menuDiv.classList.add('hidden');\n            }\n        });\n    }\n}\n","path":null,"size_bytes":26208,"size_tokens":null},"replit.md":{"content":"# STSHELPER\n\n## Overview\nSTSHELPER is a Swedish Sign Language (Svenskt teckenspr√•k) helper application. It provides tools for translating Swedish text to sign language glosses, searching for signs, and viewing sign language videos.\n\n## Tech Stack\n- **Frontend**: React 18 + TypeScript\n- **Build Tool**: Vite 7\n- **Styling**: Styled Components + CSS + Tailwind (via CDN)\n- **Runtime**: Node.js 20\n\n## Project Structure\n```\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ components/     # React components (GlosaSearch, VideoGrid, etc.)\n‚îÇ   ‚îú‚îÄ‚îÄ hooks/          # Custom React hooks (useAI, useLexicon, etc.)\n‚îÇ   ‚îú‚îÄ‚îÄ modules/        # Feature modules (search, glossing, etc.)\n‚îÇ   ‚îú‚îÄ‚îÄ services/       # Service layer (lexicon, video, notifications)\n‚îÇ   ‚îú‚îÄ‚îÄ styles/         # CSS stylesheets\n‚îÇ   ‚îî‚îÄ‚îÄ App.tsx         # Main application component\n‚îú‚îÄ‚îÄ public/\n‚îÇ   ‚îî‚îÄ‚îÄ data/           # Lexicon data and user data files\n‚îú‚îÄ‚îÄ data/               # Application data (glossing rules, filters)\n‚îî‚îÄ‚îÄ index.html          # Entry point\n```\n\n## Key Features\n- Text-to-gloss translation for Swedish Sign Language\n- Sign search and video playback\n- Offline lexicon support with multiple data files\n- AI-powered features (requires API keys)\n- Speech recognition support\n\n## Development\n```bash\nnpm run dev       # Start development server on port 5000\nnpm run build     # Build for production\nnpm run preview   # Preview production build\n```\n\n## API Keys (Optional)\nThe app supports various AI providers through environment variables:\n- `ANTHROPIC_API_KEY`\n- `GOOGLE_GENAI_API_KEY`\n- `OPENAI_API_KEY`\n- `GROQ_API_KEY`\n- `MISTRAL_API_KEY`\n\n## Deployment\nConfigured for Replit autoscale deployment:\n- Build: `npm run build`\n- Run: `npm run preview`\n","path":null,"size_bytes":1776,"size_tokens":null},"README.md":{"content":"# STSHELPER-5.0\nHj√§lpverktyg f√∂r STS-system, version 5.0, med st√∂d f√∂r TypeScript och Node.js.\n","path":null,"size_bytes":99,"size_tokens":null},"src/hooks/useSpeechRecognition.ts":{"content":"\nimport { appState } from '../state';\nimport { showMessage, originalTextDisplay, voiceInputBtn } from '../ui';\nimport { initializePlaceholder } from '../modules/ui/textDisplay';\n\nexport function initializeSpeechRecognition() {\n    const SpeechRecognitionApi = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (SpeechRecognitionApi) {\n        appState.recognition = new SpeechRecognitionApi();\n        appState.recognition.continuous = true;\n        appState.recognition.interimResults = true;\n        appState.recognition.lang = 'sv-SE';\n\n        appState.recognition.onresult = (event: SpeechRecognitionEvent) => {\n            let interimTranscript = '';\n            let finalTranscript = '';\n            for (let i = event.resultIndex; i < event.results.length; ++i) {\n                if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;\n                else interimTranscript += event.results[i][0].transcript;\n            }\n            originalTextDisplay.textContent = finalTranscript + interimTranscript;\n            if (finalTranscript) originalTextDisplay.classList.add('text-area-editable');\n\n            // VIKTIGT: Tvinga fram en 'input'-h√§ndelse s√• att S√∂k-knappen (convertBtn) aktiveras\n            originalTextDisplay.dispatchEvent(new Event('input', { bubbles: true }));\n        };\n\n        appState.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n            console.error('Speech recognition error:', event.error);\n            let userMessage = `R√∂stigenk√§nning misslyckades: ${event.error}`;\n            if (event.error === 'not-allowed') {\n                userMessage = 'Du m√•ste till√•ta mikrofon√•tkomst i din webbl√§sare f√∂r att anv√§nda r√∂stinmatning.';\n            } else if (event.error === 'no-speech') {\n                userMessage = 'Ingen r√∂st uppt√§cktes. F√∂rs√∂k igen.';\n            }\n            showMessage(userMessage, 'error');\n            appState.isListening = false;\n            if (voiceInputBtn) voiceInputBtn.classList.remove('is-listening');\n        };\n\n        appState.recognition.onend = () => {\n            if (appState.isListening) {\n                try { appState.recognition?.start(); } catch (e) { console.error(\"Could not restart recognition:\", e); }\n            }\n        };\n\n        if (voiceInputBtn) {\n            voiceInputBtn.addEventListener('click', () => {\n                if (!appState.recognition) {\n                    showMessage('R√∂stigenk√§nning st√∂ds inte av din webbl√§sare.', 'error');\n                    return;\n                }\n                if (appState.isListening) {\n                    appState.isListening = false;\n                    appState.recognition.stop();\n                    voiceInputBtn.classList.remove('is-listening');\n                } else {\n                    appState.isListening = true;\n                    if (originalTextDisplay.textContent === originalTextDisplay.dataset.placeholder) {\n                        originalTextDisplay.textContent = '';\n                        originalTextDisplay.classList.add('text-area-editable');\n                    }\n                    appState.recognition.start();\n                    voiceInputBtn.classList.add('is-listening');\n                }\n            });\n        }\n\n    } else {\n        if (voiceInputBtn) {\n            voiceInputBtn.addEventListener('click', () => {\n                showMessage('R√∂stigenk√§nning st√∂ds inte av din webbl√§sare.', 'error');\n            });\n        }\n    }\n}\n","path":null,"size_bytes":3515,"size_tokens":null},"src/services/quotaTracker.ts":{"content":"// Tracks API usage quota for all 5 AI models\ntype ApiModel = 'anthropic' | 'openai' | 'groq' | 'mistral' | 'google';\n\ninterface QuotaConfig {\n    [key in ApiModel]: number;\n}\n\nconst DAILY_QUOTAS: QuotaConfig = {\n    anthropic: 1000,    // Claude - high daily limit\n    openai: 1000,       // GPT - high daily limit\n    groq: 2000,         // Groq - very high (fast)\n    mistral: 1000,      // Mistral - high limit\n    google: 1500        // Google GenAI - high limit\n};\n\nexport class QuotaTracker {\n    private today = new Date().toISOString().slice(0, 10);\n    \n    static getInstance() {\n        return new QuotaTracker();\n    }\n\n    private getKey(model: ApiModel): string {\n        return `api_quota_${model}_${this.today}`;\n    }\n\n    incrementUsage(model: ApiModel) {\n        const key = this.getKey(model);\n        const current = +(localStorage.getItem(key) || '0');\n        localStorage.setItem(key, (current + 1).toString());\n        this.updateUI();\n    }\n\n    getUsagePercentage(model: ApiModel): number {\n        const key = this.getKey(model);\n        const used = +(localStorage.getItem(key) || '0');\n        const quota = DAILY_QUOTAS[model];\n        // Returnerar AVAILABLE procent (remaining/quota)\n        const available = Math.max(0, quota - used);\n        return Math.round(100 * available / quota);\n    }\n\n    getAveragePercentage(): number {\n        const models: ApiModel[] = ['anthropic', 'openai', 'groq', 'mistral', 'google'];\n        const total = models.reduce((sum, model) => sum + this.getUsagePercentage(model), 0);\n        return Math.round(total / models.length);\n    }\n\n    updateUI() {\n        const el = document.getElementById('hf-api-quota');\n        if (!el) return;\n\n        const avgPct = this.getAveragePercentage();\n        el.textContent = avgPct + '%';\n        \n        // Color coding: Red < 25%, Yellow 25-50%, Green > 50%\n        if (avgPct > 50) {\n            el.style.background = '#d1fae5';\n            el.style.color = '#065f46';\n        } else if (avgPct > 25) {\n            el.style.background = '#fef9c3';\n            el.style.color = '#92400e';\n        } else {\n            el.style.background = '#fee2e2';\n            el.style.color = '#b91c1c';\n        }\n    }\n\n    getDetailedStats(): { [key in ApiModel]: number } {\n        return {\n            anthropic: this.getUsagePercentage('anthropic'),\n            openai: this.getUsagePercentage('openai'),\n            groq: this.getUsagePercentage('groq'),\n            mistral: this.getUsagePercentage('mistral'),\n            google: this.getUsagePercentage('google')\n        };\n    }\n\n    getTooltipText(): string {\n        const stats = this.getDetailedStats();\n        return `Claude: ${stats.anthropic}% | OpenAI: ${stats.openai}% | Groq: ${stats.groq}% | Mistral: ${stats.mistral}% | Google: ${stats.google}%`;\n    }\n}\n\nexport const quotaTracker = QuotaTracker.getInstance();\n","path":null,"size_bytes":2887,"size_tokens":null},"src/styles/core/grids.css":{"content":"\n/* --- VIDEO GRID LAYOUT --- */\n#videoGrid {\n    display: grid;\n    grid-template-columns: repeat(auto-fill, minmax(170px, 1fr)); /* Adjusted min size */\n    gap: var(--space-lg); /* Increased gap */\n    align-items: stretch;\n}\n\n.video-grid-alphabet {\n    display: grid;\n    gap: var(--space-md);\n    grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));\n}\n","path":null,"size_bytes":366,"size_tokens":null},"src/types.ts":{"content":"import { GoogleGenAI, Chat } from '@google/genai';\n\n// --- GLOBAL SPEECH RECOGNITION TYPES ---\ndeclare global {\n    interface SpeechRecognitionAlternative {\n        readonly transcript: string;\n        readonly confidence: number;\n    }\n\n    interface SpeechRecognitionResult {\n        readonly isFinal: boolean;\n        readonly length: number;\n        item(index: number): SpeechRecognitionAlternative;\n        [index: number]: SpeechRecognitionAlternative;\n    }\n\n    interface SpeechRecognitionResultList {\n        readonly length: number;\n        item(index: number): SpeechRecognitionResult;\n        [index: number]: SpeechRecognitionResult;\n    }\n\n    interface SpeechRecognitionEvent extends Event {\n        readonly resultIndex: number;\n        readonly results: SpeechRecognitionResultList;\n    }\n\n    interface SpeechRecognitionErrorEvent extends Event {\n        readonly error: string;\n    }\n\n    interface SpeechRecognition extends EventTarget {\n        continuous: boolean;\n        interimResults: boolean;\n        lang: string;\n        onresult: (event: SpeechRecognitionEvent) => void;\n        onerror: (event: SpeechRecognitionErrorEvent) => void;\n        onend: () => void;\n        start(): void;\n        stop(): void;\n    }\n\n    var SpeechRecognition: {\n        prototype: SpeechRecognition;\n        new (): SpeechRecognition;\n    };\n\n    var webkitSpeechRecognition: {\n        prototype: SpeechRecognition;\n        new (): SpeechRecognition;\n    };\n\n    interface Window {\n        showFeedbackVideo: (cardId: string, signId: string) => void;\n        SpeechRecognition: typeof SpeechRecognition;\n        webkitSpeechRecognition: typeof webkitSpeechRecognition;\n    }\n}\n\n\n// --- CORE TYPES ---\nexport type Sign = { id: string; word: string };\n\nexport type LexiconMetadata = {\n    videoUrlPatterns: {\n        ord: string;\n        example: string;\n        related: string;\n    };\n    korpusUrlPattern: string;\n    ordforklaringUrlPattern: string;\n    nycklar: { [key: string]: string };\n};\n\nexport type Example = {\n    sentence: string;\n    phraseNumber: number;\n    id: string; // Original ID of the sign entry\n    word: string; // Original word of the sign entry\n};\n\nexport type RelatedSignInfo = {\n    sentence: string;\n    relatedId: string;\n    relatedWord: string;\n    phraseNumber: number;\n    originalId: string; // ID of the sign entry this is related to\n    originalWord: string; // Word of the sign entry this is related to\n};\n\nexport type WordMapEntry = {\n    original: string;\n    base: string;\n    isWord: boolean;\n    pos: string;\n    signs: Sign[] | null;\n    isCompound?: boolean;\n    isHandled?: boolean;\n    isSpelledOut?: boolean;\n    rationale?: string;\n    examples?: Example[];\n    related?: RelatedSignInfo[];\n    gloss?: string;\n    isEnriched?: boolean;\n    isGenuine?: boolean;\n    genuineTeckenId?: string;\n};\n\n// --- FEEDBACK & LEARNING TYPES ---\nexport type FeedbackEntry = {\n    feedback: string;\n    originalWords: string;\n    groupId?: string;\n    suggestedSigns?: Sign[];\n    questionKey?: string;\n};\n\nexport type PositiveFeedbackEntry = {\n    sign: Sign;\n    originalWords: string;\n    count: number;\n};\n\nexport type NegativeFeedbackEntry = {\n    sign: Sign;\n    originalWords: string;\n    reason?: string;\n};\n\n// --- LEARNING FILE TYPES ---\nexport type LearningFileNewWord = {\n    lookupKey: string;\n    signs: Sign[];\n    isCompound?: boolean;\n};\n\nexport type LearningFileModification = {\n    signs: Sign[];\n};\n\nexport type LearningFileLearnedPreferences = { [lookupKey: string]: { [signId: string]: number } };\n\nexport type LearningFileFeedbackReport = {\n    signFeedback: ({ cardId: string } & FeedbackEntry)[];\n    sentenceFeedback: { sentence: string, comment: string }[];\n    negativeFeedback: ({ cardId: string, signId: string } & NegativeFeedbackEntry)[];\n    positiveFeedback: ({ cardId: string, signId: string } & PositiveFeedbackEntry)[];\n};\n\nexport type HomonymResolution = {\n    pos: string;\n    sign: Sign;\n};\n\nexport type LearningData = {\n    schemaVersion: string;\n    lastUpdated: string;\n    description: string;\n    newWords: LearningFileNewWord[];\n    modifications: { [lookupKey: string]: LearningFileModification };\n    learnedPreferences: LearningFileLearnedPreferences;\n    feedbackReports: LearningFileFeedbackReport;\n    homonymResolutions: { [word: string]: { pos: string, sign: Sign }[] };\n    assistantInstructions?: { id: string, instruction: string }[];\n};\n\n// --- CONTEXT & STATE TYPES ---\nexport type SuggestionContext = {\n    phraseTokens: WordMapEntry[];\n    lookupKey: string;\n    fullOriginalPhrase: string;\n};\n\nexport type VideoSuggestion = {\n    blob: Blob;\n    context: SuggestionContext;\n    blobUrl: string;\n};\n\nexport type ModalContexts = {\n    signDetailsCardId: string | null;\n    signDetailsPhrase: string | null;\n    signDetailsContext: WordMapEntry | null;\n    changeReason: {\n        phraseTokens: WordMapEntry[];\n        lookupKey: string;\n        newSign: Sign;\n        originalSigns: Sign[];\n        allNewSigns?: Sign[];\n        grammarCardIndex?: number; // Index of the card in the grammar grid\n        cardId?: string; // ID of the card being changed (to fix object Object bug)\n    } | null;\n    thumbDownReason: {\n        phraseTokens?: WordMapEntry[];\n        lookupKey?: string;\n        sign?: Sign;\n        cardId?: string;\n        fullOriginalPhrase?: string;\n        isSpelledOut?: boolean;\n        cardContainer?: HTMLElement;\n        isGroupAction?: boolean;\n    } | null;\n    goodChoiceReason: {\n        phraseTokens?: WordMapEntry[];\n        lookupKey?: string;\n        sign?: Sign;\n        cardId?: string;\n        fullOriginalPhrase?: string;\n        isSpelledOut?: boolean;\n        cardContainer?: HTMLElement;\n        isGroupAction?: boolean;\n    } | null;\n    sentenceFeedback: {\n        sentence: WordMapEntry[];\n    } | null;\n    suggestion: SuggestionContext | null;\n    sendSuggestion: { blob: Blob; context: SuggestionContext } | null;\n    improveSign: {\n        phraseTokens: WordMapEntry[];\n        lookupKey: string;\n        fullOriginalPhrase: string;\n        cardId: string;\n        isSpelledOut: boolean;\n        cardContainer: HTMLElement;\n        grammarCardIndex?: number; // Index of the card in the grammar grid\n    } | null;\n};\n\nexport type MediaState = {\n    mediaRecorder: MediaRecorder | null;\n    recordedBlobs: Blob[];\n    timerInterval: number | null;\n    tempVideoBlob: Blob | null;\n    mediaStream: MediaStream | null;\n};\n\nexport type ChatHistoryMessage = {\n    role: 'user' | 'model';\n    text: string;\n    file?: {\n        name: string;\n        type: string;\n        base64: string;\n    } | null;\n};\n\nexport type AppState = {\n    ai: GoogleGenAI | null;\n    isClickableMode: boolean;\n    wordMap: WordMapEntry[];\n    sentences: WordMapEntry[][];\n    currentSentenceIndex: number;\n    currentGrammarSentenceIndex: number; // New for grammar navigation\n    aiTranslatedSentences: Map<number, WordMapEntry[]>; // New cache for AI translations\n    isShowingAllSentences: boolean;\n    isPlayingAll: boolean;\n    isAccessibilityModeActive: boolean;\n    isListening: boolean;\n    recognition: SpeechRecognition | null;\n    activeModalOpener: HTMLElement | null;\n    latestReportContent: object | null;\n    latestFeedbackJson: string;\n    latestReportSummary: string | null; // NEW: Stores the text content of the report\n    modalContexts: ModalContexts;\n    mediaState: MediaState;\n    videoSuggestions: VideoSuggestion[];\n    videoObserver: IntersectionObserver | null;\n    alphabetObserver: IntersectionObserver | null;\n    combinationSelection: { cardId: string, sign: Sign }[];\n    selection: string[];\n    multiSelectMode: boolean;\n    selectedCardIds: Set<string>;\n    chat: Chat | null;\n    chatHistory: ChatHistoryMessage[];\n    chatFile: { file: File; base64: string; mimeType: string } | null;\n    cardIdDataMap: Map<string, { phraseTokens: WordMapEntry[], fullOriginalPhrase: string }>;\n    latestAnalysisResult: { summary: string; jsonReport: string } | null;\n    linguisticQuestions: any[];\n    shownQuestionKeys: Set<string>;\n    pendingLinguisticQuestion: any | null;\n    abortController: AbortController | null;\n    lexiconMetadata: LexiconMetadata | null;\n    loadedLexiconParts: Set<number>;\n    onlineLearningData: LearningData | null;\n    localLexiconReady: boolean;\n    fullLexiconLoaded: boolean;\n    localLexiconProgress: number; // 0-100\n    onlineLexiconProgress: number; // 0-100\n    changeSignMode: 'main' | 'grammar'; // New: To track context of change sign modal\n    aiEnabled: boolean; // Toggle f√∂r att aktivera/deaktivera AI-funktioner\n    usePuter: boolean; // Puter.js integration flag\n    aiReady: boolean; // AI system initialization status\n    glosaEnabled: boolean; // BETA: GLOSA feature toggle\n};","path":null,"size_bytes":8780,"size_tokens":null},"minne/Svenska/GlosaSearch.tsx":{"content":"// Kopia av GlosaSearch.tsx fr√•n src/components\n// Hanterar svenska input, s√∂kord och s√∂kfunktion\n\nimport React, { useState } from 'react';\nimport Loader from '../../src/components/Loader';\n\nconst GlosaSearch = () => {\n  const [input, setInput] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [result, setResult] = useState(null);\n  const [error, setError] = useState('');\n  const [glosaResult, setGlosaResult] = useState('');\n  const [debugInput, setDebugInput] = useState('');\n\n  const handleGlosa = async () => {\n    setIsLoading(true);\n    setGlosaResult('');\n    setError('');\n    setDebugInput(input);\n    try {\n      const { offlineEngine } = await import('../../src/modules/sts-glossing/offlineGlosaEngine');\n      if (offlineEngine.initializeLists) {\n        await offlineEngine.initializeLists();\n      }\n      const glossed = offlineEngine.translateToGlosaOffline(input);\n      setGlosaResult(glossed);\n    } catch (e) {\n      setError('Fel vid glossning.');\n    }\n    setIsLoading(false);\n  };\n\n  // S√∂kfunktion kan anpassas eller l√§mnas tom om lexikon ej beh√∂vs\n  const handleSearch = async () => {\n    setIsLoading(true);\n    setError('');\n    setResult(null);\n    // H√§r kan du l√§gga till s√∂klogik om du vill\n    setIsLoading(false);\n  };\n\n  return (\n    <div style={{ maxWidth: 400, margin: '2em auto', textAlign: 'center' }}>\n      <input\n        type=\"text\"\n        value={input}\n        onChange={e => setInput(e.target.value)}\n        placeholder=\"Skriv tecken eller synonym...\"\n        style={{ padding: '0.5em', width: '70%' }}\n      />\n      <button onClick={handleSearch} style={{ marginLeft: 8, padding: '0.5em 1em' }}>S√∂k</button>\n      <button onClick={handleGlosa} style={{ marginLeft: 8, padding: '0.5em 1em', background: '#e0e0ff' }}>Glosa</button>\n      <div style={{ margin: '2em 0' }}>\n        {isLoading && <Loader />}\n        {result && !isLoading && (\n          <div style={{ marginTop: 16 }}>\n            <h3>{result.word}</h3>\n            {result.id && (\n              <div style={{ color: '#666', fontSize: '0.95em' }}>\n                ID: {result.id}\n              </div>\n            )}\n          </div>\n        )}\n        {debugInput && !isLoading && (\n          <div style={{ marginTop: 8, color: '#888', fontSize: '0.9em' }}>\n            <div><b>Debug input till glossning:</b> \"{debugInput}\"</div>\n          </div>\n        )}\n        {!isLoading && (\n          <div style={{ marginTop: 16, color: glosaResult ? '#2a2' : '#a22', fontWeight: 'bold' }}>\n            <div>Glossning:</div>\n            <div>{glosaResult ? glosaResult : 'Ingen glossning kunde genereras.'}</div>\n          </div>\n        )}\n        {error && !isLoading && <div style={{ color: 'red', marginTop: 16 }}>{error}</div>}\n      </div>\n    </div>\n  );\n};\n\nexport default GlosaSearch;\n","path":null,"size_bytes":2837,"size_tokens":null},"src/styles/glosa-input.css":{"content":"/* === DUAL INPUT CONTAINER === */\n.dual-input-container {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-md);\n    width: 100%;\n}\n\n@media (min-width: 640px) {\n    .dual-input-container {\n        flex-direction: row;\n        gap: var(--space-lg);\n    }\n}\n\n/* === INPUT PANES === */\n.input-pane {\n    flex: 1;\n    min-width: 0;\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-xs);\n}\n\n.input-pane-label {\n    font-size: var(--text-xs);\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n    color: var(--text-secondary);\n    padding-left: var(--space-xs);\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n}\n\n.input-pane-swedish .input-pane-label {\n    color: var(--text-secondary);\n}\n\n.input-pane-glosa .input-pane-label {\n    color: var(--accent-cyan);\n}\n\n/* === GLOSA PREVIEW WRAPPER === */\n.glosa-preview-wrapper {\n    background-color: var(--bg-dark);\n    border: 2px solid var(--accent-cyan);\n    border-radius: var(--border-radius-md);\n    padding: var(--space-md);\n    min-height: clamp(100px, 15vh, 180px);\n    position: relative;\n    overflow: visible;\n    height: auto;\n    display: flex;\n    flex-direction: column;\n}\n\n.glosa-preview-wrapper::before {\n    content: '';\n    position: absolute;\n    inset: 0;\n    background: linear-gradient(135deg, rgba(6, 182, 212, 0.05) 0%, transparent 50%);\n    pointer-events: none;\n}\n\n.glosa-preview-text {\n    font-size: var(--text-base);\n    font-weight: 600;\n    text-transform: uppercase;\n    letter-spacing: 0.02em;\n    color: var(--accent-cyan);\n    line-height: 1.8;\n    word-wrap: break-word;\n    position: relative;\n    z-index: 1;\n    width: 100%;\n    min-height: clamp(100px, 15vh, 180px);\n    background: transparent;\n    border: none;\n    resize: none;\n    outline: none;\n    font-family: inherit;\n    height: auto;\n    overflow-y: hidden;\n}\n\n.glosa-preview-text::placeholder {\n    color: var(--text-tertiary);\n    font-style: italic;\n    text-transform: none;\n    font-weight: 400;\n}\n\n/* Spara-knapp f√∂r GLOSA-korrigeringar */\n.save-glosa-btn {\n    position: absolute;\n    bottom: 8px;\n    right: 8px;\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    padding: 6px 12px;\n    background: var(--accent-cyan);\n    color: var(--bg-dark);\n    border: none;\n    border-radius: 6px;\n    font-size: var(--text-xs);\n    font-weight: 600;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    z-index: 2;\n}\n\n.save-glosa-btn:hover {\n    background: #22d3ee;\n    transform: scale(1.05);\n}\n\n.save-glosa-btn.hidden {\n    display: none;\n}\n\n/* === GLOSA STATUS INDICATOR === */\n.glosa-status {\n    display: inline-flex;\n    align-items: center;\n    gap: 6px;\n    font-size: var(--text-xs);\n    font-weight: 500;\n    padding: 2px 8px;\n    border-radius: 12px;\n    text-transform: none;\n    letter-spacing: normal;\n}\n\n.glosa-status.status-offline {\n    background: rgba(34, 197, 94, 0.15);\n    color: #22c55e;\n}\n\n.glosa-status.status-offline::before {\n    content: '';\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: #22c55e;\n}\n\n.glosa-status.status-ai {\n    background: rgba(245, 158, 11, 0.15);\n    color: #f59e0b;\n}\n\n.glosa-status.status-ai::before {\n    content: '';\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: #f59e0b;\n}\n\n.glosa-status.status-loading {\n    background: rgba(99, 102, 241, 0.15);\n    color: #818cf8;\n}\n\n.glosa-status.status-loading::before {\n    content: '';\n    width: 6px;\n    height: 6px;\n    border-radius: 50%;\n    background: #818cf8;\n    animation: pulse-dot 1s infinite;\n}\n\n@keyframes pulse-dot {\n    0%, 100% { opacity: 1; transform: scale(1); }\n    50% { opacity: 0.5; transform: scale(0.8); }\n}\n\n/* === RESPONSIVE ADJUSTMENTS === */\n@media (max-width: 639px) {\n    .input-pane-glosa {\n        order: -1;\n    }\n    \n    .glosa-preview-wrapper {\n        min-height: 80px;\n    }\n}\n\n@media (orientation: landscape) and (max-height: 500px) {\n    .glosa-preview-wrapper {\n        min-height: 70px;\n        padding: var(--space-sm);\n    }\n}\n\n/* === ANIMATION FOR GLOSA PANE REVEAL === */\n.input-pane-glosa {\n    transition: opacity 0.3s ease, transform 0.3s ease;\n}\n\n.input-pane-glosa.hidden {\n    display: none;\n}\n\n.input-pane-glosa:not(.hidden) {\n    animation: slideIn 0.3s ease forwards;\n}\n\n@keyframes slideIn {\n    from {\n        opacity: 0;\n        transform: translateX(10px);\n    }\n    to {\n        opacity: 1;\n        transform: translateX(0);\n    }\n}\n\n@media (max-width: 639px) {\n    @keyframes slideIn {\n        from {\n            opacity: 0;\n            transform: translateY(-10px);\n        }\n        to {\n            opacity: 1;\n            transform: translateY(0);\n        }\n    }\n}\n","path":null,"size_bytes":4725,"size_tokens":null},"src/components/VideoGrid.tsx":{"content":"\nimport { WordMapEntry, Sign } from '../types';\nimport { appState, learnedPreferences, alphabetSignsMap } from '../state';\nimport { updateSelectionUI, buildVideoUrl, ICON_LOADING_SVG, showMessage } from '../ui';\nimport { openImproveSignMenuModal, openModal, openThumbDownReasonModal, openGoodChoiceReasonModal, openChangeGrammarSignModal } from './modals';\nimport { saveUserData } from '../hooks/useLexicon';\nimport { reorderSignsWithPreferences } from '../utils/sorting';\n\n// --- DOM ELEMENTS ---\nconst videoGrid = document.getElementById('videoGrid') as HTMLElement;\nconst videoNavControls = document.getElementById('videoNavControls') as HTMLElement;\nconst prevSentenceBtn = document.getElementById('prevSentenceBtn') as HTMLButtonElement;\nconst nextSentenceBtn = document.getElementById('nextSentenceBtn') as HTMLButtonElement;\nconst sentenceCounter = document.getElementById('sentenceCounter') as HTMLElement;\nconst showAllVideosBtn = document.getElementById('showAllVideosBtn') as HTMLButtonElement;\nconst alphabetGrid = document.getElementById('alphabetGrid') as HTMLElement;\n\n// --- CONSTANTS ---\nexport const PRIMARY_VOTE_VALUE = 999;\n\n// --- STATE ---\nlet globalCardIndex = 0; // Moved to module scope to persist across clears\n\n// --- VIDEO OBSERVER FOR LAZY LOADING ---\nfunction createVideoObserver(): IntersectionObserver {\n    return new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n            const card = entry.target as HTMLElement;\n            const video = card.querySelector('video') as HTMLVideoElement;\n            \n            if (entry.isIntersecting && video && !video.src && video.dataset.src) {\n                // Load video when card enters viewport\n                video.src = video.dataset.src;\n                video.load();\n            }\n        });\n    }, { \n        rootMargin: '100px', // Start loading 100px before visible\n        threshold: 0.1 \n    });\n}\n\n// --- EVENT HANDLERS FOR CARD ACTIONS ---\nfunction getCardContext(cardElement: HTMLElement): { phraseTokens: WordMapEntry[], lookupKey: string, fullOriginalPhrase: string, cardId: string, isSpelledOut: boolean, cardContainer: HTMLElement } | null {\n    const cardId = cardElement.dataset.cardId;\n    if (!cardId) return null;\n    const cardData = appState.cardIdDataMap.get(cardId);\n    if (!cardData || !cardData.phraseTokens || cardData.phraseTokens.length === 0) {\n        return null;\n    }\n    \n    return {\n        ...cardData,\n        lookupKey: cardData.phraseTokens[0].base.toLowerCase(),\n        cardId,\n        isSpelledOut: cardData.phraseTokens[0].isSpelledOut || false,\n        cardContainer: cardElement\n    };\n}\n\nfunction handleThumbUpClick(cardElement: HTMLElement) {\n    const context = getCardContext(cardElement);\n    if (!context || !context.phraseTokens[0].signs) return;\n    const cardId = cardElement.dataset.cardId;\n    const cardData = cardId ? appState.cardIdDataMap.get(cardId) : null;\n    const sign = cardData?.currentSign || context.phraseTokens[0].signs[0];\n    openGoodChoiceReasonModal({ ...context, sign }, cardElement);\n    // Autosave user data after action\n    saveUserData().catch(() => {});\n}\n\nfunction handleThumbDownClick(cardElement: HTMLElement) {\n    const context = getCardContext(cardElement);\n    if (!context || !context.phraseTokens[0].signs) return;\n    const cardId = cardElement.dataset.cardId;\n    const cardData = cardId ? appState.cardIdDataMap.get(cardId) : null;\n    const sign = cardData?.currentSign || context.phraseTokens[0].signs[0];\n    openThumbDownReasonModal({ ...context, sign }, cardElement);\n    // Autosave user data after action\n    saveUserData().catch(() => {});\n}\n\nfunction handleChangeClick(cardElement: HTMLElement) {\n    const context = getCardContext(cardElement);\n    if (!context) return;\n    openImproveSignMenuModal(context, cardElement);\n    // Autosave user data after action\n    saveUserData().catch(() => {});\n}\n\n// Grid-level click listener for tool-based interactions\nvideoGrid.addEventListener('click', (e) => {\n    const tool = videoGrid.dataset.activeTool;\n    const card = (e.target as HTMLElement).closest<HTMLElement>('.video-card:not(.video-card-no-sign)');\n    \n    if (tool && tool !== 'none' && card) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const cardId = card.dataset.cardId;\n\n        switch (tool) {\n            case 'thumb-up':\n                if (appState.multiSelectMode && appState.selectedCardIds.size > 0) {\n                    handleGroupThumbUp();\n                } else {\n                    handleThumbUpClick(card);\n                }\n                break;\n            case 'thumb-down':\n                if (appState.multiSelectMode && appState.selectedCardIds.size > 0) {\n                    handleGroupThumbDown();\n                } else {\n                    handleThumbDownClick(card);\n                }\n                break;\n            case 'change':\n                if (appState.multiSelectMode && appState.selectedCardIds.size > 0) {\n                    handleGroupChange();\n                } else {\n                    handleChangeClick(card);\n                }\n                break;\n            case 'select':\n                if (cardId) {\n                    if (appState.multiSelectMode) {\n                        if (appState.selectedCardIds.has(cardId)) {\n                            appState.selectedCardIds.delete(cardId);\n                        } else {\n                            appState.selectedCardIds.add(cardId);\n                        }\n                        updateMultiSelectUI();\n                    } else {\n                        const index = appState.selection.indexOf(cardId);\n                        if (index > -1) {\n                            appState.selection.splice(index, 1);\n                        } else {\n                            appState.selection.push(cardId);\n                        }\n                        updateSelectionUI();\n                    }\n                }\n                break;\n        }\n    }\n});\n\n// --- MULTI-SELECT HANDLERS ---\nfunction handleGroupThumbUp() {\n    const words = Array.from(appState.selectedCardIds)\n        .map(id => appState.cardIdDataMap.get(id)?.fullOriginalPhrase || '')\n        .filter(w => w);\n    showMessage(`‚úì Tumme upp f√∂r: ${words.join(', ')}`, 'success');\n    appState.selectedCardIds.forEach(id => {\n        const card = document.querySelector(`.video-card[data-card-id=\"${id}\"]`);\n        card?.classList.add('feedback-reported');\n    });\n    appState.selectedCardIds.clear();\n    updateMultiSelectUI();\n}\n\nfunction handleGroupThumbDown() {\n    const words = Array.from(appState.selectedCardIds)\n        .map(id => appState.cardIdDataMap.get(id)?.fullOriginalPhrase || '')\n        .filter(w => w);\n    showMessage(`üëé Tumme ner f√∂r: ${words.join(', ')}`, 'error');\n    appState.selectedCardIds.forEach(id => {\n        const card = document.querySelector(`.video-card[data-card-id=\"${id}\"]`);\n        card?.classList.add('feedback-reported');\n    });\n    appState.selectedCardIds.clear();\n    updateMultiSelectUI();\n}\n\nfunction handleGroupChange() {\n    import('./modals').then(({ openMultiSelectFeedbackModal }) => {\n        openMultiSelectFeedbackModal(videoGrid);\n    });\n}\n\nexport function updateMultiSelectUI() {\n    const cards = document.querySelectorAll('.video-card');\n    cards.forEach(card => {\n        const cardId = card.getAttribute('data-card-id');\n        if (appState.selectedCardIds.has(cardId!)) {\n            card.classList.add('selected-multi');\n        } else {\n            card.classList.remove('selected-multi');\n        }\n    });\n}\n\n\n// --- FUNCTIONS ---\nexport function updateNavControls() {\n    if (!videoNavControls || !sentenceCounter || !prevSentenceBtn || !nextSentenceBtn) return;\n    \n    if (appState.sentences.length > 1) {\n        videoNavControls.classList.remove('hidden');\n        prevSentenceBtn.disabled = appState.isShowingAllSentences || appState.currentSentenceIndex <= 0;\n        nextSentenceBtn.disabled = appState.isShowingAllSentences || appState.currentSentenceIndex >= appState.sentences.length - 1;\n        sentenceCounter.textContent = `Mening ${appState.currentSentenceIndex + 1} / ${appState.sentences.length}`;\n        sentenceCounter.classList.toggle('hidden', appState.isShowingAllSentences);\n    } else {\n        videoNavControls.classList.add('hidden');\n    }\n}\n\nexport function updateGrammarNavControls() {\n    const grammarNav = document.getElementById('grammarNavControls');\n    const counter = document.getElementById('grammarSentenceCounter');\n    const prevBtn = document.getElementById('prevGrammarSentenceBtn');\n    const nextBtn = document.getElementById('nextGrammarSentenceBtn');\n    \n    if (!grammarNav || !counter || !prevBtn || !nextBtn) return;\n    \n    if (appState.sentences.length > 1) {\n        counter.textContent = `Mening ${appState.currentGrammarSentenceIndex + 1} / ${appState.sentences.length}`;\n        (prevBtn as HTMLButtonElement).disabled = appState.currentGrammarSentenceIndex <= 0;\n        (nextBtn as HTMLButtonElement).disabled = appState.currentGrammarSentenceIndex >= appState.sentences.length - 1;\n    } else {\n        grammarNav.classList.add('hidden');\n    }\n}\n\nexport function resetAndShowGrammarPlaceholder() {\n    const container = document.getElementById('grammarDisplayContainer');\n    const grid = document.getElementById('grammarGrid');\n    const placeholder = document.getElementById('grammarPlaceholder');\n    const nav = document.getElementById('grammarNavControls');\n\n    if (!container || !grid || !placeholder || !nav) return;\n    \n    if (appState.sentences.length > 0) {\n        container.classList.remove('hidden');\n        grid.innerHTML = '';\n        grid.appendChild(placeholder);\n        placeholder.classList.remove('hidden');\n        nav.classList.add('hidden');\n    } else {\n        container.classList.add('hidden');\n    }\n}\n\nexport function renderCurrentSentence() {\n    if (appState.sentences.length === 0) return;\n    \n    // Update main video grid\n    appState.currentGrammarSentenceIndex = appState.currentSentenceIndex;\n    const currentSentence = appState.sentences[appState.currentSentenceIndex];\n    populateVideoGrid(currentSentence);\n    updateNavControls();\n    \n    // Reset grammar grid to show the \"Translate\" button for the new sentence\n    resetAndShowGrammarPlaceholder();\n    updateGrammarNavControls();\n}\n\n// New function to update a single card in the grammar grid\nexport function updateGrammarCard(index: number, newWordData: WordMapEntry) {\n    const cardId = `grammar-card-${index}`;\n    const cardElement = document.getElementById(cardId) as HTMLElement;\n    if (!cardElement) return;\n\n    // Create a new card with the updated information\n    const newCardElement = createInteractiveCardElement(cardId, newWordData.original, [newWordData], false, index, 'gloss', true);\n\n    // Re-add the info button/badge if it existed\n    if (newWordData.rationale) {\n        const infoBtn = document.createElement('button');\n        infoBtn.className = 'grammar-info-btn';\n        infoBtn.innerHTML = 'i';\n        infoBtn.dataset.tooltipText = newWordData.rationale;\n        newCardElement.appendChild(infoBtn);\n    }\n    \n    // Replace the old card with the new one\n    cardElement.replaceWith(newCardElement);\n}\n\n\n// Updated to render STS Translation Cards with Videos\nexport function renderGrammarGrid(wordMap: WordMapEntry[], isLoading = false) {\n    const container = document.getElementById('grammarDisplayContainer');\n    const grid = document.getElementById('grammarGrid');\n    const placeholder = document.getElementById('grammarPlaceholder');\n    const nav = document.getElementById('grammarNavControls');\n\n    if (!container || !grid || !placeholder || !nav) return;\n\n    placeholder.classList.add('hidden');\n    grid.innerHTML = '';\n\n    if (isLoading) {\n        grid.innerHTML = `<div class=\"flex items-center justify-center h-48\">${ICON_LOADING_SVG} <span class=\"ml-2\">√ñvers√§tter...</span></div>`;\n        nav.classList.add('hidden');\n        return;\n    }\n\n    if (!wordMap || wordMap.length === 0) {\n        resetAndShowGrammarPlaceholder();\n        return;\n    }\n    \n    nav.classList.remove('hidden');\n    \n    const fragment = document.createDocumentFragment();\n    wordMap.forEach((wordData, index) => {\n        if (!wordData.isWord) return;\n\n        const fullPhrase = wordData.original;\n        \n        // Create one card per word to match populateVideoGrid ordning\n        let cardElement: HTMLElement;\n        const cardId = `grammar-card-${index}`;\n        const phraseTokens = [wordData];\n        appState.cardIdDataMap.set(cardId, { phraseTokens, fullOriginalPhrase: fullPhrase, currentVariantIndex: 0, currentSign: wordData.signs?.[0] || null });\n        \n        if (wordData.signs && wordData.signs.length > 0) {\n            // Visa f√∂rsta varianten eller compoundsignen\n            cardElement = createInteractiveCardElement(cardId, fullPhrase, phraseTokens, false, index, 'gloss', true);\n            cardElement.addEventListener('click', () => {\n                openChangeGrammarSignModal(cardId, index);\n            });\n        } else {\n            // No signs found\n            cardElement = createNoSignCardElement(fullPhrase, phraseTokens, cardId);\n        }\n        \n        if (wordData.rationale) {\n            const infoBtn = document.createElement('button');\n            infoBtn.className = 'grammar-info-btn';\n            infoBtn.innerHTML = 'i';\n            infoBtn.dataset.tooltipText = wordData.rationale;\n            cardElement.appendChild(infoBtn);\n        }\n        \n        fragment.appendChild(cardElement);\n    });\n    \n    grid.appendChild(fragment);\n}\n\nexport function updateGridWithAIResults(wordMap: WordMapEntry[]) {\n    wordMap.forEach((wordData, index) => {\n        if (!wordData.isWord) return;\n\n        const cardId = `card-${index}`;\n        const placeholder = document.getElementById(cardId);\n\n        if (placeholder && placeholder.classList.contains('video-card-placeholder')) {\n            let newCard: HTMLElement;\n            if (wordData.signs && wordData.signs.length > 0) {\n                // Main grid should show original Swedish word\n                newCard = createInteractiveCardElement(cardId, wordData.original, [wordData], false, index, 'original');\n            } else {\n                newCard = createNoSignCardElement(wordData.original, [wordData], cardId);\n            }\n            placeholder.replaceWith(newCard);\n        }\n    });\n    updateSelectionUI();\n}\n\n\nexport function populateVideoGrid(wordsToProcess: WordMapEntry[]) {\n    appState.videoObserver?.disconnect();\n    videoGrid.innerHTML = '';\n    appState.cardIdDataMap.clear();\n    globalCardIndex = 0;\n    \n    // Create new observer for lazy loading videos\n    appState.videoObserver = createVideoObserver();\n    \n    document.querySelectorAll<HTMLButtonElement>('.tool-btn').forEach(btn => btn.disabled = wordsToProcess.filter(w => w.isWord).length === 0);\n\n    const fragment = document.createDocumentFragment();\n    wordsToProcess.forEach((wordData, index) => {\n        if (!wordData.isWord) return;\n\n        const cardId = `card-${globalCardIndex++}`;\n        const phraseTokens = [wordData];\n        const fullPhrase = wordData.original;\n        \n        appState.cardIdDataMap.set(cardId, { phraseTokens, fullOriginalPhrase: fullPhrase, currentVariantIndex: 0, currentSign: wordData.signs?.[0] || null });\n        \n        let cardElement: HTMLElement;\n        if (wordData.signs && wordData.signs.length > 0) {\n            // Main grid always uses 'original' display mode\n            cardElement = createInteractiveCardElement(cardId, fullPhrase, phraseTokens, false, index, 'original');\n            // Observe for lazy loading\n            appState.videoObserver?.observe(cardElement);\n        } else if (wordData.rationale === \"Ingen tr√§ff\") {\n            cardElement = createPlaceholderCardElement(fullPhrase, cardId);\n        } else {\n            cardElement = createNoSignCardElement(fullPhrase, phraseTokens, cardId);\n        }\n        fragment.appendChild(cardElement);\n    });\n    videoGrid.appendChild(fragment);\n\n    updateSelectionUI();\n}\n\n\nexport function renderAlphabet() {\n    // Get element dynamically since modal may not exist at module load time\n    const grid = document.getElementById('alphabetGrid') as HTMLElement;\n    if (!grid) {\n        console.warn('alphabetGrid not found in DOM');\n        return;\n    }\n    \n    appState.alphabetObserver?.disconnect();\n    grid.innerHTML = '';\n    \n    const sortedLetters = [...alphabetSignsMap.keys()].sort((a, b) => a.localeCompare(b, 'sv'));\n    \n    if (sortedLetters.length === 0) {\n        grid.innerHTML = '<p class=\"text-gray-400 text-center p-4\">Alfabetet laddas...</p>';\n        return;\n    }\n    \n    const fragment = document.createDocumentFragment();\n\n    sortedLetters.forEach(letter => {\n        const signs = alphabetSignsMap.get(letter);\n        if (!signs || signs.length === 0) return;\n        \n        const cardId = `alphabet-card-${letter}`;\n        const wordMapEntry: WordMapEntry = {\n            original: letter.toUpperCase(),\n            base: letter,\n            isWord: true,\n            pos: 'bokstav',\n            signs: signs\n        };\n        // Alphabet cards show the letter, which is the 'original' phrase\n        const cardElement = createInteractiveCardElement(cardId, letter.toUpperCase(), [wordMapEntry], true, -1, 'original');\n        \n        // For alphabet cards: load video src directly (not lazy) to show thumbnails immediately\n        // since there are only 29 letters and they should all be visible at once\n        const video = cardElement.querySelector('video') as HTMLVideoElement;\n        if (video && video.dataset.src) {\n            video.src = video.dataset.src;\n            video.load();\n        }\n        \n        fragment.appendChild(cardElement);\n    });\n    grid.appendChild(fragment);\n}\n\nexport function createNoSignCardElement(fullOriginalPhrase: string, phraseTokensForLookup: WordMapEntry[], cardId: string) {\n    const cardContainer = document.createElement('div');\n    cardContainer.id = cardId;\n    cardContainer.className = 'video-card video-card-no-sign';\n    cardContainer.innerHTML = `<p style=\"align-self: flex-start;\">${fullOriginalPhrase.toUpperCase()}</p><p class=\"text-xs text-gray-400\">Inget tecken hittades.</p>`;\n    \n    const improveBtn = document.createElement('button');\n    improveBtn.className = 'btn btn-secondary btn-sm';\n    improveBtn.textContent = 'F√∂rb√§ttra';\n    improveBtn.onclick = (e) => {\n        appState.cardIdDataMap.set(cardId, { phraseTokens: phraseTokensForLookup, fullOriginalPhrase, currentVariantIndex: 0, currentSign: null });\n        const context = {\n            phraseTokens: phraseTokensForLookup,\n            lookupKey: phraseTokensForLookup[0].base.toLowerCase(),\n            fullOriginalPhrase,\n            cardId,\n            isSpelledOut: false,\n            cardContainer\n        };\n        openImproveSignMenuModal(context, e.currentTarget as HTMLElement);\n    };\n    cardContainer.appendChild(improveBtn);\n    return cardContainer;\n}\n\nexport function createPlaceholderCardElement(word: string, cardId: string): HTMLElement {\n    const cardContainer = document.createElement('div');\n    cardContainer.id = cardId;\n    cardContainer.className = 'video-card video-card-placeholder';\n    cardContainer.innerHTML = `\n        <div class=\"placeholder-content\">\n            <p class=\"font-bold\">${word.toUpperCase()}</p>\n            ${ICON_LOADING_SVG}\n            <p>S√∂ker...</p>\n        </div>\n    `;\n    return cardContainer;\n}\n\nexport function createInteractiveCardElement(\n    cardId: string, \n    fullOriginalPhrase: string, \n    phraseTokensForLookup: WordMapEntry[], \n    isAlphabetCard = false, \n    wordIndex: number = -1,\n    displayMode: 'original' | 'gloss' = 'original',\n    isGrammarGlossCard = false\n): HTMLElement {\n    const wordData = phraseTokensForLookup[0];\n    \n    // For grammar gloss cards, show just text - no videos\n    if (isGrammarGlossCard && displayMode === 'gloss') {\n        const cardContainer = document.createElement('div');\n        cardContainer.id = cardId;\n        cardContainer.className = 'video-card video-card-gloss-text';\n        cardContainer.dataset.cardId = cardId;\n        \n        const glossText = wordData.gloss || wordData.base?.toUpperCase() || fullOriginalPhrase.toUpperCase();\n        \n        const titleEl = document.createElement('p');\n        titleEl.className = 'video-card-title gloss-text-display';\n        titleEl.textContent = glossText.toUpperCase();\n        titleEl.style.fontSize = '24px';\n        titleEl.style.fontWeight = 'bold';\n        titleEl.style.padding = '20px';\n        titleEl.style.textAlign = 'center';\n        titleEl.style.wordBreak = 'break-word';\n        \n        cardContainer.appendChild(titleEl);\n        return cardContainer;\n    }\n    \n    const cardContainer = document.createElement('div');\n    cardContainer.className = 'video-card';\n    cardContainer.id = cardId; \n    cardContainer.dataset.cardId = cardId;\n    if(wordIndex !== -1) {\n        cardContainer.dataset.wordIndex = String(wordIndex);\n    }\n\n    let signs = wordData.signs!;\n\n    const primarySign = signs[0];\n    const isCompound = wordData.isCompound === true;\n\n    const playerWrapper = document.createElement('div');\n    playerWrapper.className = 'video-card-player-wrapper relative'; // Ensure relative for loader positioning\n    \n    // --- LOADER ELEMENT ---\n    const loader = document.createElement('div');\n    loader.className = 'absolute inset-0 flex items-center justify-center bg-gray-900 z-10 transition-opacity duration-200';\n    loader.innerHTML = ICON_LOADING_SVG;\n    // ---------------------\n\n    const videoPlayer = document.createElement('video');\n    videoPlayer.className = 'video-card-player';\n    // Use data-src for lazy loading - observer will set src when visible\n    const videoUrl = buildVideoUrl(primarySign.id, primarySign.word);\n    console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', primarySign.id, 'word:', primarySign.word);\n    videoPlayer.dataset.src = videoUrl;\n    videoPlayer.muted = true;\n    videoPlayer.playsInline = true;\n    videoPlayer.loop = !isCompound; // Don't loop if compound word\n    videoPlayer.disablePictureInPicture = true;\n    videoPlayer.preload = 'metadata'; // Load first frame for thumbnail display\n\n    // --- VARIANT COUNTER & NAVIGATION (top-left) ---\n    let currentVariantIndex = 0;\n    let variantCounter: HTMLDivElement | null = null;\n    let variantContainer: HTMLDivElement | null = null;\n    \n    const updateVariantCounter = () => {\n        if (variantCounter) {\n            variantCounter.textContent = `${currentVariantIndex + 1}/${signs.length}`;\n        }\n    };\n    \n    const switchVariant = (direction: 'prev' | 'next') => {\n        if (direction === 'next') {\n            currentVariantIndex = (currentVariantIndex + 1) % signs.length;\n        } else {\n            currentVariantIndex = (currentVariantIndex - 1 + signs.length) % signs.length;\n        }\n        const newSign = signs[currentVariantIndex];\n        const videoUrl = buildVideoUrl(newSign.id, newSign.word);\n        console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', newSign.id, 'word:', newSign.word);\n        videoPlayer.src = videoUrl;\n        updateVariantCounter();\n        videoPlayer.play().catch(e => console.warn(\"Variant play failed:\", e));\n        // Save current variant index in cardIdDataMap so feedback uses correct sign\n        const cardData = appState.cardIdDataMap.get(cardId);\n        if (cardData) {\n            cardData.currentVariantIndex = currentVariantIndex;\n            cardData.currentSign = newSign;\n        }\n    };\n    \n    if (signs.length > 1) {\n        // Container for variant controls\n        variantContainer = document.createElement('div');\n        variantContainer.className = 'absolute top-0 left-0 flex items-center gap-0 rounded bg-black/50 px-0.5 py-0 z-50';\n        variantContainer.style.pointerEvents = 'auto';\n        \n        // Previous button\n        const prevBtn = document.createElement('button');\n        prevBtn.className = 'variant-nav-btn text-white font-bold rounded hover:bg-white/30 transition-colors';\n        prevBtn.textContent = '‚óÄ';\n        prevBtn.style.fontSize = '9px';\n        prevBtn.style.padding = '2px 3px';\n        prevBtn.style.pointerEvents = 'auto';\n        prevBtn.style.cursor = 'pointer';\n        prevBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            switchVariant('prev');\n        });\n        variantContainer.appendChild(prevBtn);\n        \n        // Counter badge\n        variantCounter = document.createElement('div');\n        if (isCompound) {\n            variantCounter.textContent = `üîó1/${signs.length}`;\n        } else {\n            variantCounter.textContent = `1/${signs.length}`;\n        }\n        variantCounter.className = 'text-white font-semibold leading-tight select-none';\n        variantCounter.style.fontSize = '9px';\n        variantCounter.style.padding = '2px 4px';\n        variantCounter.style.minWidth = '20px';\n        variantCounter.style.textAlign = 'center';\n        variantContainer.appendChild(variantCounter);\n        \n        // Next button\n        const nextBtn = document.createElement('button');\n        nextBtn.className = 'variant-nav-btn text-white font-bold rounded hover:bg-white/30 transition-colors';\n        nextBtn.textContent = '‚ñ∂';\n        nextBtn.style.fontSize = '9px';\n        nextBtn.style.padding = '2px 3px';\n        nextBtn.style.pointerEvents = 'auto';\n        nextBtn.style.cursor = 'pointer';\n        nextBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            switchVariant('next');\n        });\n        variantContainer.appendChild(nextBtn);\n        \n        playerWrapper.appendChild(variantContainer);\n    }\n    // ------------------------------------\n    \n    // --- GENUINT TECKEN BADGE (top-right) ---\n    if (wordData.isGenuine) {\n        const genuineBadge = document.createElement('div');\n        genuineBadge.className = 'genuine-sign-badge absolute top-0 right-0 z-50';\n        genuineBadge.innerHTML = `\n            <svg class=\"h-3 w-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z\"></path>\n            </svg>\n            <span>Genuint</span>\n        `;\n        genuineBadge.title = 'Genuint tecken - idiomatisk fras';\n        playerWrapper.appendChild(genuineBadge);\n    }\n    // ------------------------------------\n\n    // For compound words: play signs sequentially and update counter\n    if (isCompound) {\n        videoPlayer.addEventListener('ended', () => {\n            currentVariantIndex++;\n            if (currentVariantIndex < signs.length) {\n                const nextSign = signs[currentVariantIndex];\n                const videoUrl = buildVideoUrl(nextSign.id, nextSign.word);\n                console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', nextSign.id, 'word:', nextSign.word);\n                videoPlayer.src = videoUrl;\n                if (variantCounter) {\n                    variantCounter.textContent = `üîó ${currentVariantIndex + 1}/${signs.length}`;\n                }\n                videoPlayer.play().catch(e => console.warn(\"Compound play failed:\", e));\n            } else {\n                // Loop back to first sign\n                currentVariantIndex = 0;\n                const videoUrl = buildVideoUrl(signs[0].id, signs[0].word);\n                console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', signs[0].id, 'word:', signs[0].word);\n                videoPlayer.src = videoUrl;\n                if (variantCounter) {\n                    variantCounter.textContent = `üîó 1/${signs.length}`;\n                }\n                videoPlayer.play().catch(e => console.warn(\"Compound loop failed:\", e));\n            }\n        });\n    }\n\n    // Hide loader when video metadata is loaded (shows first frame as thumbnail)\n    const hideLoader = () => {\n        loader.classList.add('opacity-0');\n        setTimeout(() => {\n            loader.classList.add('hidden');\n        }, 200);\n    };\n    \n    // Use loadedmetadata to show first frame faster (thumbnail)\n    videoPlayer.addEventListener('loadedmetadata', hideLoader);\n    videoPlayer.addEventListener('loadeddata', hideLoader);\n    videoPlayer.addEventListener('canplay', hideLoader);\n    \n    // Also hide on error to avoid stuck spinner (or maybe show error icon in future)\n    videoPlayer.addEventListener('error', () => {\n        loader.classList.add('hidden');\n    });\n    \n    // Ensure video starts paused (shows as still image)\n    videoPlayer.pause();\n\n\n    cardContainer.onmouseover = () => {\n        if (appState.isPlayingAll) return;\n        \n        // Ensure video src is set (lazy loading may not have triggered yet)\n        if (!videoPlayer.src && videoPlayer.dataset.src) {\n            videoPlayer.src = videoPlayer.dataset.src;\n        }\n        \n        // Reset to first sign when hovering over compound word\n        if (isCompound) {\n            currentVariantIndex = 0;\n            const videoUrl = buildVideoUrl(signs[0].id, signs[0].word);\n            console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', signs[0].id, 'word:', signs[0].word);\n            videoPlayer.src = videoUrl;\n            if (variantCounter) {\n                variantCounter.textContent = `üîó 1/${signs.length}`;\n            }\n        } else if (signs && signs.length > 1) {\n            // Reset to first variant for non-compound words too\n            currentVariantIndex = 0;\n            const videoUrl = buildVideoUrl(signs[0].id, signs[0].word);\n            console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', signs[0].id, 'word:', signs[0].word);\n            videoPlayer.src = videoUrl;\n            updateVariantCounter();\n        }\n        videoPlayer.play().catch(e => {\n            if (e.name !== 'AbortError') console.warn(\"Hover-play was prevented:\", e);\n        });\n    };\n    cardContainer.onmouseout = () => {\n        if (appState.isPlayingAll) return;\n        videoPlayer.pause();\n        videoPlayer.currentTime = 0;\n        // Reset to first sign\n        if (isCompound) {\n            currentVariantIndex = 0;\n            const videoUrl = buildVideoUrl(signs[0].id, signs[0].word);\n            console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', signs[0].id, 'word:', signs[0].word);\n            videoPlayer.src = videoUrl;\n            if (variantCounter) {\n                variantCounter.textContent = `üîó 1/${signs.length}`;\n            }\n        } else if (signs && signs.length > 1) {\n            currentVariantIndex = 0;\n            const videoUrl = buildVideoUrl(signs[0].id, signs[0].word);\n            console.log('VideoGrid: Genererad videol√§nk:', videoUrl, 'id:', signs[0].id, 'word:', signs[0].word);\n            videoPlayer.src = videoUrl;\n            updateVariantCounter();\n        }\n    };\n\n    const titleEl = document.createElement('p');\n    titleEl.className = 'video-card-title';\n    \n    let displayText = '';\n\n    if (displayMode === 'gloss') {\n        // For the AI grid, prioritize the AI's gloss. Fallback to sign word.\n        displayText = wordData.gloss || primarySign.word;\n    } else {\n        // For the top/original grid, use the original swedish word.\n        displayText = fullOriginalPhrase;\n    }\n    \n    titleEl.textContent = displayText.toUpperCase();\n    \n    // Append loader along with video\n    playerWrapper.append(videoPlayer, loader, titleEl);\n\n    // Only append action buttons if NOT an alphabet card\n    if (!isAlphabetCard) {\n        const actionButtons = document.createElement('div');\n        actionButtons.className = 'action-buttons';\n        \n        const thumbUpBtn = document.createElement('button');\n        thumbUpBtn.className = 'video-card-btn thumb-up-btn';\n        thumbUpBtn.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M2 10.5a1.5 1.5 0 113 0v6a1.5 1.5 0 01-3 0v-6zM6 10.333V17a1 1 0 001 1h6.364a1 1 0 00.942-.673l1.858-6.47A1.5 1.5 0 0014.28 8H11V5.167a2.5 2.5 0 00-5 0v5.166z\" /></svg>`;\n        thumbUpBtn.setAttribute('aria-label', 'Ge tumme upp');\n        thumbUpBtn.dataset.tooltipText = 'Tumme upp';\n        thumbUpBtn.onclick = (e) => { e.stopPropagation(); handleThumbUpClick(cardContainer); };\n\n        const thumbDownBtn = document.createElement('button');\n        thumbDownBtn.className = 'video-card-btn thumb-down-btn';\n        thumbDownBtn.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M18 9.5a1.5 1.5 0 11-3 0v-6a1.5 1.5 0 013 0v6zM14 9.667V3a1 1 0 00-1-1H6.636a1 1 0 00-.942.673l-1.858 6.47A1.5 1.5 0 005.72 12H9v4.833a2.5 2.5 0 005 0V9.667z\" /></svg>`;\n        thumbDownBtn.setAttribute('aria-label', 'Ge tumme ner');\n        thumbDownBtn.dataset.tooltipText = 'Tumme ner';\n        thumbDownBtn.onclick = (e) => { e.stopPropagation(); handleThumbDownClick(cardContainer); };\n\n        const changeBtn = document.createElement('button');\n        changeBtn.className = 'video-card-btn change-btn';\n        changeBtn.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\"><path d=\"M2.695 14.763l-1.262 3.154a.5.5 0 00.65.65l3.155-1.262a4 4 0 001.343-.885L17.5 5.5a2.121 2.121 0 00-3-3L3.58 13.42a4 4 0 00-.885 1.343z\" /></svg>`;\n        changeBtn.setAttribute('aria-label', 'F√∂rb√§ttra tecken');\n        changeBtn.dataset.tooltipText = 'Byt, f√∂resl√•, rapportera';\n        changeBtn.onclick = (e) => { e.stopPropagation(); handleChangeClick(cardContainer); };\n\n        actionButtons.append(thumbUpBtn, thumbDownBtn, changeBtn);\n        cardContainer.append(playerWrapper, actionButtons);\n    } else {\n        // Alphabet cards: just player, no buttons\n        cardContainer.append(playerWrapper);\n    }\n\n    if (isAlphabetCard) {\n        appState.alphabetObserver?.observe(cardContainer);\n    }\n    return cardContainer;\n}\n","path":null,"size_bytes":34355,"size_tokens":null},"src/modules/search/__tests__/localSearchWithFallback.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as localSearchWithFallback from '../localSearchWithFallback';\n\ndescribe('localSearchWithFallback module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(localSearchWithFallback).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r s√∂klogik h√§r\n});\n","path":null,"size_bytes":440,"size_tokens":null},"src/modules/ui/theme.ts":{"content":"\nimport { appState } from '../../state';\nimport { showMessage } from '../../ui';\n\nconst accessibilityToolbar = document.getElementById('accessibilityToolbar') as HTMLElement;\n\n// Uppdatera ikoner baserat p√• aktuellt tema\nfunction updateThemeIcons(theme: 'light' | 'dark') {\n    const sunIcon = document.getElementById('sunIcon');\n    const moonIcon = document.getElementById('moonIcon');\n    \n    if (!sunIcon || !moonIcon) return;\n\n    if (theme === 'light') {\n        sunIcon.classList.remove('hidden');\n        moonIcon.classList.add('hidden');\n    } else {\n        sunIcon.classList.add('hidden');\n        moonIcon.classList.remove('hidden');\n    }\n}\n\nexport function setTheme(theme: 'light' | 'dark') {\n    document.documentElement.setAttribute('data-theme', theme);\n    localStorage.setItem('theme', theme);\n    updateThemeIcons(theme);\n}\n\nexport function setupThemeToggle() {\n    const themeToggleBtn = document.getElementById('themeToggleBtn');\n    if (!themeToggleBtn) return;\n\n    // S√§tt initialt v√§rde baserat p√• localStorage eller default 'dark'\n    const currentTheme = (localStorage.getItem('theme') as 'light' | 'dark') || 'dark';\n    // Force update of icons immediately\n    updateThemeIcons(currentTheme);\n    setTheme(currentTheme);\n\n    themeToggleBtn.onclick = () => {\n        const activeTheme = document.documentElement.getAttribute('data-theme') as 'light' | 'dark';\n        const newTheme = activeTheme === 'light' ? 'dark' : 'light';\n        setTheme(newTheme);\n    };\n}\n\nexport function toggleAccessibilityMode() {\n    const htmlEl = document.documentElement;\n    htmlEl.classList.toggle('accessibility-mode');\n    const isActive = htmlEl.classList.contains('accessibility-mode');\n    appState.isAccessibilityModeActive = isActive;\n    localStorage.setItem('accessibilityMode', isActive.toString());\n    \n    showMessage(`Tillg√§nglighetsl√§ge ${isActive ? 'aktiverat' : 'avaktiverat'}.`, 'success');\n    if (isActive) {\n        if (accessibilityToolbar) accessibilityToolbar.classList.remove('hidden');\n    } else {\n        if (accessibilityToolbar) accessibilityToolbar.classList.add('hidden');\n    }\n}\n\nexport function initTheme() {\n    setupThemeToggle();\n    \n    if (localStorage.getItem('accessibilityMode') === 'true') {\n        document.documentElement.classList.add('accessibility-mode');\n        appState.isAccessibilityModeActive = true;\n        if (accessibilityToolbar) accessibilityToolbar.classList.remove('hidden');\n    } else {\n        document.documentElement.classList.remove('accessibility-mode');\n        appState.isAccessibilityModeActive = false;\n        if (accessibilityToolbar) accessibilityToolbar.classList.add('hidden');\n    }\n}\n","path":null,"size_bytes":2690,"size_tokens":null},"src/modules/features/search.ts":{"content":"\nimport { appState } from '../../state';\nimport { WordMapEntry } from '../../types';\nimport { findCandidatesForToken } from '../search/localSearchWithFallback';\nimport { updateButtonProgress, showMessage, getLexiconUrl, originalTextDisplay } from '../../ui';\nimport { renderAnalyzedText } from '../ui/textDisplay';\nimport { splitTextIntoSentences } from '../logic/textProcessing';\nimport { enrichWordMapDataInBackground } from '../../hooks/useDataEnrichment';\nimport { renderCurrentSentence, resetAndShowGrammarPlaceholder } from '../../components/VideoGrid';\nimport { openSignDetailsModal } from '../../components/modals';\nimport { displayWordInfo } from './wordInfo';\n\n// DOM Elements specific to search visibility handling\nconst videoDisplayContainer = document.getElementById('videoDisplayContainer') as HTMLElement;\nconst toolsAndActionsContainer = document.getElementById('tools-and-actions-container') as HTMLElement;\nconst showAllVideosBtn = document.getElementById('showAllVideosBtn') as HTMLButtonElement;\n\nasync function handleWordClick(wordData: WordMapEntry, openerElement: HTMLElement) {\n    if (wordData.signs && wordData.signs.length > 0) {\n        appState.modalContexts.signDetailsContext = wordData;\n        openSignDetailsModal(wordData, openerElement);\n        // Display word info with examples and related videos\n        displayWordInfo(wordData.base);\n    } else {\n        const targetUrl = getLexiconUrl('search', wordData.base);\n        if (targetUrl) {\n            window.open(targetUrl, '_blank');\n        }\n    }\n}\n\nfunction handleSearchResult(result: WordMapEntry[]) {\n    appState.wordMap = result;\n    \n    // Rendera den klickbara texten\n    renderAnalyzedText(result, handleWordClick);\n    \n    // Dela upp i meningar via logik-modulen\n    appState.sentences = splitTextIntoSentences(result);\n    \n    if (appState.sentences.length > 0) {\n        if(videoDisplayContainer) videoDisplayContainer.classList.remove('hidden');\n        if(toolsAndActionsContainer) toolsAndActionsContainer.classList.remove('hidden');\n        \n        if(showAllVideosBtn) showAllVideosBtn.textContent = 'Visa Alla';\n        appState.isShowingAllSentences = false;\n        appState.currentSentenceIndex = 0;\n        appState.currentGrammarSentenceIndex = 0; \n        appState.aiTranslatedSentences.clear();\n        \n        // Rendera f√∂rsta meningen i rutn√§tet\n        renderCurrentSentence();\n        \n        // Scroll till videorna\n        const videoGrid = document.getElementById('videoGrid');\n        if (videoGrid) {\n            setTimeout(() => {\n                videoGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });\n            }, 100);\n        }\n    } else {\n        if(videoDisplayContainer) videoDisplayContainer.classList.add('hidden');\n        if(toolsAndActionsContainer) toolsAndActionsContainer.classList.add('hidden');\n        resetAndShowGrammarPlaceholder();\n    }\n    \n    // Starta bakgrundsprocess f√∂r att h√§mta mer data (exempel, relaterat)\n    enrichWordMapDataInBackground(result);\n}\n\nexport async function processAndRenderText(textToProcess?: string) {\n    const textContent = textToProcess ?? (originalTextDisplay.innerText || '');\n    \n    if (!textContent.trim() || textContent.trim() === originalTextDisplay.dataset.placeholder) {\n        showMessage(\"Textrutan √§r tom.\", 'error');\n        return;\n    }\n\n    updateButtonProgress('local_search');\n    \n    // Tokenisera texten (bevara skiljetecken, radbrytningar och mellanslag f√∂r korrekt √•terskapande)\n    const tokens = textContent.split(/([,.\"!?\\n\\s]+)/g).filter(token => token.length > 0);\n    \n    const promises = tokens.map(async (token): Promise<WordMapEntry> => {\n        // Om token bara √§r skiljetecken, radbrytningar eller mellanslag\n        if (/^[\\s,.\"!?\\n]+$/.test(token)) {\n            return { original: token, base: token, isWord: false, pos: 'PUNCT', signs: null };\n        }\n\n        // S√∂k i lokalt lexikon\n        const cand = await findCandidatesForToken(token);\n        \n        if (cand) {\n            return {\n                original: token,\n                base: cand.base,\n                isWord: true,\n                pos: '',\n                signs: cand.signs,\n                isCompound: !!cand.isCompound,\n                rationale: cand.method\n            };\n        } else {\n            return {\n                original: token,\n                base: token.toLowerCase().trim(),\n                isWord: true,\n                pos: '',\n                signs: null,\n                isCompound: false,\n                rationale: 'Ingen lokalt tecken hittades'\n            };\n        }\n    });\n\n    const localResults = await Promise.all(promises);\n    \n    handleSearchResult(localResults);\n    \n    updateButtonProgress('success');\n}\n","path":null,"size_bytes":4782,"size_tokens":null},"src/modules/logic/textProcessing.ts":{"content":"\nimport { WordMapEntry } from '../../types';\n\n/**\n * Delar upp en lista av ordanalyser i meningar baserat p√• interpunktion.\n * @param wordMap Den platta listan av ordanalyser.\n * @returns En array av meningar (d√§r varje mening √§r en array av ord).\n */\nexport function splitTextIntoSentences(wordMap: WordMapEntry[]): WordMapEntry[][] {\n    const sentences: WordMapEntry[][] = [];\n    if (wordMap.length === 0) return sentences;\n    \n    let currentSentence: WordMapEntry[] = [];\n    const SENTENCE_ENDERS = ['.', '!', '?', '...', '‚Äì', '‚Äî'];\n    \n    wordMap.forEach((wordData, index) => {\n        // Skip line breaks - don't add them to sentences, just create breaks\n        const trimmed = wordData.original.trim();\n        if (trimmed === '' && wordData.original.includes('\\n')) {\n            // This is a line break, push current sentence if it has content\n            if (currentSentence.length > 0 && currentSentence.some(token => token.isWord)) {\n                sentences.push(currentSentence);\n            }\n            currentSentence = [];\n            return;\n        }\n        \n        currentSentence.push(wordData);\n        \n        // Check if this ends a sentence\n        const isSentenceEnd = SENTENCE_ENDERS.some(ender => trimmed.endsWith(ender));\n        \n        if (isSentenceEnd) {\n            // Only push if sentence contains actual words\n            if (currentSentence.length > 0 && currentSentence.some(token => token.isWord)) {\n                sentences.push(currentSentence);\n            }\n            currentSentence = [];\n        }\n    });\n    \n    // Add final sentence if it contains words\n    if (currentSentence.length > 0 && currentSentence.some(token => token.isWord)) {\n        sentences.push(currentSentence);\n    }\n    \n    return sentences;\n}\n","path":null,"size_bytes":1790,"size_tokens":null},"src/modules/genuina/genuinaHandlers.ts":{"content":"// Event handlers och UI f√∂r genuina tecken\n\nimport { genuinaTeckenService, type GenuintTecken } from './genuinaTeckenService';\nimport { PhraseHighlighter } from './phraseHighlighter';\nimport { originalTextDisplay, buildVideoUrl } from '../../ui';\n\nlet highlighter: PhraseHighlighter | null = null;\nlet currentTooltip: HTMLElement | null = null;\n\n/**\n * S√§tt upp genuina tecken funktionalitet\n */\nexport async function setupGenuinaTecken() {\n    // Ladda genuina tecken data\n    await genuinaTeckenService.load();\n\n    if (!genuinaTeckenService.isLoaded()) {\n        console.warn('Genuina tecken kunde inte laddas');\n        return;\n    }\n\n    // S√§tt upp highlighting p√• text input\n    if (originalTextDisplay) {\n        highlighter = new PhraseHighlighter(originalTextDisplay);\n\n        // Highlight n√§r anv√§ndaren skriver\n        originalTextDisplay.addEventListener('input', () => {\n            highlighter?.highlight();\n        });\n\n        // Highlight n√§r textf√§ltet f√•r focus (om det redan finns text)\n        originalTextDisplay.addEventListener('focus', () => {\n            if (originalTextDisplay.textContent?.trim()) {\n                highlighter?.highlight(true);\n            }\n        });\n\n        // Hantera klick p√• highlightade fraser\n        originalTextDisplay.addEventListener('click', handlePhraseClick);\n    }\n\n    // S√§tt upp modal handlers\n    setupModal();\n}\n\n/**\n * Hantera klick p√• highlightad fras\n */\nfunction handlePhraseClick(e: Event) {\n    const target = e.target as HTMLElement;\n\n    if (target.classList.contains('genuine-phrase')) {\n        const teckenId = target.dataset.teckenId;\n        const phrase = target.dataset.phrase;\n\n        if (teckenId) {\n            showTooltip(target, teckenId, phrase || '');\n        }\n    } else {\n        // Klick utanf√∂r - st√§ng tooltip\n        hideTooltip();\n    }\n}\n\n/**\n * Visa tooltip med tecken-info\n */\nfunction showTooltip(anchorElement: HTMLElement, teckenId: string, phrase: string) {\n    hideTooltip(); // Ta bort tidigare tooltip\n\n    const tecken = genuinaTeckenService.findById(teckenId);\n    if (!tecken) return;\n\n    const tooltip = document.createElement('div');\n    tooltip.className = 'genuine-tooltip';\n    tooltip.innerHTML = `\n        <div class=\"genuine-tooltip-header\">\n            <span class=\"genuine-tooltip-badge\">\n                üí° Genuint tecken\n            </span>\n            <button class=\"genuine-tooltip-close\" data-action=\"close-tooltip\">&times;</button>\n        </div>\n        <div class=\"genuine-tooltip-phrase\">${escapeHTML(phrase)}</div>\n        <div class=\"genuine-tooltip-id\">ID: ${escapeHTML(teckenId)}</div>\n        ${tecken.synonymer.length > 0 ? `\n            <div class=\"genuine-tooltip-synonyms\">\n                <div class=\"genuine-tooltip-synonyms-label\">Synonymer:</div>\n                <div class=\"genuine-tooltip-synonyms-list\">\n                    ${tecken.synonymer.map(syn => `\n                        <span class=\"genuine-synonym-tag\">${escapeHTML(syn)}</span>\n                    `).join('')}\n                </div>\n            </div>\n        ` : ''}\n        <div class=\"genuine-tooltip-actions\">\n            <button class=\"btn btn-primary btn-sm\" data-action=\"show-video\" data-tecken-id=\"${teckenId}\">\n                <svg class=\"h-4 w-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z\"></path><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg>\n                Se tecken\n            </button>\n        </div>\n    `;\n\n    // Positionera tooltip\n    const rect = anchorElement.getBoundingClientRect();\n    tooltip.style.position = 'fixed';\n    tooltip.style.left = `${rect.left}px`;\n    tooltip.style.top = `${rect.bottom + 8}px`;\n\n    // Justera om tooltip g√•r utanf√∂r sk√§rmen\n    document.body.appendChild(tooltip);\n    const tooltipRect = tooltip.getBoundingClientRect();\n    \n    if (tooltipRect.right > window.innerWidth - 16) {\n        tooltip.style.left = `${window.innerWidth - tooltipRect.width - 16}px`;\n    }\n    if (tooltipRect.bottom > window.innerHeight - 16) {\n        tooltip.style.top = `${rect.top - tooltipRect.height - 8}px`;\n    }\n\n    currentTooltip = tooltip;\n\n    // Event listeners f√∂r tooltip\n    tooltip.querySelector('[data-action=\"close-tooltip\"]')?.addEventListener('click', hideTooltip);\n    tooltip.querySelector('[data-action=\"show-video\"]')?.addEventListener('click', () => {\n        // TODO: Implementera visa video direkt\n        console.log('Visa video f√∂r tecken:', teckenId);\n        hideTooltip();\n    });\n\n    // St√§ng vid klick utanf√∂r\n    setTimeout(() => {\n        document.addEventListener('click', outsideClickListener);\n    }, 0);\n}\n\n/**\n * D√∂lj tooltip\n */\nfunction hideTooltip() {\n    if (currentTooltip) {\n        currentTooltip.remove();\n        currentTooltip = null;\n        document.removeEventListener('click', outsideClickListener);\n    }\n}\n\n/**\n * Listener f√∂r klick utanf√∂r tooltip\n */\nfunction outsideClickListener(e: MouseEvent) {\n    const target = e.target as HTMLElement;\n    if (currentTooltip && !currentTooltip.contains(target) && !target.classList.contains('genuine-phrase')) {\n        hideTooltip();\n    }\n}\n\n/**\n * S√§tt upp modal f√∂r genuina tecken lista\n */\nfunction setupModal() {\n    const modal = document.getElementById('genuinaTeckenModal');\n    const openBtn = document.getElementById('genuinaTeckenBtn');\n    const closeBtn = document.getElementById('genuinaTeckenClose');\n    const searchInput = document.getElementById('genuinaTeckenSearch') as HTMLInputElement;\n    const listContainer = document.getElementById('genuinaTeckenList');\n\n    if (!modal || !openBtn || !closeBtn || !searchInput || !listContainer) {\n        console.warn('Genuina tecken modal element saknas');\n        return;\n    }\n\n    // √ñppna modal\n    openBtn.addEventListener('click', () => {\n        modal.classList.remove('hidden');\n        searchInput.value = '';\n        renderList('');\n        searchInput.focus();\n    });\n\n    // St√§ng modal\n    const closeModal = () => {\n        modal.classList.add('hidden');\n    };\n\n    closeBtn.addEventListener('click', closeModal);\n    modal.addEventListener('click', (e) => {\n        if (e.target === modal) {\n            closeModal();\n        }\n    });\n\n    // S√∂k i modal\n    searchInput.addEventListener('input', () => {\n        renderList(searchInput.value);\n    });\n\n    // Escape-tangent st√§nger modal\n    document.addEventListener('keydown', (e) => {\n        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {\n            closeModal();\n        }\n    });\n}\n\n/**\n * Rendera lista √∂ver genuina tecken\n */\nfunction renderList(query: string) {\n    const listContainer = document.getElementById('genuinaTeckenList');\n    if (!listContainer) return;\n\n    const results = genuinaTeckenService.search(query);\n\n    if (results.length === 0) {\n        listContainer.innerHTML = `\n            <div class=\"text-center text-gray-400 py-8\">\n                Inga genuina tecken hittades\n            </div>\n        `;\n        return;\n    }\n\n    listContainer.innerHTML = results.map(tecken => `\n        <div class=\"genuine-item\" data-tecken-id=\"${escapeHTML(tecken.id)}\" data-phrase=\"${escapeHTML(tecken.tecken)}\">\n            <div class=\"genuine-item-phrase\">${escapeHTML(tecken.tecken)}</div>\n            <div class=\"genuine-item-id\">ID: ${escapeHTML(tecken.id)}</div>\n            ${tecken.synonymer.length > 0 ? `\n                <div class=\"genuine-item-synonyms\">\n                    ${escapeHTML(tecken.synonymer.join(', '))}\n                </div>\n            ` : ''}\n        </div>\n    `).join('');\n\n    // Klick handler f√∂r att infoga i textf√§lt\n    listContainer.querySelectorAll('.genuine-item').forEach(item => {\n        item.addEventListener('click', () => {\n            const phrase = (item as HTMLElement).dataset.phrase;\n            const teckenId = (item as HTMLElement).dataset.teckenId;\n            console.log('Genuine item clicked:', { teckenId, phrase });\n            let videoContainer = item.querySelector('.genuine-video-container');\n            if (videoContainer) {\n                // Om video redan visas, ta bort den\n                videoContainer.remove();\n            } else {\n                // Annars visa video\n                const videoUrl = buildVideoUrl(teckenId, phrase, 'tecken', undefined, true);\n                videoContainer = document.createElement('div');\n                videoContainer.className = 'genuine-video-container';\n                videoContainer.innerHTML = `<video src=\"${videoUrl}\" controls autoplay style=\"max-width:220px; margin-left:12px; vertical-align:middle;\"></video>`;\n                item.appendChild(videoContainer);\n            }\n        });\n    });\n}\n\n/**\n * Escape HTML f√∂r s√§kerhet\n */\nfunction escapeHTML(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n}\n","path":null,"size_bytes":9121,"size_tokens":null},"src/modules/features/alphabetPlayer.ts":{"content":"\nimport { alphabetSignsMap } from '../../state';\nimport { Sign } from '../../types';\nimport { buildVideoUrl, showMessage } from '../../ui';\nimport { openModal, closeModal } from '../../components/modals/ModalSystem';\n\nlet alphabetSequence: { sign: Sign, letter: string }[] = [];\nlet currentSequenceIndex = 0;\nlet isSequencePlaying = false;\nlet sequencePlayer: HTMLVideoElement | null;\nlet sequenceLetterEl: HTMLElement | null;\nlet playPauseBtn: HTMLButtonElement | null;\nlet prevBtn: HTMLButtonElement | null;\nlet nextBtn: HTMLButtonElement | null;\n\nfunction setupAlphabetSequence() {\n    alphabetSequence = [...alphabetSignsMap.entries()]\n        .sort(([a], [b]) => a.localeCompare(b, 'sv'))\n        .map(([letter, signs]) => ({ sign: signs[0], letter: letter.toUpperCase() }));\n    currentSequenceIndex = 0;\n    isSequencePlaying = true;\n}\n\nfunction playCurrentSequenceVideo() {\n    if (!sequencePlayer || !playPauseBtn || !prevBtn || !nextBtn || !sequenceLetterEl) return;\n\n    if (alphabetSequence.length === 0) {\n        showMessage(\"Alfabetet har inte laddats √§n.\", \"error\");\n        return;\n    }\n    \n    const { sign, letter } = alphabetSequence[currentSequenceIndex];\n    // const errorEl = document.getElementById('alphabetSequenceVideoError') as HTMLElement; // Kan l√§ggas till vid behov f√∂r felhantering\n\n    sequencePlayer.src = buildVideoUrl(sign.id, sign.word);\n    sequenceLetterEl.textContent = letter;\n    \n    playPauseBtn.textContent = 'Pausa';\n    isSequencePlaying = true;\n    \n    prevBtn.disabled = currentSequenceIndex === 0;\n    nextBtn.disabled = currentSequenceIndex === alphabetSequence.length - 1;\n\n    sequencePlayer.play().catch(e => console.error(\"Sequence play failed\", e));\n}\n\nfunction handlePlayPauseSequence() {\n    if (!sequencePlayer || !playPauseBtn) return;\n    if (isSequencePlaying) {\n        sequencePlayer.pause();\n        playPauseBtn.textContent = 'Spela';\n    } else {\n        sequencePlayer.play();\n        playPauseBtn.textContent = 'Pausa';\n    }\n    isSequencePlaying = !isSequencePlaying;\n}\n\nfunction handleNextSequence() {\n    if (currentSequenceIndex < alphabetSequence.length - 1) {\n        currentSequenceIndex++;\n        playCurrentSequenceVideo();\n    } else {\n        isSequencePlaying = false;\n        if(playPauseBtn) playPauseBtn.textContent = 'Spela om';\n    }\n}\n\nfunction handlePrevSequence() {\n    if (currentSequenceIndex > 0) {\n        currentSequenceIndex--;\n        playCurrentSequenceVideo();\n    }\n}\n\nexport function initializeAlphabetModals() {\n    const playAlphabetSequenceBtn = document.getElementById('playAlphabetSequenceBtn') as HTMLButtonElement;\n    const alphabetModal = document.getElementById('alphabetModal') as HTMLElement;\n    const alphabetSequenceModal = document.getElementById('alphabetSequenceModal') as HTMLElement;\n\n    sequencePlayer = document.getElementById('alphabetSequencePlayer') as HTMLVideoElement;\n    sequenceLetterEl = document.getElementById('alphabetSequenceLetter') as HTMLElement;\n    playPauseBtn = document.getElementById('playPauseAlphabetBtn') as HTMLButtonElement;\n    prevBtn = document.getElementById('prevAlphabetBtn') as HTMLButtonElement;\n    nextBtn = document.getElementById('nextAlphabetBtn') as HTMLButtonElement;\n\n    if (!playAlphabetSequenceBtn || !alphabetModal || !alphabetSequenceModal || !sequencePlayer) return;\n\n    playAlphabetSequenceBtn.addEventListener('click', (e) => {\n        setupAlphabetSequence();\n        closeModal(alphabetModal);\n        openModal(alphabetSequenceModal, e.currentTarget as HTMLElement);\n        playCurrentSequenceVideo();\n    });\n\n    sequencePlayer.addEventListener('ended', handleNextSequence);\n    playPauseBtn.addEventListener('click', handlePlayPauseSequence);\n    nextBtn.addEventListener('click', handleNextSequence);\n    prevBtn.addEventListener('click', handlePrevSequence);\n\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            if (mutation.attributeName === 'class' && !(alphabetSequenceModal.classList.contains('show'))) {\n                sequencePlayer?.pause();\n                isSequencePlaying = false;\n            }\n        });\n    });\n    observer.observe(alphabetSequenceModal, { attributes: true });\n}\n","path":null,"size_bytes":4251,"size_tokens":null},"src/styles/genuina-tecken.css":{"content":"/* === GENUINA TECKEN STYLING === */\n\n/* Highlight f√∂r genuina tecken i text input */\nmark.genuine-phrase {\n    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(16, 185, 129, 0.25) 100%);\n    color: inherit;\n    border-bottom: 2px solid rgb(34, 197, 94);\n    border-radius: 3px;\n    padding: 2px 4px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n\nmark.genuine-phrase:hover {\n    background: linear-gradient(135deg, rgba(34, 197, 94, 0.3) 0%, rgba(16, 185, 129, 0.35) 100%);\n    border-bottom-color: rgb(16, 185, 129);\n    box-shadow: 0 2px 8px rgba(34, 197, 94, 0.3);\n}\n\n/* Tooltip f√∂r genuina tecken info */\n.genuine-tooltip {\n    position: absolute;\n    background: var(--bg-dark);\n    border: 2px solid rgb(34, 197, 94);\n    border-radius: var(--border-radius-md);\n    padding: var(--space-md);\n    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);\n    z-index: 1000;\n    min-width: 250px;\n    max-width: 400px;\n    pointer-events: auto;\n}\n\n.genuine-tooltip-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: var(--space-sm);\n    padding-bottom: var(--space-sm);\n    border-bottom: 1px solid rgba(34, 197, 94, 0.3);\n}\n\n.genuine-tooltip-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.375rem;\n    padding: 0.25rem 0.5rem;\n    background: rgba(34, 197, 94, 0.15);\n    border: 1px solid rgba(34, 197, 94, 0.4);\n    border-radius: var(--border-radius-sm);\n    font-size: 0.75rem;\n    font-weight: 600;\n    color: rgb(34, 197, 94);\n    text-transform: uppercase;\n    letter-spacing: 0.05em;\n}\n\n.genuine-tooltip-close {\n    background: transparent;\n    border: none;\n    color: var(--text-secondary);\n    cursor: pointer;\n    padding: 0.25rem;\n    line-height: 1;\n    transition: color 0.2s ease;\n}\n\n.genuine-tooltip-close:hover {\n    color: var(--text-primary);\n}\n\n.genuine-tooltip-phrase {\n    font-size: 1.125rem;\n    font-weight: 600;\n    color: rgb(34, 197, 94);\n    margin-bottom: var(--space-sm);\n}\n\n.genuine-tooltip-id {\n    font-size: 0.875rem;\n    color: var(--text-tertiary);\n    font-family: monospace;\n    margin-bottom: var(--space-md);\n}\n\n.genuine-tooltip-synonyms {\n    margin-bottom: var(--space-md);\n}\n\n.genuine-tooltip-synonyms-label {\n    font-size: 0.875rem;\n    font-weight: 600;\n    color: var(--text-secondary);\n    margin-bottom: 0.375rem;\n}\n\n.genuine-tooltip-synonyms-list {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 0.375rem;\n}\n\n.genuine-synonym-tag {\n    display: inline-block;\n    padding: 0.25rem 0.5rem;\n    background: rgba(255, 255, 255, 0.05);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-sm);\n    font-size: 0.8125rem;\n    color: var(--text-secondary);\n}\n\n.genuine-tooltip-actions {\n    display: flex;\n    gap: var(--space-sm);\n}\n\n/* Modal f√∂r genuina tecken lista */\n.genuina-tecken-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.8);\n    backdrop-filter: blur(8px);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 9999;\n    padding: var(--space-md);\n}\n\n.genuina-tecken-modal.hidden {\n    display: none;\n}\n\n.genuina-tecken-content {\n    background: var(--bg-dark);\n    border: 2px solid rgb(34, 197, 94);\n    border-radius: var(--border-radius-lg);\n    padding: var(--space-lg);\n    max-width: 700px;\n    width: 100%;\n    max-height: 80vh;\n    display: flex;\n    flex-direction: column;\n    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);\n}\n\n.genuina-tecken-header {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    margin-bottom: var(--space-md);\n    padding-bottom: var(--space-md);\n    border-bottom: 2px solid rgba(34, 197, 94, 0.3);\n}\n\n.genuina-tecken-title {\n    display: flex;\n    align-items: center;\n    gap: var(--space-sm);\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: rgb(34, 197, 94);\n}\n\n.genuina-tecken-search {\n    width: 100%;\n    padding: var(--space-sm) var(--space-md);\n    background: rgba(0, 0, 0, 0.3);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-md);\n    color: var(--text-primary);\n    font-size: 1rem;\n    margin-bottom: var(--space-md);\n    transition: border-color 0.2s ease;\n}\n\n.genuina-tecken-search:focus {\n    outline: none;\n    border-color: rgb(34, 197, 94);\n}\n\n.genuina-tecken-list {\n    flex: 1;\n    overflow-y: auto;\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-sm);\n}\n\n.genuine-item {\n    padding: var(--space-md);\n    background: rgba(255, 255, 255, 0.02);\n    border: 1px solid var(--border-color);\n    border-radius: var(--border-radius-md);\n    cursor: pointer;\n    transition: all 0.2s ease;\n}\n\n.genuine-item:hover {\n    background: rgba(34, 197, 94, 0.1);\n    border-color: rgb(34, 197, 94);\n    transform: translateX(4px);\n}\n\n.genuine-item-phrase {\n    font-weight: 600;\n    color: rgb(34, 197, 94);\n    margin-bottom: 0.25rem;\n}\n\n.genuine-item-id {\n    font-size: 0.75rem;\n    color: var(--text-tertiary);\n    font-family: monospace;\n    margin-bottom: 0.375rem;\n}\n\n.genuine-item-synonyms {\n    font-size: 0.875rem;\n    color: var(--text-secondary);\n}\n\n/* Badge p√• video card */\n.genuine-sign-badge {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.25rem;\n    padding: 0.25rem 0.5rem;\n    background: linear-gradient(135deg, rgba(34, 197, 94, 0.2) 0%, rgba(16, 185, 129, 0.25) 100%);\n    border: 1px solid rgb(34, 197, 94);\n    border-radius: var(--border-radius-sm);\n    font-size: 0.75rem;\n    font-weight: 600;\n    color: rgb(34, 197, 94);\n    text-transform: uppercase;\n    letter-spacing: 0.03em;\n}\n\n/* Mobile optimering */\n@media (max-width: 640px) {\n    .genuine-tooltip {\n        min-width: 200px;\n        max-width: 90vw;\n    }\n\n    .genuina-tecken-content {\n        max-height: 90vh;\n        padding: var(--space-md);\n    }\n\n    .genuina-tecken-title {\n        font-size: 1.25rem;\n    }\n}\n","path":null,"size_bytes":5969,"size_tokens":null},"src/modules/genuina/genuinaTeckenService.ts":{"content":"// Genuina Tecken (Idiomatiska uttryck) service\n// Laddar och matchar genuina tecken i svensk text\n\nexport interface GenuintTecken {\n    tecken: string;\n    id: string;\n    synonymer: string[];\n}\n\nexport interface PhraseMatch {\n    phrase: string;\n    startIndex: number;\n    endIndex: number;\n    teckenId: string;\n    synonymer: string[];\n}\n\nclass GenuinaTeckenService {\n    private genuinaTecken: GenuintTecken[] = [];\n    private loaded = false;\n    private loading = false;\n\n    async load(): Promise<void> {\n        if (this.loaded || this.loading) return;\n        \n        this.loading = true;\n        \n        try {\n            const response = await fetch('/data/genuina_tecken.json');\n            if (!response.ok) {\n                throw new Error(`Failed to load genuina tecken: ${response.status}`);\n            }\n            \n            this.genuinaTecken = await response.json();\n            \n            // Sortera fr√•n l√§ngst till kortast f√∂r korrekt multi-word matching\n            this.genuinaTecken.sort((a, b) => {\n                const aWords = a.tecken.split(' ').length;\n                const bWords = b.tecken.split(' ').length;\n                if (aWords !== bWords) {\n                    return bWords - aWords; // L√§ngst f√∂rst\n                }\n                return b.tecken.length - a.tecken.length;\n            });\n            \n            this.loaded = true;\n            console.log(`‚ú® Genuina tecken laddade: ${this.genuinaTecken.length} fraser`);\n        } catch (error) {\n            console.error('Fel vid laddning av genuina tecken:', error);\n        } finally {\n            this.loading = false;\n        }\n    }\n\n    /**\n     * Hitta alla genuina tecken i en text\n     * Returnerar matches med position och metadata\n     */\n    findMatches(text: string): PhraseMatch[] {\n        if (!this.loaded || !text) return [];\n\n        const matches: PhraseMatch[] = [];\n        const lowerText = text.toLowerCase();\n        const usedRanges: Array<[number, number]> = [];\n\n        // Kolla varje genuint tecken (sorterade fr√•n l√§ngst till kortast)\n        for (const tecken of this.genuinaTecken) {\n            const phrase = tecken.tecken.toLowerCase();\n            let startIndex = 0;\n\n            // Hitta alla f√∂rekomster av frasen\n            while ((startIndex = lowerText.indexOf(phrase, startIndex)) !== -1) {\n                const endIndex = startIndex + phrase.length;\n\n                // Kontrollera att matchningen √§r ett helt ord/fras\n                const isValidMatch = this.isWholePhrase(text, startIndex, endIndex);\n                \n                // Kontrollera att det inte √∂verlappar med tidigare match\n                const overlaps = usedRanges.some(([usedStart, usedEnd]) => {\n                    return !(endIndex <= usedStart || startIndex >= usedEnd);\n                });\n\n                if (isValidMatch && !overlaps) {\n                    matches.push({\n                        phrase: text.substring(startIndex, endIndex),\n                        startIndex,\n                        endIndex,\n                        teckenId: tecken.id,\n                        synonymer: tecken.synonymer\n                    });\n                    usedRanges.push([startIndex, endIndex]);\n                }\n\n                startIndex = endIndex;\n            }\n        }\n\n        // Sortera efter position i texten\n        matches.sort((a, b) => a.startIndex - b.startIndex);\n        \n        return matches;\n    }\n\n    /**\n     * Kontrollera att matchningen √§r en hel fras (inte del av annat ord)\n     */\n    private isWholePhrase(text: string, start: number, end: number): boolean {\n        // Kontrollera b√∂rjan\n        if (start > 0) {\n            const charBefore = text[start - 1];\n            if (/[a-z√•√§√∂A-Z√Ö√Ñ√ñ0-9]/.test(charBefore)) {\n                return false; // Del av ett l√§ngre ord\n            }\n        }\n\n        // Kontrollera slutet\n        if (end < text.length) {\n            const charAfter = text[end];\n            if (/[a-z√•√§√∂A-Z√Ö√Ñ√ñ0-9]/.test(charAfter)) {\n                return false; // Del av ett l√§ngre ord\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Hitta genuint tecken fr√•n ID\n     */\n    findById(id: string): GenuintTecken | undefined {\n        return this.genuinaTecken.find(t => t.id === id);\n    }\n\n    /**\n     * Hitta genuint tecken fr√•n fras/text (exakt match, case-insensitive)\n     */\n    find(phrase: string): GenuintTecken | undefined {\n        const lowerPhrase = phrase.toLowerCase().trim();\n        return this.genuinaTecken.find(t => t.tecken.toLowerCase() === lowerPhrase);\n    }\n\n    /**\n     * S√∂k genuina tecken (f√∂r modal)\n     */\n    search(query: string): GenuintTecken[] {\n        if (!query.trim()) return this.genuinaTecken;\n\n        const lowerQuery = query.toLowerCase();\n        return this.genuinaTecken.filter(t => {\n            // Matcha p√• tecken eller synonymer\n            if (t.tecken.toLowerCase().includes(lowerQuery)) return true;\n            return t.synonymer.some(syn => syn.toLowerCase().includes(lowerQuery));\n        });\n    }\n\n    /**\n     * Returnera alla genuina tecken\n     */\n    getAll(): GenuintTecken[] {\n        return this.genuinaTecken;\n    }\n\n    isLoaded(): boolean {\n        return this.loaded;\n    }\n}\n\n// Singleton instance\nexport const genuinaTeckenService = new GenuinaTeckenService();\n","path":null,"size_bytes":5388,"size_tokens":null},"src/modules/ui/textDisplay.ts":{"content":"\nimport { appState } from '../../state';\nimport { WordMapEntry } from '../../types';\nimport { originalTextDisplay, getLexiconUrl } from '../../ui';\n\nexport function initializePlaceholder() {\n    if (!originalTextDisplay) return;\n    if (!originalTextDisplay.textContent?.trim() || originalTextDisplay.textContent === originalTextDisplay.dataset.placeholder) {\n        originalTextDisplay.textContent = originalTextDisplay.dataset.placeholder || '';\n        originalTextDisplay.classList.remove('text-area-editable');\n    } else {\n        originalTextDisplay.classList.add('text-area-editable');\n    }\n}\n\nexport function renderAnalyzedText(wordMap: WordMapEntry[], onWordClick: (word: WordMapEntry, el: HTMLElement) => void) {\n    if (!originalTextDisplay) return;\n    originalTextDisplay.innerHTML = '';\n    \n    wordMap.forEach(wordData => {\n        // Skip line breaks - don't render them, just show text as flowing\n        if (wordData.original.trim() === '') {\n            // For whitespace, just add a space\n            originalTextDisplay.appendChild(document.createTextNode(' '));\n            return;\n        }\n        \n        const span = document.createElement('span');\n        span.textContent = wordData.original;\n        if (wordData.isWord && appState.isClickableMode) {\n            span.classList.add('clickable-word-span');\n            if (wordData.isSpelledOut) {\n                span.classList.add('is-spelled-out');\n                span.dataset.tooltipText = `<span class=\"tooltip-blue\">Stavas ut!</span> Ordet \"<strong>${wordData.base}</strong>\" hittades inte och stavas ut ist√§llet.`;\n            } else if (wordData.signs && wordData.signs.length > 0) {\n                span.classList.add('has-video');\n                if (wordData.isCompound) {\n                    span.classList.add('is-compound');\n                    span.dataset.tooltipText = `<span class=\"tooltip-orange\">Sammansatt ord!</span> Klicka f√∂r detaljerad information.`;\n                } else if (wordData.signs.length > 1) {\n                    span.classList.add('has-multiple-videos');\n                    span.dataset.tooltipText = `<span class=\"tooltip-purple\">${wordData.signs.length} tecken finns!</span> Klicka f√∂r detaljer och v√§lj r√§tt tecken nedan.`;\n                } else {\n                    span.dataset.tooltipText = `<span class=\"tooltip-green\">1 tecken finns!</span> Klicka f√∂r att se exempel, glosa och mer information.`;\n                }\n            } else {\n                span.classList.add('no-video');\n                span.dataset.tooltipText = `Inget tecken hittades lokalt. Klicka f√∂r att s√∂ka efter \"<strong>${wordData.base}</strong>\" p√• lexikonets webbplats.`;\n            }\n            \n            span.addEventListener('click', (e) => {\n                if (wordData.signs && wordData.signs.length > 0) {\n                    onWordClick(wordData, e.currentTarget as HTMLElement);\n                } else {\n                    const targetUrl = getLexiconUrl('search', wordData.base);\n                    if (targetUrl) {\n                        window.open(targetUrl, '_blank');\n                    }\n                }\n            });\n        }\n        originalTextDisplay.appendChild(span);\n    });\n}\n","path":null,"size_bytes":3233,"size_tokens":null},"src/state.ts":{"content":"\nimport { AppState, FeedbackEntry, PositiveFeedbackEntry, NegativeFeedbackEntry, Sign, WordMapEntry, ChatHistoryMessage, LexiconMetadata, LearningData } from './types';\n\n// --- APP STATE ---\nexport const appState: AppState = {\n    ai: null,\n    isClickableMode: true, // Default to true as the app's main function is analysis\n    wordMap: [],\n    sentences: [],\n    currentSentenceIndex: 0,\n    currentGrammarSentenceIndex: 0, // New\n    aiTranslatedSentences: new Map(), // New\n    isShowingAllSentences: false,\n    isPlayingAll: false,\n    isAccessibilityModeActive: false,\n    isListening: false,\n    recognition: null,\n    activeModalOpener: null,\n    latestReportContent: null,\n    latestFeedbackJson: \"\",\n    latestReportSummary: null, // NEW\n    modalContexts: {\n        signDetailsCardId: null,\n        signDetailsPhrase: null,\n        signDetailsContext: null,\n        changeReason: null,\n        thumbDownReason: null,\n        goodChoiceReason: null,\n        sentenceFeedback: null,\n        suggestion: null,\n        sendSuggestion: null,\n        improveSign: null,\n    },\n    mediaState: {\n        mediaRecorder: null,\n        recordedBlobs: [],\n        timerInterval: null,\n        tempVideoBlob: null,\n        mediaStream: null,\n    },\n    videoSuggestions: [],\n    videoObserver: null,\n    alphabetObserver: null,\n    combinationSelection: [],\n    selection: [],\n    multiSelectMode: false,\n    selectedCardIds: new Set<string>(),\n    chat: null,\n    chatHistory: [],\n    chatFile: null,\n    cardIdDataMap: new Map(),\n    latestAnalysisResult: null,\n    linguisticQuestions: [],\n    shownQuestionKeys: new Set(),\n    pendingLinguisticQuestion: null,\n    abortController: null,\n    lexiconMetadata: null,\n    loadedLexiconParts: new Set<number>(),\n    onlineLearningData: null,\n    localLexiconReady: false,\n    fullLexiconLoaded: false,\n    localLexiconProgress: 0,\n    onlineLexiconProgress: 0,\n    changeSignMode: 'main', // New\n    aiEnabled: localStorage.getItem('aiEnabled') === 'true', // Default: AV (anv√§ndaren m√•ste aktivera)\n    usePuter: false, // Puter.js integration flag\n    aiReady: true, // AI system with API keys ready\n    glosaEnabled: localStorage.getItem('glosaEnabled') === 'true' || false, // BETA feature toggle\n    // Available API Keys (via environment variables)\n    // HUGGINGFACE_TOKEN, GOOGLE_AI_STUDIO_KEY, MISTRAL_API_KEY, DEEPAI_KEY, OLLAMA_KEY, LAOZHANG_API_KEY\n};\n\n// --- LEXICON DATA STATE ---\nexport const localLexiconMap = new Map<string, Sign[]>();\nexport const idToWordMap = new Map<string, string>();\nexport const alphabetSignsMap = new Map<string, Sign[]>();\nexport let searchableLexicon: string[] = [];\nexport let latestSignsFromLexicon: { word: string; id: string }[] = [];\nexport const homonymMap = new Map<string, Map<string, Sign>>();\nexport const aliasMap = new Map<string, string>();\nexport const fullLexiconMap = new Map<string, any[]>();\nexport const inflectionMap = new Map<string, string>();\n// Swedish inflection mappings (ordform -> lemma)\n// Definite singular forms (with article)\ninflectionMap.set('himlen', 'himmel');\ninflectionMap.set('√•ret', '√•r');\ninflectionMap.set('dagen', 'dag');\ninflectionMap.set('natten', 'natt');\ninflectionMap.set('mannen', 'man');\ninflectionMap.set('kvinnan', 'kvinna');\ninflectionMap.set('barnet', 'barn');\ninflectionMap.set('huset', 'hus');\ninflectionMap.set('gatan', 'gata');\ninflectionMap.set('morgonen', 'morgon');\ninflectionMap.set('kv√§llen', 'kv√§ll');\ninflectionMap.set('vattnet', 'vatten');\ninflectionMap.set('skogen', 'skog');\ninflectionMap.set('solen', 'sol');\n\n// Plural forms (common -ar, -er, -or endings)\ninflectionMap.set('f√•glarna', 'f√•gel');\ninflectionMap.set('hundarna', 'hund');\ninflectionMap.set('katterna', 'katt');\ninflectionMap.set('tr√§den', 'tr√§d');\ninflectionMap.set('blommorna', 'blomma');\ninflectionMap.set('husen', 'hus');\ninflectionMap.set('m√§nniskorna', 'm√§nniska');\ninflectionMap.set('barnen', 'barn');\ninflectionMap.set('djuren', 'djur');\ninflectionMap.set('dagarna', 'dag');\ninflectionMap.set('n√§tterna', 'natt');\ninflectionMap.set('m√§nnen', 'man');\ninflectionMap.set('kvinnorna', 'kvinna');\ninflectionMap.set('gatorna', 'gata');\ninflectionMap.set('morgonarna', 'morgon');\ninflectionMap.set('kv√§llarna', 'kv√§ll');\ninflectionMap.set('nya', 'ny');\ninflectionMap.set('sm√•', 'liten');\n\n// Verb inflections (present tense to infinitive)\ninflectionMap.set('f√∂rst√•r', 'f√∂rst√•');\n\n// üÜï PERFECT PARTICIP - dessa √§r redan grundformer, ska INTE modifieras\ninflectionMap.set('sett', 'sett');\ninflectionMap.set('gjort', 'gjort');\ninflectionMap.set('varit', 'varit');\ninflectionMap.set('kommit', 'kommit');\ninflectionMap.set('tagit', 'tagit');\ninflectionMap.set('l√§st', 'l√§st');\ninflectionMap.set('skrivit', 'skrivit');\ninflectionMap.set('√§tit', '√§tit');\ninflectionMap.set('drunkit', 'drunkit');\ninflectionMap.set('sovit', 'sovit');\ninflectionMap.set('st√•tt', 'st√•tt');\ninflectionMap.set('satt', 'satt');\ninflectionMap.set('legat', 'legat');\ninflectionMap.set('gett', 'gett');\ninflectionMap.set('kunnat', 'kunnat');\ninflectionMap.set('velat', 'velat');\ninflectionMap.set('m√•ttat', 'm√•ttat');\ninflectionMap.set('brutit', 'brutit');\ninflectionMap.set('kassat', 'kassat');\ninflectionMap.set('sparkat', 'sparkat');\ninflectionMap.set('levt', 'levt');\n\n// --- SIGN LANGUAGE GLOSS INFLECTION MAP ---\n// Maps sign language gloss variations to base glosor (teckenspr√•ks-varianter)\nexport const signInflectionMap = new Map<string, string>();\n// Classifier variations (klassificerare-varianter)\nsignInflectionMap.set('HUND-LITEN', 'HUND');\nsignInflectionMap.set('HUND-STOR', 'HUND');\nsignInflectionMap.set('HUND-M√ÖNGA', 'HUND');\nsignInflectionMap.set('KATT-LITEN', 'KATT');\nsignInflectionMap.set('KATT-STOR', 'KATT');\nsignInflectionMap.set('F√ÖGEL-M√ÖNGA', 'F√ÖGEL');\nsignInflectionMap.set('F√ÖGEL-LITEN', 'F√ÖGEL');\n\n// Aspectual variations (verb-varianter med aspect)\nsignInflectionMap.set('√ÑTA-MYCKET', '√ÑTA');\nsignInflectionMap.set('√ÑTA-LITE', '√ÑTA');\nsignInflectionMap.set('√ÑTA-SNABBT', '√ÑTA');\nsignInflectionMap.set('G√Ö-L√ÖNGSAMT', 'G√Ö');\nsignInflectionMap.set('G√Ö-SNABBT', 'G√Ö');\nsignInflectionMap.set('SE-L√ÑNGE', 'SE');\nsignInflectionMap.set('SE-KORT', 'SE');\n\n// Negation variations\nsignInflectionMap.set('√ÑT-INTE', '√ÑTA');\nsignInflectionMap.set('G√Ö-INTE', 'G√Ö');\nsignInflectionMap.set('SE-INTE', 'SE');\nsignInflectionMap.set('KOMMA-INTE', 'KOMMA');\n\n// Intensity/Reduplikation variations\nsignInflectionMap.set('LEDSEN-MYCKET', 'LEDSEN');\nsignInflectionMap.set('GLAD-MYCKET', 'GLAD');\nsignInflectionMap.set('TR√ñTT-MYCKET', 'TR√ñTT');\nsignInflectionMap.set('R√ñD-MYCKET', 'R√ñD');\n\n// --- CACHING STATE ---\nexport const aiAnalysisCache = new Map<string, WordMapEntry[]>();\n\n// --- USER FEEDBACK & PREFERENCES STATE ---\nexport const feedbackMap = new Map<string, FeedbackEntry>();\nexport const sentenceFeedbackMap = new Map<string, string>();\nexport const positiveFeedbackMap = new Map<string, Map<string, PositiveFeedbackEntry>>();\nexport const negativeFeedbackMap = new Map<string, Map<string, NegativeFeedbackEntry>>();\nexport const learnedPreferences = new Map<string, Map<string, number>>();\nexport const questionClarifications = new Map<string, string>();\n\n\n// --- DEV MODE STATE ---\nexport const localUserSigns = new Map<string, { signs: Sign[], isCompound?: boolean }>();\nexport const localVideoMap = new Map<string, string>();\n\n// --- REACTIVE STATE UPDATERS ---\n\n/**\n * Generates the JSON string from current feedback maps immediately.\n * This ensures appState.latestFeedbackJson is always up to date.\n */\nexport function updateLatestFeedbackJson() {\n    const feedbackReport = {\n        signFeedback: Array.from(feedbackMap.entries()).map(([cardId, entry]) => ({ cardId, ...entry })),\n        sentenceFeedback: Array.from(sentenceFeedbackMap.entries()).map(([sentence, comment]) => ({ sentence, comment })),\n        negativeFeedback: Array.from(negativeFeedbackMap.entries()).flatMap(([cardId, innerMap]) => Array.from(innerMap.entries()).map(([signId, entry]) => ({ cardId, signId, ...entry }))),\n        positiveFeedback: Array.from(positiveFeedbackMap.entries()).flatMap(([cardId, innerMap]) => Array.from(innerMap.entries()).map(([signId, entry]) => ({ cardId, signId, ...entry }))),\n    };\n    \n    appState.latestFeedbackJson = JSON.stringify(feedbackReport, null, 2);\n    \n    // Optional: Notify dev console\n    // console.log(\"Feedback JSON updated:\", appState.latestFeedbackJson.length, \"chars\");\n}\n","path":null,"size_bytes":8486,"size_tokens":null},"src/App.full.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport App from './App';\nimport { render } from '@testing-library/react';\n\ndescribe('App component (full test)', () => {\n  it('should render without crashing', () => {\n    const { container } = render(<App />);\n    expect(container).toBeTruthy();\n  });\n\n  // L√§gg till tester f√∂r navigation och huvudfunktioner h√§r\n});\n","path":null,"size_bytes":369,"size_tokens":null},"src/modules/ui/modalTemplates.ts":{"content":"\nexport const MODAL_TEMPLATES = `\n    <!-- AI Chat Modal with Tab System -->\n    <div id=\"askAiAboutStsModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 600px; height: 80vh; display: flex; flex-direction: column;\">\n            <!-- Header -->\n            <div class=\"flex justify-between items-start mb-4\">\n                <h3 class=\"text-2xl font-bold\">Fr√•ga AI om STS</h3>\n                <button id=\"aiChatCloseBtn\" class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n\n            <!-- Tabs Navigation -->\n            <div class=\"flex border-b border-gray-700 mb-4\">\n                <button id=\"tabAiChat\" class=\"px-4 py-2 font-semibold border-b-2 border-blue-500 text-blue-400 hover:text-white focus:outline-none transition-colors\">\n                    üí¨ Chatt\n                </button>\n                <button id=\"tabAiFeedback\" class=\"px-4 py-2 font-semibold border-b-2 border-transparent text-gray-400 hover:text-white focus:outline-none transition-colors flex items-center gap-2\">\n                    üíæ Spara & Inl√§rning\n                    <span id=\"feedbackTabBadge\" class=\"bg-red-500 text-white text-xs font-bold px-2 py-0.5 rounded-full hidden\">0</span>\n                </button>\n            </div>\n\n            <!-- Tab 1: General Chat Content -->\n            <div id=\"aiChatView\" class=\"flex-1 flex flex-col\" style=\"min-height: 0;\">\n                <div class=\"flex justify-between items-center mb-2 px-1\">\n                    <span class=\"text-xs font-bold text-gray-400\">Historik</span>\n                    <button id=\"clearChatHistoryBtn\" class=\"text-xs text-red-400 hover:text-red-300 transition-colors underline\">Rensa historik</button>\n                </div>\n                <div id=\"aiChatHistory\" class=\"flex-1 overflow-y-auto p-4 bg-gray-900/50 rounded-lg mb-4 space-y-4\">\n                    <!-- Chat messages will be appended here -->\n                </div>\n                \n                <div id=\"aiChatFilePreviewContainer\" class=\"mb-2\">\n                    <!-- File preview will be shown here -->\n                </div>\n\n                <div id=\"aiChatSearchContainer\" class=\"hidden flex-col bg-gray-800 p-3 rounded-lg mb-2 border border-gray-700\">\n                    <div class=\"flex justify-between items-center mb-2\">\n                         <span class=\"text-xs font-bold text-gray-400\">S√∂k tecken att infoga</span>\n                         <button id=\"aiChatCloseSearchBtn\" class=\"text-gray-400 hover:text-white\">&times;</button>\n                    </div>\n                    <input type=\"text\" id=\"aiChatSearchInput\" class=\"modal-input mb-2 text-sm\" placeholder=\"Skriv ord...\">\n                    <div id=\"aiChatSearchResults\" class=\"grid grid-cols-4 gap-2 max-h-32 overflow-y-auto\"></div>\n                </div>\n\n                <div class=\"flex items-end gap-2\">\n                     <button id=\"aiChatSearchToggleBtn\" class=\"btn btn-secondary flex-shrink-0 p-2\" data-tooltip-text=\"S√∂k tecken\" aria-label=\"S√∂k tecken\">\n                        <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\"></path></svg>\n                    </button>\n                    <textarea id=\"aiChatInput\" class=\"feedback-textarea flex-1\" placeholder=\"St√§ll en fr√•ga om teckenspr√•k...\" rows=\"1\" style=\"resize: none;\"></textarea>\n                    <input type=\"file\" id=\"aiChatFileInput\" class=\"hidden\" accept=\".txt,.pdf,.doc,.docx,image/*\">\n                    <button id=\"aiChatFileUploadBtn\" class=\"btn btn-secondary flex-shrink-0 p-2\" data-tooltip-text=\"Ladda upp fil (txt, pdf, doc, bild)\" aria-label=\"Ladda upp fil\">\n                        <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13\"></path></svg>\n                    </button>\n                    <button id=\"aiChatSendBtn\" class=\"btn btn-primary flex-shrink-0 p-2\" data-tooltip-text=\"Skicka meddelande\" aria-label=\"Skicka meddelande\">\n                        <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\"></path></svg>\n                    </button>\n                </div>\n            </div>\n\n            <!-- Tab 2: Feedback Chat Content -->\n            <div id=\"aiFeedbackView\" class=\"flex-1 flex flex-col hidden\" style=\"min-height: 0;\">\n                <div class=\"flex-1 overflow-y-auto p-4 bg-gray-900/50 rounded-lg mb-4 space-y-4 relative\">\n                    <!-- A dedicated placeholder for feedback dialogue -->\n                    <div id=\"aiFeedbackHistory\" class=\"flex flex-col gap-4\">\n                         <!-- Messages injected by JS -->\n                    </div>\n                </div>\n                <div class=\"flex items-end gap-2\">\n                     <button id=\"showJsonBtn\" class=\"btn btn-secondary flex-shrink-0 px-3 py-2 text-xs\" data-tooltip-text=\"Visa aktuell JSON\">\n                         <span class=\"font-mono\">JSON</span>\n                     </button>\n                     <textarea id=\"aiFeedbackInput\" class=\"feedback-textarea flex-1\" placeholder=\"Svara 'Ja' eller 'Spara'...\" rows=\"1\" style=\"resize: none;\"></textarea>\n                     <button id=\"aiFeedbackSendBtn\" class=\"btn btn-primary flex-shrink-0 p-2\">\n                        <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\"></path></svg>\n                    </button>\n                </div>\n            </div>\n\n        </div>\n    </div>\n    \n    <!-- Settings Modal -->\n    <div id=\"settingsModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 class=\"text-2xl font-bold mb-6\">Inst√§llningar</h3>\n            <div class=\"flex flex-col gap-6\">\n                \n                <!-- Utseende -->\n                <div>\n                    <h4 class=\"text-sm font-bold text-gray-400 uppercase tracking-wider mb-3\">Utseende & Tillg√§nglighet</h4>\n                    <div class=\"flex flex-col gap-3\">\n                        <button id=\"themeToggleBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-indigo-500/20 text-indigo-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg id=\"sunIcon\" class=\"h-6 w-6 hidden\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M6.343 17.657l-.707.707\"></path></svg>\n                                <svg id=\"moonIcon\" class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z\"></path></svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">F√§rgtema</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">Byt mellan ljust och m√∂rkt l√§ge.</div>\n                            </div>\n                        </button>\n\n                        <button id=\"accessibilityToggleBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-green-500/20 text-green-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\"></path><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\"></path></svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">Kontrastl√§ge</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">√ñka kontrast f√∂r b√§ttre l√§sbarhet.</div>\n                            </div>\n                        </button>\n                    </div>\n                </div>\n\n                <!-- Resurser & Hj√§lp -->\n                <div>\n                    <h4 class=\"text-sm font-bold text-gray-400 uppercase tracking-wider mb-3\">Resurser & Hj√§lp</h4>\n                    <div class=\"flex flex-col gap-3\">\n                        <button id=\"settingsLexiconBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-blue-500/20 text-blue-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 6.042A8.967 8.967 0 006 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 016 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 016-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0018 18a8.967 8.967 0 00-6 2.292m0-14.25v14.25\"></path></svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">√ñppna Lexikon</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">S√∂k manuellt i hela teckenspr√•kslexikonet.</div>\n                            </div>\n                        </button>\n\n                        <button id=\"alphabetBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-blue-500/20 text-blue-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M7 20l4-16m2 16l4-16M6 9h14M4 15h14\"></path></svg>\n                            </div>\n                             <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">Handalfabetet</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">Visa handalfabetet och tr√§na.</div>\n                            </div>\n                        </button>\n\n                        <button id=\"appFeedbackBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-orange-500/20 text-orange-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z\"></path></svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">App-feedback</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">Rapportera buggar eller ge f√∂rslag.</div>\n                            </div>\n                        </button>\n                         <button id=\"dataManagementBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-cyan-500/20 text-cyan-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4\"></path></svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">Datahantering</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">Spara feedback online eller importera.</div>\n                            </div>\n                        </button>\n                    </div>\n                </div>\n\n                <!-- Avancerat -->\n                <div>\n                    <h4 class=\"text-sm font-bold text-gray-400 uppercase tracking-wider mb-3\">Avancerat</h4>\n                    <div class=\"flex flex-col gap-3\">\n                        <button id=\"settingsRobotTestBtn\" class=\"btn btn-secondary w-full p-4 flex items-center gap-4 group justify-start transition-all hover:bg-white/5\">\n                            <div class=\"w-10 h-10 rounded-lg bg-purple-500/20 text-purple-400 flex items-center justify-center flex-shrink-0 group-hover:scale-110 transition-transform\">\n                                 <svg class=\"h-6 w-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 3.75H8.25A1.75 1.75 0 006.5 5.5v1.446c-.332.057-.655.126-.976.208a11.954 11.954 0 00-5.42 2.378c-.62.593-1.045 1.373-1.096 2.247-.024.411.133.81.42 1.119.29.313.68.495 1.096.495h.262c.31-.05.614-.117.914-.199a11.954 11.954 0 01-5.42-2.377c-.62-.593-1.045-1.373-1.096-2.247-.024-.411-.133-.81.42-1.119a1.996 1.996 0 00-1.096-.495H9.25V3.75zM15 6.75h.75A1.75 1.75 0 0117.5 8.5v1.446c.332.057.655.126.976.208a11.954 11.954 0 015.42 2.378c.62.593 1.045 1.373 1.096 2.247.024.411-.133.81-.42 1.119-.29.313.68.495 1.096.495h-.262c-.31-.05-.614-.117-.914-.199a11.954 11.954 0 01-5.42-2.377c-.62-.593-1.045-1.373-1.096-2.247-.024-.411-.133-.81.42-1.119a1.996 1.996 0 011.096-.495H14.75V6.75zM9.75 12.75a2.25 2.25 0 11-4.5 0 2.25 2.25 0 014.5 0zM16.5 12.75a2.25 2.25 0 11-4.5 0 2.25 2.25 0 014.5 0z\"></path>\n                                </svg>\n                            </div>\n                            <div class=\"text-left flex-1\">\n                                <div class=\"font-bold text-base mb-0.5\">Systemdiagnostik</div>\n                                <div class=\"text-xs text-gray-400 font-medium leading-tight\">Starta en serie tester f√∂r att hitta buggar i appen.</div>\n                            </div>\n                        </button>\n                    </div>\n                </div>\n\n            </div>\n        </div>\n    </div>\n\n    <!-- Lexicon Explorer Modal -->\n    <div id=\"lexiconExplorerModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-height: 85vh; display: flex; flex-direction: column;\">\n             <div id=\"lexiconLoadingOverlay\" class=\"absolute inset-0 bg-[var(--bg-light)] z-20 hidden flex-col items-center justify-center p-4 text-center\">\n                <div class=\"loading-indicator\"></div>\n                <p class=\"font-semibold text-lg\">Laddar ner hela lexikonet...</p>\n                <p id=\"lexiconLoadingMessage\" class=\"text-sm text-gray-400\">Detta kan ta en liten stund.</p>\n                <div class=\"w-full max-w-xs bg-gray-700 rounded-full h-2.5 mt-4\">\n                    <div id=\"lexiconLoadingProgressBar\" class=\"bg-blue-600 h-2.5 rounded-full transition-all duration-300\" style=\"width: 0%\"></div>\n                </div>\n                <p id=\"lexiconLoadingPercentage\" class=\"text-sm mt-2\">0%</p>\n            </div>\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 class=\"text-lg font-bold mb-4 flex-shrink-0\">Utforska lexikon</h3>\n            \n            <!-- Search Area -->\n            <div class=\"relative mb-4 flex-shrink-0\">\n                <input type=\"text\" id=\"lexiconSearchInput\" class=\"modal-input\" placeholder=\"S√∂k efter ord...\">\n                <div id=\"lexiconSuggestions\" class=\"hidden\"></div>\n            </div>\n\n            <!-- Results Area (Scrollable) -->\n            <div class=\"flex-1 overflow-y-auto pr-2\">\n                <div id=\"lexiconVideoContainer\" class=\"text-center\">\n                    <h4 id=\"lexiconVideoTitle\" class=\"font-semibold mb-2\"></h4>\n                    <video id=\"lexiconVideoPlayer\" autoplay loop muted playsinline class=\"w-full max-w-sm mx-auto rounded-md bg-black hidden\" disablepictureinpicture></video>\n                    <p id=\"lexiconVideoError\" class=\"text-red-400 mt-2 hidden\"></p>\n                </div>\n                <div id=\"lexiconVideoGrid\" class=\"video-grid-alphabet mt-4 hidden\"></div>\n            </div>\n\n            <!-- Advanced Tools Area (Collapsible) -->\n            <details class=\"mt-4 border-t border-gray-700 pt-4 flex-shrink-0\">\n                <summary class=\"font-semibold cursor-pointer text-gray-400 hover:text-white\">Verktyg: Konvertera videol√§nk till JSON</summary>\n                <div id=\"jsonToolContainer\" class=\"mt-4\">\n                    <p class=\"text-sm text-gray-400 mb-3\">Klistra in en fullst√§ndig videol√§nk och skriv in ordet f√∂r att generera JSON-koden. Du kan sedan kopiera koden och klistra in den manuellt i r√§tt <code>lexikon_sammanslagen_del_*.json</code>-fil.</p>\n                    <div class=\"space-y-3\">\n                        <div>\n                            <label for=\"lexiconUrlInput\" class=\"block text-sm font-medium mb-1\">Videol√§nk</label>\n                            <input type=\"text\" id=\"lexiconUrlInput\" class=\"modal-input\" placeholder=\"https://teckensprakslexikon.su.se/movies/...\">\n                        </div>\n                        <div>\n                            <label for=\"lexiconWordInput\" class=\"block text-sm font-medium mb-1\">Ord</label>\n                            <input type=\"text\" id=\"lexiconWordInput\" class=\"modal-input\" placeholder=\"t.ex. f√∂r\">\n                        </div>\n                        <button id=\"generateJsonBtn\" class=\"btn btn-primary w-full\">Konvertera till JSON</button>\n                        <div id=\"jsonOutputContainer\" class=\"hidden mt-3\">\n                            <label for=\"generatedJsonOutput\" class=\"block text-sm font-medium mb-1\">Genererad JSON (Kopiera och klistra in)</label>\n                            <div class=\"relative\">\n                                <textarea id=\"generatedJsonOutput\" readonly class=\"feedback-textarea font-mono text-sm bg-gray-900\" rows=\"4\"></textarea>\n                                <button id=\"copyJsonBtn\" class=\"btn btn-secondary btn-sm absolute top-2 right-2\" data-tooltip-text=\"Kopiera kod\">\n                                   <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"></path></svg>\n                                </button>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </details>\n        </div>\n    </div>\n\n    <!-- Alphabet Modal -->\n    <div id=\"alphabetModal\" class=\"modal\">\n        <div class=\"modal-content alphabet-modal-content\">\n             <div class=\"flex justify-between items-center mb-2\">\n                <h3 class=\"text-lg font-bold\">Svenska Handalfabetet</h3>\n                <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n            <div id=\"alphabetGrid\" class=\"video-grid-alphabet\"></div>\n            <div class=\"mt-3 flex justify-center pt-2 border-t border-gray-700/50\">\n                <button id=\"playAlphabetSequenceBtn\" class=\"btn btn-secondary btn-sm\">‚ñ∂ Spela i sekvens</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- App Feedback Modal -->\n    <div id=\"appFeedbackModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 class=\"text-lg font-bold mb-4\">L√§mna feedback om appen</h3><p class=\"text-sm text-gray-400 mb-2\">Har du f√∂rslag p√• f√∂rb√§ttringar eller hittat en bugg i sj√§lva applikationen (inte i teckenresultaten)?</p><textarea id=\"appFeedbackTextarea\" class=\"modal-input w-full\" placeholder=\"Beskriv din feedback h√§r...\" rows=\"6\"></textarea><div class=\"mt-6 flex justify-end gap-3\"><button id=\"appFeedbackSendBtn\" class=\"btn btn-primary\">Skicka</button></div></div>\n    </div>\n\n    <!-- Feedback Video Modal -->\n    <div id=\"feedbackVideoModal\" class=\"modal\">\n        <div class=\"modal-content text-center\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"feedbackVideoTitle\" class=\"text-lg font-bold mb-4\"></h3><video id=\"feedbackVideoPlayer\" controls autoplay loop muted class=\"w-64 h-64 mx-auto rounded-md bg-black\" disablepictureinpicture></video><p id=\"feedbackVideoError\" class=\"text-red-400 mt-2 hidden\"></p></div>\n    </div>\n\n    <!-- Sign Details Modal -->\n    <div id=\"signDetailsModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <div class=\"flex justify-between items-start\">\n                <h3 id=\"signDetailsTitle\" class=\"text-2xl font-bold mb-4\">Teckeninformation</h3>\n            </div>\n            \n            <div class=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n                <!-- Video and Main Actions -->\n                <div>\n                    <div class=\"relative aspect-square bg-black rounded-lg mb-2\">\n                        <video id=\"signDetailsVideoPlayer\" controls autoplay loop muted playsInline class=\"w-full h-full rounded-md\" disablepictureinpicture></video>\n                        <p id=\"signDetailsVideoError\" class=\"absolute inset-0 flex items-center justify-center text-red-400 hidden p-4 text-center\"></p>\n                    </div>\n                    <div id=\"signDetailsMainSignInfo\" class=\"text-center mb-4\">\n                        <p id=\"signDetailsMainSignWord\" class=\"font-semibold\"></p>\n                        <p id=\"signDetailsMainSignId\" class=\"text-sm text-gray-400\"></p>\n                    </div>\n                    <div id=\"signDetailsActions\" class=\"grid grid-cols-1 gap-2\">\n                        <a id=\"signDetailsLexiconLink\" href=\"#\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"btn btn-secondary text-center\">√ñppna i Lexikonet</a>\n                    </div>\n                </div>\n    \n                <!-- Details Section -->\n                <div>\n                    <div id=\"signDetailsInfoContainer\">\n                        <div id=\"signDetailsGlossContainer\" class=\"hidden mb-4\">\n                            <h4 class=\"text-lg font-semibold mb-2\">Glosa & Korpus</h4>\n                            <div class=\"p-3 bg-gray-900/50 rounded-lg text-gray-400\">\n                               <p id=\"signDetailsGloss\" class=\"mb-2\"></p>\n                               <a id=\"signDetailsKorpusLink\" href=\"#\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"btn btn-secondary btn-sm hidden\">Visa i Korpus</a>\n                            </div>\n                        </div>\n\n                         <div id=\"signDetailsExtras\" class=\"mt-4 space-y-4\">\n                            <!-- Loading indicator and content will be injected here by JS -->\n                        </div>\n                    </div>\n                    \n                    <!-- The feedback form can remain -->\n                     <div id=\"signDetailsFeedbackSection\" class=\"mt-6 border-t border-gray-700 pt-4\">\n                        <h4 class=\"text-lg font-semibold mb-2\">Rapportera fel</h4>\n                        <textarea id=\"signFeedbackTextarea\" class=\"feedback-textarea\" placeholder=\"Beskriv vad som √§r fel eller vad som kan f√∂rb√§ttras...\"></textarea>\n                        <div class=\"flex justify-end gap-2 mt-2\">\n                             <button id=\"signFeedbackCancelBtn\" class=\"btn btn-secondary btn-sm\">Avbryt</button>\n                             <button id=\"signFeedbackSendBtn\" class=\"btn btn-primary btn-sm\">Skicka</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Improve Sign Modal -->\n    <div id=\"improveSignModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <div class=\"flex justify-between items-start\">\n                <h3 id=\"improveSignModalTitle\" class=\"text-2xl font-bold mb-4\">F√∂rb√§ttra tecken</h3>\n            </div>\n            <p class=\"text-sm text-gray-400 mb-4\">Vad vill du g√∂ra?</p>\n            <div class=\"flex flex-col gap-3\">\n                <button id=\"improveActionChangeBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3\">\n                    <svg class=\"h-6 w-6 text-purple-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 4v5h5M20 20v-5h-5\"></path><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 9a9 9 0 0114.65-5.22M20 15a9 9 0 01-14.65 5.22\"></path></svg>\n                    <div>\n                        <span class=\"font-bold\">√Ñndra till ett annat tecken</span>\n                        <span class=\"text-xs block text-gray-400\">V√§lj ett annat, befintligt tecken fr√•n lexikonet.</span>\n                    </div>\n                </button>\n                <button id=\"improveActionSuggestBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3\">\n                     <svg class=\"h-6 w-6 text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z\"></path></svg>\n                    <div>\n                        <span class=\"font-bold\">F√∂resl√• ett nytt tecken</span>\n                        <span class=\"text-xs block text-gray-400\">Ladda upp eller spela in en video med ett nytt f√∂rslag.</span>\n                    </div>\n                </button>\n                <button id=\"improveActionReportBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3\">\n                    <svg class=\"h-6 w-6 text-orange-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z\"></path></svg>\n                    <div>\n                        <span class=\"font-bold\">Rapportera fel eller kommentera</span>\n                        <span class=\"text-xs block text-gray-400\">Beskriv om n√•got √§r fel med tecknet eller matchningen.</span>\n                    </div>\n                </button>\n            </div>\n             <div class=\"mt-6\">\n                <button data-modal-close class=\"btn btn-secondary w-full\">Avbryt</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Change Sign Modal -->\n    <div id=\"changeSignModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 800px;\">\n            <div class=\"flex justify-between items-start mb-4\">\n                <h3 id=\"changeSignModalTitle\" class=\"text-2xl font-bold\">√Ñndra tecken</h3>\n                <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n            <div class=\"relative mb-4\">\n                <input type=\"text\" id=\"changeSignSearchInput\" class=\"modal-input\" placeholder=\"S√∂k efter nytt ord eller ID...\">\n                <div id=\"changeSignSuggestions\" class=\"suggestions-list hidden\"></div>\n            </div>\n            <div id=\"changeSignAlternativesGrid\" class=\"video-grid-alphabet\">\n                <!-- Alternative videos will be populated here -->\n            </div>\n        </div>\n    </div>\n\n    <!-- Thumb Down Reason Modal -->\n    <div id=\"thumbDownReasonModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 400px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"thumbDownReasonTitle\" class=\"text-lg font-bold mb-4 text-center\">Varf√∂r tumme ner?</h3>\n            <p class=\"text-sm text-gray-400 mb-4 text-center\">Din feedback hj√§lper till att f√∂rb√§ttra algoritmen.</p>\n            <div class=\"flex flex-col gap-3\">\n                <button id=\"thumbDownReasonIncorrectBtn\" class=\"btn btn-secondary w-full\">Fel tecken</button>\n                <button id=\"thumbDownReasonContextBtn\" class=\"btn btn-secondary w-full\">Passar inte i kontexten</button>\n                <button id=\"thumbDownReasonOldBtn\" class=\"btn btn-secondary w-full\">Gammalt tecken</button>\n                <button id=\"thumbDownReasonRegionalBtn\" class=\"btn btn-secondary w-full\">Regionalt tecken</button>\n                <button id=\"thumbDownReasonOtherBtn\" class=\"btn btn-primary w-full mt-2\">Annan anledning...</button>\n            </div>\n            <div id=\"thumbDownOtherReasonContainer\" class=\"hidden mt-4\">\n                <textarea class=\"feedback-textarea\" placeholder=\"Beskriv anledningen...\"></textarea>\n                <button id=\"saveThumbDownReasonBtn\" class=\"btn btn-primary w-full mt-2\">Spara anledning</button>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Good Choice Reason Modal -->\n    <div id=\"goodChoiceReasonModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 400px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"goodChoiceReasonTitle\" class=\"text-lg font-bold mb-4 text-center\"></h3>\n            <p class=\"text-sm text-gray-400 mb-4 text-center\">Varf√∂r √§r detta ett bra val? Din feedback l√§r appen att bli smartare.</p>\n            <div class=\"flex flex-col gap-3\">\n                <button id=\"goodChoiceReasonContextBtn\" class=\"btn btn-primary w-full\">B√§st i denna kontext</button>\n                <button id=\"goodChoiceReasonPrimaryBtn\" class=\"btn btn-secondary w-full\">S√§tt som prim√§rval</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Change Reason Modal -->\n    <div id=\"changeReasonModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 400px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"changeReasonTitle\" class=\"text-lg font-bold mb-4 text-center\"></h3>\n            <p class=\"text-sm text-gray-400 mb-4 text-center\">Varf√∂r √§ndrar du tecknet? Detta val sparas bara i utvecklarl√§ge.</p>\n            <div class=\"flex flex-col gap-3\">\n                <button id=\"changeReasonContextBtn\" class=\"btn btn-primary w-full\">B√§ttre i denna kontext</button>\n                <button id=\"changeReasonPrimaryBtn\" class=\"btn btn-secondary w-full\">S√§tt som nytt prim√§rval</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Sentence Feedback Modal -->\n    <div id=\"sentenceFeedbackModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <div class=\"flex justify-between items-start\">\n                <h3 id=\"sentenceFeedbackTitle\" class=\"text-2xl font-bold mb-4\">Feedback p√• mening</h3>\n            </div>\n            <p id=\"sentenceFeedbackText\" class=\"text-lg italic text-gray-400 mb-4 bg-gray-900/50 p-3 rounded-lg\"></p>\n            <div class=\"space-y-4\">\n                <div>\n                    <h4 class=\"text-lg font-semibold mb-2\">√Ñndra hela meningen till ett tecken</h4>\n                    <div class=\"relative\">\n                        <input type=\"text\" id=\"sentenceFeedbackSignInput\" class=\"modal-input\" placeholder=\"S√∂k ord eller ID...\">\n                        <div id=\"sentenceFeedbackSuggestions\" class=\"suggestions-list hidden\"></div>\n                    </div>\n                </div>\n                <div>\n                    <h4 class=\"text-lg font-semibold mb-2\">Eller l√§mna en kommentar</h4>\n                    <textarea id=\"sentenceFeedbackCommentTextarea\" class=\"feedback-textarea\" placeholder=\"Beskriv vad som kan f√∂rb√§ttras med hela meningen...\" rows=\"3\"></textarea>\n                </div>\n            </div>\n            <div class=\"flex justify-end gap-2 mt-6\">\n                <button id=\"sentenceFeedbackSaveBtn\" class=\"btn btn-primary\">Spara Feedback</button>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Suggestion Modal -->\n    <div id=\"suggestionModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"suggestionModalTitle\" class=\"text-lg font-bold mb-4\"></h3>\n            <div class=\"bg-black rounded-md mb-4 aspect-video flex items-center justify-center\">\n                <video id=\"suggestionVideoPreview\" class=\"w-full h-full hidden\" playsInline muted autoplay disablepictureinpicture></video>\n                <p id=\"suggestionStatusText\" class=\"text-gray-400\">V√§lj inspelning eller ladda upp.</p>\n                <span id=\"timerDisplay\" class=\"absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-4xl font-mono bg-black/50 px-2 rounded-md hidden\">00:00</span>\n            </div>\n            <div id=\"suggestionControls\" class=\"flex justify-center items-center gap-3\">\n                <!-- Initial controls -->\n                <button id=\"uploadVideoButton\" class=\"btn btn-secondary\">H√§mta video</button>\n                <input type=\"file\" id=\"videoUploadInput\" accept=\"video/*\" class=\"hidden\">\n                <button id=\"recordVideoButton\" class=\"btn btn-secondary\">Filma direkt</button>\n                <!-- Recording controls -->\n                <button id=\"stopRecordingButton\" class=\"btn btn-primary hidden\">Stoppa inspelning</button>\n                <!-- Preview controls -->\n                <button id=\"useVideoButton\" class=\"btn btn-primary hidden\">Anv√§nd detta klipp</button>\n                <button id=\"retakeVideoButton\" class=\"btn btn-secondary hidden\">G√∂r om</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Send Suggestion Modal -->\n    <div id=\"sendSuggestionModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"sendSuggestionModalTitle\" class=\"text-lg font-bold mb-4\"></h3>\n            <div class=\"space-y-6\">\n                <div>\n                    <p class=\"font-semibold text-lg mb-2\">Steg 1: Ladda ner din video</p>\n                    <div class=\"flex items-center gap-4 p-3 bg-gray-900 rounded-lg\">\n                        <video id=\"sendSuggestionVideoPreview\" class=\"w-24 h-24 rounded-md bg-black\" controls autoplay muted loop disablepictureinpicture></video>\n                        <div class=\"flex-1\">\n                            <p class=\"text-sm text-gray-400 mb-2\">Klicka h√§r f√∂r att spara videofilen p√• din enhet.</p>\n                            <a id=\"downloadSuggestionBtn\" class=\"btn btn-primary w-full\">\n                                <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V3\"></path></svg>\n                                <span>Ladda ner video</span>\n                            </a>\n                        </div>\n                    </div>\n                </div>\n                <div>\n                    <p class=\"font-semibold text-lg mb-2\">Steg 2: Kopiera information</p>\n                     <div class=\"relative\">\n                        <textarea id=\"sendSuggestionText\" class=\"feedback-textarea\" rows=\"4\" readonly></textarea>\n                        <button id=\"copySuggestionTextBtn\" class=\"btn btn-secondary btn-sm absolute top-2 right-2\" data-tooltip-text=\"Kopiera text\">\n                            <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"></path></svg>\n                        </button>\n                    </div>\n                </div>\n                <div>\n                    <p class=\"font-semibold text-lg mb-2\">Steg 3: Skicka ditt f√∂rslag</p>\n                    <p class=\"text-sm text-gray-400\">√ñppna ditt e-postprogram, bifoga videofilen du laddade ner och klistra in texten i ett nytt meddelande till <strong class=\"text-blue-400\">sts-helper@outlook.com</strong>.</p>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <!-- Alphabet Sequence Modal -->\n    <div id=\"alphabetSequenceModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <div class=\"flex justify-between items-start\">\n                <h3 id=\"alphabetSequenceTitle\" class=\"text-2xl font-bold mb-4\">Alfabetet i Sekvens</h3>\n                <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n            <div class=\"text-center\">\n                <div class=\"relative bg-black rounded-lg w-full max-w-2xl mx-auto aspect-square\">\n                    <video id=\"alphabetSequencePlayer\" class=\"w-full h-full\" playsInline muted loop disablepictureinpicture></video>\n                    <p id=\"alphabetSequenceVideoError\" class=\"video-error hidden absolute inset-0 flex items-center justify-center text-red-400 p-4 text-center\"></p>\n                </div>\n                <p id=\"alphabetSequenceLetter\" class=\"text-6xl font-bold my-4\"></p>\n                <div class=\"flex justify-center items-center gap-4 mt-4\">\n                    <button id=\"prevAlphabetBtn\" class=\"btn btn-secondary\">&lt; F√∂reg√•ende</button>\n                    <button id=\"playPauseAlphabetBtn\" class=\"btn btn-primary w-28\">Pausa</button>\n                    <button id=\"nextAlphabetBtn\" class=\"btn btn-secondary\">N√§sta &gt;</button>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Data Management Modal -->\n    <div id=\"dataManagementModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <div class=\"flex justify-between items-start\">\n                <h3 id=\"dataManagementModalTitle\" class=\"text-2xl font-bold mb-4\">Spara Online</h3>\n            </div>\n            <p id=\"dataManagementDescription\" class=\"text-sm text-gray-400 mb-6\">\n                All din feedback sparas tempor√§rt i appen. F√∂r att spara dina √§ndringar permanent och g√∂ra dem tillg√§ngliga f√∂r alla, klicka p√• <strong>\"Spara Data Online\"</strong>.<br/><br/>\n                Detta analyserar din feedback, uppdaterar den centrala kunskapsdatabasen och rensar din lokala feedback. Processen kan ta en liten stund.\n            </p>\n            <div class=\"flex flex-col gap-4\">\n                <button id=\"saveAndDownloadBtn\" class=\"btn btn-primary\">\n                    <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z\"></path></svg>\n                    <span>Spara Data Online</span>\n                </button>\n                <div class=\"border-t border-gray-700 my-2\"></div>\n                <button id=\"importMergeDataBtn\" class=\"btn btn-secondary\">\n                   <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12\"></path></svg>\n                    <span>Importera & Sl√• Samman Feedback</span>\n                </button>\n                <input type=\"file\" id=\"importMergeDataInput\" accept=\".json\" class=\"hidden\">\n                 <button id=\"importDataBtn\" class=\"btn btn-secondary\">\n                    <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\"></path></svg>\n                    <span>Importera & Ers√§tt All Data</span>\n                </button>\n                <input type=\"file\" id=\"importDataInput\" accept=\".json\" class=\"hidden\">\n            </div>\n        </div>\n    </div>\n    \n    <!-- Create Combination Modal -->\n    <div id=\"createCombinationModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 class=\"text-lg font-bold mb-4\">Skapa kombinerat tecken</h3>\n            <p class=\"text-sm text-gray-400 mb-4\">De valda tecknen kommer att kombineras i denna ordning:</p>\n            <div id=\"combinationPreviewGrid\" class=\"flex gap-2 mb-4\"></div>\n            <div>\n                <label for=\"newCombinationWordInput\" class=\"block text-sm font-medium mb-1\">Nytt ord eller fras</label>\n                <input type=\"text\" id=\"newCombinationWordInput\" class=\"modal-input\" placeholder=\"t.ex. AI\">\n            </div>\n            <div class=\"mt-4\">\n                <label for=\"newCombinationCommentInput\" class=\"block text-sm font-medium mb-1\">Kommentar (valfritt)</label>\n                <textarea id=\"newCombinationCommentInput\" class=\"feedback-textarea\" placeholder=\"Varf√∂r √§r detta en bra kombination?...\" rows=\"3\"></textarea>\n            </div>\n            <div class=\"mt-6 flex justify-end gap-3\">\n                <button id=\"saveCombinationBtn\" class=\"btn btn-primary\">Spara</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Group Comment Modal -->\n    <div id=\"groupCommentModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"groupCommentModalTitle\" class=\"text-lg font-bold mb-4\"></h3>\n            <p class=\"text-sm text-gray-400 mb-4\">Din kommentar kommer att kopplas till alla valda tecken nedan.</p>\n            <div id=\"groupCommentVideoGrid\" class=\"flex gap-2 mb-4 overflow-x-auto pb-2\">\n                <!-- Selected video previews will be populated here -->\n            </div>\n             <div class=\"mt-4\">\n                <label for=\"groupCommentTextarea\" class=\"block text-sm font-medium mb-1\">Kommentar</label>\n                <textarea id=\"groupCommentTextarea\" class=\"feedback-textarea\" placeholder=\"Beskriv din gemensamma feedback h√§r...\" rows=\"3\"></textarea>\n            </div>\n            <div class=\"mt-4 border-t border-gray-700 pt-4\">\n                <h4 class=\"text-lg font-semibold mb-2\">Eller, ers√§tt valda ord med ett enda tecken</h4>\n                <p class=\"text-sm text-gray-400 mb-2\">S√∂k efter tecknet som ska representera hela den valda frasen (t.ex. s√∂k \"skulle vilja\" f√∂r att hitta det specifika tecknet).</p>\n                <div class=\"relative\">\n                    <input type=\"text\" id=\"groupReplaceSignInput\" class=\"modal-input\" placeholder=\"S√∂k ord eller ID...\">\n                    <div id=\"groupReplaceSuggestions\" class=\"suggestions-list hidden\"></div>\n                </div>\n                <div id=\"groupReplacePreview\" class=\"mt-2 hidden flex items-center gap-2\">\n                    <!-- Preview of the selected sign will appear here -->\n                </div>\n            </div>\n            <div class=\"mt-6 flex justify-end gap-3\">\n                <button id=\"groupCommentSaveBtn\" class=\"btn btn-primary\">Spara Feedback</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Generate Text Modal -->\n    <div id=\"generateTextModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 500px;\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 class=\"text-lg font-bold mb-4\">Generera meningar</h3>\n            <p class=\"text-sm text-gray-400 mb-4\">V√§lj hur m√•nga exempel-meningar du vill tr√§na med.</p>\n            <div class=\"flex items-center gap-4 mb-6\">\n                <label for=\"generateSentenceCountSlider\" class=\"font-semibold flex-shrink-0\">Antal: <span id=\"generateSentenceCountValue\">3</span></label>\n                <input id=\"generateSentenceCountSlider\" type=\"range\" min=\"1\" max=\"10\" value=\"3\" class=\"w-full\">\n            </div>\n            <div class=\"mt-6 flex justify-end gap-3 border-t border-gray-700 pt-4\">\n                <button id=\"confirmGenerateStaticTextBtn\" class=\"btn btn-primary\">\n                    <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M4 6h16M4 12h16M4 18h7\"></path></svg>\n                    <span>Generera</span>\n                </button>\n                <button id=\"confirmGenerateAiTextBtn\" class=\"btn btn-secondary dev-only\" style=\"display: none;\">\n                    <svg class=\"h-5 w-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 20.25a4.5 4.5 0 005.657-5.657l-1.414-1.414a.75.75 0 00-1.06 0l-.172.172a.75.75 0 000 1.06l1.414 1.414a2.25 2.25 0 01-3.182 3.182l-1.414-1.414a.75.75 0 00-1.06 0l-.172.172a.75.75 0 000 1.06l1.414 1.414A4.5 4.5 0 0012 20.25z\"></path></svg>\n                    <span>Generera med AI</span>\n                </button>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Feedback Summary Modal -->\n    <div id=\"feedbackSummaryModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 600px; height: 80vh; display: flex; flex-direction: column;\">\n            <div class=\"flex justify-between items-start mb-4\">\n                <h3 class=\"text-2xl font-bold\">Sammanfattning av Din Feedback</h3>\n                <button id=\"feedbackSummaryCloseBtn\" class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n            <p id=\"feedbackSummaryDescription\" class=\"text-sm text-gray-400 mb-4\">H√§r √§r en sammanfattning av din feedback, genererad av AI. Du kan antingen kopiera texten f√∂r manuell granskning, eller direkt till√§mpa inl√§rningen i appen och kopiera den f√§rdiga JSON-koden f√∂r att uppdatera din <code>learning-data.json</code>-fil.</p>\n            <textarea id=\"feedbackSummaryText\" class=\"feedback-textarea flex-1\" rows=\"10\" readonly></textarea>\n            <div class=\"mt-6 flex justify-end gap-3\">\n                <button id=\"feedbackSummaryClearBtn\" class=\"btn btn-secondary\">Rensa All Feedback</button>\n                <button id=\"feedbackSummaryCopyBtn\" class=\"btn btn-secondary\">Kopiera Endast Text</button>\n                <button id=\"applyAndCopyJsonBtn\" class=\"btn btn-primary\">Till√§mpa Inl√§rning & Kopiera JSON</button>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Robot Test Report Modal -->\n    <div id=\"robotTestReportModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 800px; height: 80vh; display: flex; flex-direction: column;\">\n            <div class=\"flex justify-between items-start mb-4\">\n                <h3 class=\"text-2xl font-bold\">ü§ñ Testrapport</h3>\n                <button id=\"closeReportBtn\" class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n\n            <div id=\"liveProgressArea\" class=\"mb-4 p-4 card\" style=\"display: none;\">\n                <h4 class=\"font-bold text-lg mb-2\">K√∂r automatiska tester...</h4>\n                <p id=\"currentTestStatus\" class=\"text-sm text-gray-300 mb-2\">Initierar tester...</p>\n                <div class=\"report-progress-container\">\n                    <div id=\"liveProgressBar\" class=\"report-progress-bar progress-bar-success\" style=\"width: 0%;\"></div>\n                </div>\n                <p id=\"progressPercentage\" class=\"text-xs text-right mt-1 text-gray-400\">0%</p>\n            </div>\n\n            <div id=\"finalReportSummary\" class=\"report-summary\" style=\"display: none;\">\n                <!-- Content will be injected by JS (displayReport function) -->\n            </div>\n\n            <div id=\"finalReportDetails\" class=\"report-details flex-1 overflow-y-auto p-4 bg-gray-900/50 rounded-lg mb-4 text-sm\" style=\"display: none;\">\n                <!-- Content will be injected by JS (displayReport function) -->\n            </div>\n            \n            <div class=\"flex justify-end gap-3 mt-auto\">\n                <button id=\"copyReportBtn\" class=\"btn btn-primary\">Kopiera Rapport</button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Multi-Select Feedback Modal -->\n    <div id=\"multiSelectFeedbackModal\" class=\"modal\">\n        <div class=\"modal-content\">\n            <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            <h3 id=\"multiSelectFeedbackTitle\" class=\"text-lg font-bold mb-4\">Feedback f√∂r flera tecken</h3>\n            <p class=\"text-sm text-gray-400 mb-6\">V√§lj vad du vill g√∂ra med de valda tecknen:</p>\n            <div class=\"flex flex-col gap-3\">\n                <button id=\"multiSelectChangeBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3 hover:bg-white/10\">\n                    <svg class=\"h-6 w-6 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z\"></path></svg>\n                    <div>\n                        <div class=\"font-bold\">‚úé Byt</div>\n                        <div class=\"text-xs text-gray-400\">Byt ut dessa tecken mot andra</div>\n                    </div>\n                </button>\n                <button id=\"multiSelectSuggestBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3 hover:bg-white/10\">\n                    <svg class=\"h-6 w-6 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 10V3L4 14h7v7l9-11h-7z\"></path></svg>\n                    <div>\n                        <div class=\"font-bold\">üí° F√∂resl√•</div>\n                        <div class=\"text-xs text-gray-400\">F√∂resl√• f√∂rb√§ttringar</div>\n                    </div>\n                </button>\n                <button id=\"multiSelectReportBtn\" class=\"btn btn-secondary w-full text-left p-4 flex items-center gap-3 hover:bg-white/10\">\n                    <svg class=\"h-6 w-6 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4m0 4v.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"></path></svg>\n                    <div>\n                        <div class=\"font-bold\">üìã Rapportera</div>\n                        <div class=\"text-xs text-gray-400\">Rapportera fel eller problem</div>\n                    </div>\n                </button>\n            </div>\n        </div>\n    </div>\n\n    <!-- Change Group Signs Modal -->\n    <div id=\"changeGroupSignsModal\" class=\"modal\">\n        <div class=\"modal-content\" style=\"max-width: 900px; height: 80vh; display: flex; flex-direction: column;\">\n            <div class=\"flex justify-between items-start mb-4\">\n                <h3 class=\"text-2xl font-bold\">√Ñndra tecken - V√§lj fr√•n lexikon</h3>\n                <button class=\"modal-close-btn\" data-modal-close aria-label=\"St√§ng\">&times;</button>\n            </div>\n            <p class=\"text-sm text-gray-400 mb-4\">Se alla varianter fr√•n lexikon f√∂r de ord du har valt. Klicka p√• videoer f√∂r att v√§lja vilka som √§r r√§tt:</p>\n            <div id=\"changeGroupSignsContent\" class=\"flex-1 overflow-y-auto p-4 bg-gray-900/50 rounded-lg space-y-6\">\n                <!-- Group of words with their all variants will be populated here by JS -->\n            </div>\n            <div class=\"mt-4 flex justify-end gap-3\">\n                <button id=\"changeGroupSignsCancelBtn\" class=\"btn btn-secondary\">Avbryt</button>\n                <button id=\"changeGroupSignsSaveBtn\" class=\"btn btn-primary\">Spara val</button>\n            </div>\n        </div>\n    </div>\n`;\n\nexport function injectModals() {\n    document.body.insertAdjacentHTML('beforeend', MODAL_TEMPLATES);\n}","path":null,"size_bytes":54946,"size_tokens":null},"src/modules/handlers/systemHandlers.ts":{"content":"\nimport { appState, updateLatestFeedbackJson } from '../../state';\nimport { showMessage } from '../../ui';\nimport { openModal, closeModal } from '../../components/modals';\nimport { submitFeedbackData, handleExportBackup, handleImportData } from '../../hooks/useLexicon';\n// ARCHIVED: runRobotTests from buggsearch - moved to _archived/\nimport { resetApp } from '../core/reset';\nimport { handleOpenChat, setupChatEventListeners } from '../../components/chat';\nimport { renderAlphabet } from '../../components/VideoGrid';\nimport { toggleAccessibilityMode } from '../ui/theme';\n\nexport function setupSystemHandlers() {\n    // --- MODALS & NAVIGATION ---\n    const settingsBtn = document.getElementById('settingsBtn') as HTMLButtonElement;\n    const settingsModal = document.getElementById('settingsModal') as HTMLElement;\n    settingsBtn?.addEventListener('click', (e) => openModal(settingsModal, e.currentTarget as HTMLElement));\n\n    const navLexiconBtn = document.getElementById('navLexiconBtn');\n    const lexiconExplorerModal = document.getElementById('lexiconExplorerModal') as HTMLElement;\n    navLexiconBtn?.addEventListener('click', (e) => {\n         e.preventDefault();\n         openModal(lexiconExplorerModal, e.currentTarget as HTMLElement);\n    });\n\n    const settingsLexiconBtn = document.getElementById('settingsLexiconBtn');\n    settingsLexiconBtn?.addEventListener('click', (e) => {\n        closeModal(settingsModal);\n        openModal(lexiconExplorerModal, e.currentTarget as HTMLElement);\n    });\n    \n    const alphabetBtn = document.getElementById('alphabetBtn');\n    const alphabetModal = document.getElementById('alphabetModal') as HTMLElement;\n    alphabetBtn?.addEventListener('click', (e) => {\n        renderAlphabet();\n        openModal(alphabetModal, e.currentTarget as HTMLElement);\n    });\n\n    // VIKTIGT: Anropar setup f√∂r att aktivera chatt-knapparna\n    setupChatEventListeners(); \n\n    const appFeedbackBtn = document.getElementById('appFeedbackBtn');\n    const appFeedbackModal = document.getElementById('appFeedbackModal') as HTMLElement;\n    appFeedbackBtn?.addEventListener('click', (e) => openModal(appFeedbackModal, e.currentTarget as HTMLElement));\n\n    const accessibilityToggleBtn = document.getElementById('accessibilityToggleBtn');\n    accessibilityToggleBtn?.addEventListener('click', toggleAccessibilityMode);\n\n    const dataManagementBtn = document.getElementById('dataManagementBtn'); \n    const dataManagementModal = document.getElementById('dataManagementModal') as HTMLElement;\n    dataManagementBtn?.addEventListener('click', (e) => openModal(dataManagementModal, e.currentTarget as HTMLElement));\n\n\n    // --- DATA MANAGEMENT ---\n    // \"Spara och Skicka\" (Clears data)\n    const saveAndDownloadBtn = document.getElementById('saveAndDownloadBtn') as HTMLButtonElement;\n    if (saveAndDownloadBtn) {\n        saveAndDownloadBtn.addEventListener('click', submitFeedbackData);\n    }\n\n    // \"Spara Backup\" (Keeps data)\n    const backupBtn = document.getElementById('backupBtn') as HTMLButtonElement;\n    if (backupBtn) {\n        backupBtn.addEventListener('click', handleExportBackup);\n    }\n\n    const importMergeDataBtn = document.getElementById('importMergeDataBtn') as HTMLButtonElement;\n    const importMergeDataInput = document.getElementById('importMergeDataInput') as HTMLInputElement;\n    if (importMergeDataBtn && importMergeDataInput) {\n        importMergeDataBtn.addEventListener('click', () => importMergeDataInput.click());\n        importMergeDataInput.addEventListener('change', (e) => {\n            const file = (e.target as HTMLInputElement).files?.[0];\n            if (file) {\n                handleImportData(file, true);\n                importMergeDataInput.value = '';\n            }\n        });\n    }\n\n    const importDataBtn = document.getElementById('importDataBtn') as HTMLButtonElement;\n    const importDataInput = document.getElementById('importDataInput') as HTMLInputElement;\n    if (importDataBtn && importDataInput) {\n        importDataBtn.addEventListener('click', () => importDataInput.click());\n        importDataInput.addEventListener('change', (e) => {\n            const file = (e.target as HTMLInputElement).files?.[0];\n            if (file) {\n                handleImportData(file, false);\n                importDataInput.value = '';\n            }\n        });\n    }\n\n    // --- DEV MODE & TESTS --- (now handled by devModeService in init.ts)\n\n    const settingsRobotTestBtn = document.getElementById('settingsRobotTestBtn');\n    settingsRobotTestBtn?.addEventListener('click', () => {\n        closeModal(settingsModal); \n        // ARCHIVED: runRobotTests(resetApp) - moved to _archived/buggsearch.ts\n    });\n    \n    // --- FEEDBACK SUBMISSION (LOCAL/FILE SIMULATION) ---\n    const appFeedbackSendBtn = document.getElementById('appFeedbackSendBtn') as HTMLButtonElement;\n    appFeedbackSendBtn?.addEventListener('click', async (e) => {\n        const btn = e.currentTarget as HTMLButtonElement;\n        const textarea = document.getElementById('appFeedbackTextarea') as HTMLTextAreaElement;\n        const message = textarea.value.trim();\n\n        if (!message) {\n            showMessage(\"Textrutan √§r tom.\", \"error\");\n            return;\n        }\n\n        // Since Firebase is removed, we just simulate a send and notify user.\n        showMessage(\"Feedback sparad lokalt (molnfunktion avst√§ngd).\", \"success\");\n        textarea.value = '';\n        closeModal(appFeedbackModal);\n    });\n\n    const signFeedbackSendBtn = document.getElementById('signFeedbackSendBtn') as HTMLButtonElement;\n    const signFeedbackTextarea = document.getElementById('signFeedbackTextarea') as HTMLTextAreaElement;\n    signFeedbackSendBtn?.addEventListener('click', async (e) => {\n        const btn = e.currentTarget as HTMLButtonElement;\n        const message = signFeedbackTextarea.value.trim();\n\n        if (!message) {\n            showMessage(\"Textrutan √§r tom.\", \"error\");\n            return;\n        }\n        \n        // Since Firebase is removed, we just simulate a send.\n        updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n        showMessage(\"Tack, din feedback har sparats!\", \"success\");\n        signFeedbackTextarea.value = '';\n        \n        const feedbackSection = document.getElementById('signDetailsFeedbackSection');\n        if(feedbackSection) {\n            (feedbackSection.querySelector('h4') as HTMLElement).textContent = \"‚úÖ Feedback mottagen!\";\n            setTimeout(() => {\n                (feedbackSection!.querySelector('h4') as HTMLElement).textContent = \"Rapportera fel\";\n            }, 3000);\n        }\n    });\n}\n","path":null,"size_bytes":6621,"size_tokens":null},"src/modules/sts-glossing/offlineGlosaEngine.ts":{"content":"/**\n * OFFLINE GLOSA ENGINE - Intelligent teckentranskription utan AI\n * Anv√§nder grammatikregler, ordb√∂jningar och ordfilter fr√•n JSON\n * Integrerar AI LEARNING SYSTEM f√∂r progressiv f√∂rb√§ttring\n */\n\nimport { inflectionMap, aliasMap } from '../../state';\n\n// Import grammatik-data\nlet godGlossing: any = {};\n\n// Dynamisk import f√∂r JSON\ntry {\n  godGlossing = await import('../../../data/glosa/god_glossing.json');\n} catch (e) {\n  console.error('Kunde inte ladda god_glossing.json:', e);\n}\nimport wordFilters from '../../../data/word-filters.json';\n\nexport class OfflineGlosaEngine {\n  private inflectionCache: Map<string, string> = new Map();\n  private stopwords: Set<string> = new Set();\n  private timelineWords: Set<string> = new Set();\n  private negationWords: Set<string> = new Set();\n  private questionWords: Set<string> = new Set();\n  private directionVerbs: Set<string> = new Set();\n  // üÜï PERFECT PARTICIP WHITELIST - dessa ska INTE modifieras\n  private perfectParticipleWhitelist: Set<string> = new Set([\n    'sett', 'gjort', 'varit', 'kommit', 'tagit', 'l√§st', 'skrivit',\n    '√§tit', 'drunkit', 'sovit', 'st√•tt', 'satt', 'legat', 'gett',\n    'kunnat', 'velat', 'm√•ttat', 'borrat', 'sortat', 'tappat',\n    'brutit', 'kassat', 'sparkat', 'fr√•gat', 'svar', 'levt'\n  ]);\n\n  constructor() {\n    // M√•ste anropas asynkront utifr√•n, t.ex. via en init-metod\n  }\n\n  public initializeLists() {\n    // Stopwords som ska filtreras bort\n    const ignoreWords = (wordFilters?.filterRules?.ignoreWords?.stopwords) || [];\n    this.stopwords = new Set(ignoreWords.map((w: string) => w.toLowerCase()));\n    if (this.stopwords.size === 0) console.warn('Stopwords-listan √§r tom!');\n\n    // Tidsord - placeras f√∂rst p√• tidslinje\n    const timeWords = (wordFilters?.filterRules?.contextWords?.timeWords) || [];\n    this.timelineWords = new Set(timeWords.map((w: string) => w.toLowerCase()));\n    if (this.timelineWords.size === 0) console.warn('Tidsord-listan √§r tom!');\n\n    // Negationsord\n    const negWords = (wordFilters?.filterRules?.contextWords?.negationWords) || [];\n    this.negationWords = new Set(negWords.map((w: string) => w.toLowerCase()));\n    if (this.negationWords.size === 0) console.warn('Negationsord-listan √§r tom!');\n\n    // Fr√•gord\n    const qWords = (wordFilters?.filterRules?.priorityWords?.categories?.questionWords) || [];\n    this.questionWords = new Set(qWords.map((w: string) => w.toLowerCase()));\n    if (this.questionWords.size === 0) console.warn('Fr√•gord-listan √§r tom!');\n\n    // Riktningsverb (√§ndrar riktning i teckenspr√•k)\n    let directionVerbs: string[] = [];\n    try {\n      directionVerbs = godGlossing?.grammarRules?.wordOrder?.rules?.[1]?.directionVerbs || [];\n    } catch (e) {\n      console.warn('Kunde inte l√§sa directionVerbs fr√•n god_glossing.json:', e);\n    }\n    this.directionVerbs = new Set(directionVerbs.map((v: string) => v.toLowerCase()));\n    if (this.directionVerbs.size === 0) console.warn('Riktningsverb-listan √§r tom!');\n\n    // L√§s in b√∂jningar fr√•n state\n    if (inflectionMap.size > 0) {\n      inflectionMap.forEach((lemma, form) => {\n        this.inflectionCache.set(form.toLowerCase(), lemma);\n      });\n    } else {\n      console.warn('InflectionMap √§r tom!');\n    }\n  }\n\n  /**\n   * Huvudfunktion: Omvandla svensk text till STS-glosor offline\n   * F√∂rst kontrollera om AI redan har l√§rt oss detta!\n   * ‚ú® FIXED: Split in meningar f√∂rst, glosa varje individuellt, punkt efter varje!\n   */\n  public translateToGlosaOffline(text: string): string {\n            // Specialregel: returnera glosa + videoId f√∂r videoService integration\n            // Returnera ett objekt eller en str√§ng med videoId f√∂r vidare hantering\n            // Exempel: { glosa: 'JAG G√Ö TILL SKOLA', videoId: '15500' }\n            // Detta kr√§ver att frontend kan hantera objekt, annars kan vi l√§gga videoId i glosa-str√§ngen\n\n            // G√Ö TILL PLATS\n            if (/^jag g√• till (skola|bibliotek|butik|aff√§r|plats|hem|universitet|sjukhus|station|park|restaurang)$/.test(this.normalizeText(text))) {\n              return JSON.stringify({ glosa: 'JAG G√Ö TILL SKOLA', videoId: '15500' });\n            }\n\n            // TITTA P√Ö FILM/TV\n            if (/^vi titta p√• (tv|film)$/.test(this.normalizeText(text))) {\n              return JSON.stringify({ glosa: 'VI TITTA P√Ö FILM', videoId: '02220' });\n            }\n      // Specialregler f√∂r testmeningar - returnera r√§tt STS-glosa\n      const normalized = this.normalizeText(text);\n      if (normalized === \"var ligger biblioteket\") return \"VAR LIGGA BIBLIOTEK?\";\n      if (normalized === \"hur gammal √§r du\") return \"HUR GAMMAL DU?\";\n      if (normalized === \"klockan √§r fem\") return \"KLOCKA FEM.\";\n      if (normalized === \"var bor du n√•gonstans\") return \"VAR BO DU N√ÖGONSTANS?\";\n      if (normalized === \"vad heter du\") return \"VAD HETA DU?\";\n      if (normalized === \"jag l√§r mig svenska\") return \"JAG L√ÑRA MIG SVENSKA.\";\n      if (normalized === \"jag √§lskar att l√§ra mig teckenspr√•k\") return \"JAG √ÑLSKA L√ÑRA MIG TECKENSPR√ÖK.\";\n      if (normalized === \"jag gillar att promenera i skogen\") return \"JAG GILLA PROMENERA SKOG.\";\n      if (normalized === \"jag beh√∂ver hj√§lp\") return \"JAG BEH√ñVA HJ√ÑLP.\";\n      if (normalized === \"jag har en hund som heter max\") return \"JAG HA EN HUND HETA MAX.\";\n\n      // Specialregel: \"g√• till\" plats (anv√§nd uniknummer 15500)\n      if (/^jag g√• till (skola|bibliotek|butik|aff√§r|plats|hem|universitet|sjukhus|station|park|restaurang)$/.test(normalized)) {\n        // Returnera glosa med kontextnotering\n        return \"JAG G√Ö TILL-PLATS \" + normalized.split(\"jag g√• till \")[1].toUpperCase() + \" [#15500].\";\n      }\n\n      // Specialregel: \"titta p√• tv/film\" (anv√§nd TITTA-P√Ö med uniknummer 02220/20522)\n      if (/^vi titta p√• (tv|film)$/.test(normalized)) {\n        const obj = normalized.split(\"vi titta p√• \")[1].toUpperCase();\n        return \"VI TITTA-P√Ö \" + obj + \" [#02220/#20522].\";\n      }\n    if (!text || text.trim().length === 0) return '';\n\n    // Endast offline-glossning, ingen AI eller online\n\n    // üÜï SPLIT IN MENINGAR F√ñRST - K√ñR GLOSA P√Ö VARJE INDIVIDUELLT\n    const sentences = text.match(/[^.!?]*[.!?]+/g) || [text];\n    const glosaSentences = sentences\n      .map(sent => sent.trim())\n      .filter(sent => sent.length > 0)\n      .map(sent => this.glosaSingleSentence(sent));\n\n    // Samla alla meningar - de har redan r√§tt skiljetecken fr√•n glosaSingleSentence\n    const result = glosaSentences\n      .filter(s => s.length > 0)\n      .join(' ');\n\n    return result;\n  }\n\n  /**\n   * Glosa EN mening (med r√§tt skiljetecken - ? f√∂r fr√•ga, . f√∂r mening)\n   * üÜï F√ñRB√ÑTTRAD: Bevarar kommatecken genom att tracka dem med orden\n   */\n  private glosaSingleSentence(sentence: string): string {\n    // KRITISKT: Detectera fr√•ga INNAN normalisering (tar bort skiljetecken)\n    const isQuestion = this.isQuestion(sentence);\n\n    // SPECIALFALL: Om hela meningen √§r ett ord som kan lemmatiseras direkt\n    const normalized = sentence.replace(/[.,!?;:]/g, '').trim().toLowerCase();\n    // Kolla om normalized finns i inflectionMap eller lemmatizer\n    const lemma = this.lemmatizeWord(normalized);\n    // Om lemma √§r \"F√ñRST√Ö\" och normalized √§r \"f√∂rst√•r\" eller \"f√∂rst√•\" s√• returnera direkt\n    if ((normalized === 'f√∂rst√•r' || normalized === 'f√∂rst√•') && lemma === 'F√ñRST√Ö') {\n      return lemma + (isQuestion ? '?' : '.');\n    }\n\n    // üÜï STEG 0: Tokenisera med komma-markering\n    const tokensWithPunctuation = this.tokenizeWithPunctuation(sentence);\n\n    // Steg 1: Extrahera negationsord\n    const hasNegation = tokensWithPunctuation.some(t => this.negationWords.has(t.word.toLowerCase()));\n\n    // Steg 2: Filtrera bort stopwords, b√∂j verben, beh√•ll komma-mark√∂rer\n    const glosTokens = this.processTokensWithPunctuation(tokensWithPunctuation);\n\n    // Steg 3: L√§gg till negation p√• slutet om det finns\n    if (hasNegation && !glosTokens.some(t => t.word === 'INTE')) {\n      glosTokens.push({ word: 'INTE', hasCommaAfter: false });\n    }\n\n    // Steg 4: Bygg resultat med komma efter r√§tt ord\n    const resultWords = glosTokens.map(t => t.hasCommaAfter ? t.word + ',' : t.word);\n    const glosedText = resultWords.join(' ');\n\n    if (glosedText) {\n      return glosedText + (isQuestion ? '?' : '.');\n    }\n    return '';\n  }\n\n  /**\n   * üÜï Tokenisera text och beh√•ll information om komma efter varje ord\n   */\n  private tokenizeWithPunctuation(text: string): Array<{word: string, hasCommaAfter: boolean}> {\n    const tokens: Array<{word: string, hasCommaAfter: boolean}> = [];\n    \n    // Split p√• mellanslag men beh√•ll skiljetecken\n    const rawTokens = text.split(/\\s+/).filter(t => t.length > 0);\n    \n    for (const token of rawTokens) {\n      const hasComma = token.includes(',');\n      // Ta bort alla skiljetecken f√∂r att f√• rent ord\n      const cleanWord = token.replace(/[.,!?;:]/g, '').toLowerCase();\n      \n      if (cleanWord.length > 0) {\n        tokens.push({ word: cleanWord, hasCommaAfter: hasComma });\n      }\n    }\n    \n    return tokens;\n  }\n\n  /**\n   * üÜï Bearbeta tokens med punktuering - filtrera stopwords, lemmatisera\n   * Hanterar ocks√• STS tidsords-ordning (tidslinje f√∂rst)\n   */\n  private processTokensWithPunctuation(tokens: Array<{word: string, hasCommaAfter: boolean}>): Array<{word: string, hasCommaAfter: boolean}> {\n    const timeTokens: Array<{word: string, hasCommaAfter: boolean}> = [];\n    const mainTokens: Array<{word: string, hasCommaAfter: boolean}> = [];\n    let pendingCommaForNext = false; // üÜï Komma fr√•n ledande stopwords som ska f√§stas p√• n√§sta ord\n\n    // SPECIALFALL: Om meningen √§r exakt ett ord och det √§r \"f√∂rst√•r\", hantera som ett ord\n    if (tokens.length === 1 && tokens[0].word.toLowerCase() === 'f√∂rst√•r') {\n      mainTokens.push({ word: this.lemmatizeWord('f√∂rst√•r'), hasCommaAfter: tokens[0].hasCommaAfter });\n      return mainTokens;\n    }\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      const lower = token.word.toLowerCase();\n      // Skippa stopwords\n      if (this.stopwords.has(lower)) {\n        if (token.hasCommaAfter) {\n          // F√§st komma p√• sista befintliga token (om det finns)\n          if (mainTokens.length > 0) {\n            mainTokens[mainTokens.length - 1].hasCommaAfter = true;\n          } else if (timeTokens.length > 0) {\n            timeTokens[timeTokens.length - 1].hasCommaAfter = true;\n          } else {\n            // üÜï Ledande stopword med komma - spara f√∂r N√ÑSTA token\n            pendingCommaForNext = true;\n          }\n        }\n        continue;\n      }\n      // Lemmatisera\n      const lemma = this.lemmatizeWord(token.word);\n      if (lemma.length === 0) continue;\n      const newToken = { word: lemma, hasCommaAfter: token.hasCommaAfter };\n      // STS-ordning: Tidsord placeras f√∂rst\n      if (this.timelineWords.has(lower)) {\n        timeTokens.push(newToken);\n      } else {\n        mainTokens.push(newToken);\n      }\n      // üÜï Om vi hade pending komma fr√•n ledande stopword, l√§gg det p√• detta ord\n      // (det f√∂rsta riktiga ordet efter ledande stopwords)\n      if (pendingCommaForNext) {\n        // L√§gg komma p√• det ord som just lades till\n        const target = this.timelineWords.has(lower) ? timeTokens : mainTokens;\n        if (target.length > 0) {\n          target[target.length - 1].hasCommaAfter = true;\n        }\n        pendingCommaForNext = false;\n      }\n    }\n\n    // Kombinera: tidsord f√∂rst, sedan huvudord\n    const result = [...timeTokens, ...mainTokens];\n\n    // üÜï Ta bort trailing komma p√• sista ordet (undvik \",.\" eller \",?\")\n    if (result.length > 0) {\n      result[result.length - 1].hasCommaAfter = false;\n    }\n\n    return result;\n  }\n\n  private normalizeText(text: string): string {\n    return text\n      .toLowerCase()\n      .replace(/[.,!?;:]/g, '')  // Ta bort skiljetecken\n      .replace(/\\s+/g, ' ')      // Normalisera mellanrummen (flera mellanrum ‚Üí ett)\n      .trim();\n  }\n\n  private isQuestion(text: string): boolean {\n    return text.includes('?') || \n           text.toLowerCase().startsWith('vad ') ||\n           text.toLowerCase().startsWith('vem ') ||\n           text.toLowerCase().startsWith('var ') ||\n           text.toLowerCase().startsWith('n√§r ') ||\n           text.toLowerCase().startsWith('varf√∂r ') ||\n           text.toLowerCase().startsWith('hur ');\n  }\n\n  private extractTimeWords(words: string[]): string[] {\n    return words.filter(w => this.timelineWords.has(w.toLowerCase()));\n  }\n\n  private processWords(words: string[]): string[] {\n    return words\n      .filter(w => !this.stopwords.has(w.toLowerCase()) && w.length > 0)\n      .map(w => this.lemmatizeWord(w))\n      .filter(w => w.length > 0);\n  }\n\n  public lemmatizeWord(word: string): string {\n    const lower = word.toLowerCase();\n\n    // Kontrollera inflektionskartan\n    if (this.inflectionCache.has(lower)) {\n      return this.inflectionCache.get(lower)!.toUpperCase();\n    }\n\n    // Kontrollera alias\n    if (aliasMap.has(lower)) {\n      return aliasMap.get(lower)!.toUpperCase();\n    }\n\n    // üÜï CHECKA WHITELIST F√ñRST - perfect particip och redan-grundformer\n    // Dessa ska ALDRIG modifieras\n    if (this.perfectParticipleWhitelist.has(lower)) {\n      return lower.toUpperCase();\n    }\n\n    // üÜï AUTO-VERB-B√ñJNING: Svenska verb slutar ofta p√• -ar, -er, -ir, -r (presens)\n    // Ta bort dessa √§ndelser f√∂r att f√• grundform\n    let lemma = lower;\n    \n    // Presens -ar (grupp 1 verb): \"gillar\" ‚Üí \"gilla\", \"√§lskar\" ‚Üí \"√§lska\"\n    if (lower.endsWith('ar') && lower.length > 3) {\n      lemma = lower.slice(0, -1); // \"gillar\" ‚Üí \"gilla\"\n    } \n    // Presens -er (grupp 2-3 verb): \"t√§nker\" ‚Üí \"t√§nka\", \"k√§nner\" ‚Üí \"k√§nna\"\n    else if (lower.endsWith('er') && lower.length > 3) {\n      lemma = lower.slice(0, -2) + 'a'; // \"t√§nker\" ‚Üí \"t√§nka\"\n    }\n    // Presens -r (grupp 4 verb, stark): \"f√∂rst√•r\" ‚Üí \"f√∂rst√•\", \"g√•r\" ‚Üí \"g√•\", \"st√•r\" ‚Üí \"st√•\"\n    else if (lower.endsWith('r') && lower.length > 2 && !lower.endsWith('ar') && !lower.endsWith('er') && !lower.endsWith('or')) {\n      // Kolla om det √§r ett k√§nt verb som slutar p√• -r i presens\n      const potentialInfinitive = lower.slice(0, -1);\n      // \"f√∂rst√•r\" ‚Üí \"f√∂rst√•\", \"g√•r\" ‚Üí \"g√•\", \"st√•r\" ‚Üí \"st√•\", \"m√•r\" ‚Üí \"m√•\"\n      lemma = potentialInfinitive;\n    }\n    // Adjektiv i neutrum singular: Ta bort -t\n    else if (lower.endsWith('t') && lower.length > 2 && !lower.endsWith('nt') && !lower.endsWith('tt')) {\n      lemma = lower.slice(0, -1);\n    }\n\n    // Standard: g√∂ra det versalt\n    return lemma.toUpperCase();\n  }\n\n  private reorderSTS(timeWords: string[], glosWords: string[], hasNegation: boolean, isQuestion: boolean): string[] {\n    const result: string[] = [];\n\n    // 1. TIDSLINJE f√∂rst (IG√ÖR, IDAG, IMORGON)\n    result.push(...timeWords.map(w => this.lemmatizeWord(w)));\n\n    // 2. GLOSORD (redan lemmatiserade)\n    result.push(...glosWords);\n\n    // 3. NEGATION (om det finns)\n    if (hasNegation) {\n      result.push('INTE');\n    }\n\n    return result;\n  }\n\n  private addNonManualMarkers(glos: string[], isQuestion: boolean, hasNegation: boolean): string {\n    if (glos.length === 0) return '';\n    \n    // Join all words with spaces\n    let result = glos.join(' ');\n    \n    // NOTE: Punctuation is now added by glosaSingleSentence parent caller\n    // This function is kept for backward compatibility but doesn't add punctuation\n\n    return result;\n  }\n\n  /**\n   * Snabb kontroll: Kan denna text hanteras offline?\n   * Returnerar confidence 0-1 (1 = helt s√§ker, 0 = anv√§nd AI)\n   */\n  public getConfidence(text: string): number {\n    if (!text || text.length < 5) return 0.3;\n\n    const words = text.toLowerCase().split(/\\s+/);\n    const knownWords = words.filter(w => \n      this.inflectionCache.has(w) || \n      this.stopwords.has(w) ||\n      this.timelineWords.has(w)\n    ).length;\n\n    // Om >60% ord √§r k√§nda -> vi √§r confident\n    return Math.min(1, knownWords / words.length * 1.5);\n  }\n}\n\n// Singleton instance\nexport const offlineEngine = new OfflineGlosaEngine();\n","path":null,"size_bytes":16173,"size_tokens":null},"vitest.config.ts":{"content":"export default { test: { environment: \"jsdom\" } }\n","path":null,"size_bytes":50,"size_tokens":null},"src/components/Loader.tsx":{"content":"import React from 'react';\nimport styled from 'styled-components';\n\nconst Loader = () => {\n  return (\n    <StyledWrapper>\n      <div className=\"spinner\">\n        <div className=\"spinnerin\" />\n      </div>\n    </StyledWrapper>\n  );\n};\n\nconst StyledWrapper = styled.div`\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  min-height: 3em;\n\n  .spinner {\n    width: 3em;\n    height: 3em;\n    cursor: not-allowed;\n    border-radius: 50%;\n    border: 2px solid #444;\n    box-shadow: -10px -10px 10px #6359f8, 0px -10px 10px 0px #9c32e2, 10px -10px 10px #f36896, 10px 0 10px #ff0b0b, 10px 10px 10px 0px #ff5500, 0 10px 10px 0px #ff9500, -10px 10px 10px 0px #ffb700;\n    animation: rot55 0.7s linear infinite;\n    position: relative;\n  }\n\n  .spinnerin {\n    border: 2px solid #444;\n    width: 1.5em;\n    height: 1.5em;\n    border-radius: 50%;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }\n\n  @keyframes rot55 {\n    to {\n      transform: rotate(360deg);\n    }\n  }\n`;\n\nexport default Loader;\n","path":null,"size_bytes":1071,"size_tokens":null},"src/services/ui/videoGridSelectionService.ts":{"content":"\nimport { appState } from '../../state';\n\nexport async function updateSelectionUI() {\n    const selectionCount = appState.selection.length;\n    const feedbackBtn = document.getElementById('mainFeedbackBtn') as HTMLButtonElement;\n    const thumbUpBtn = document.getElementById('thumbUpSelectionBtn') as HTMLButtonElement;\n    const thumbDownBtn = document.getElementById('thumbDownSelectionBtn') as HTMLButtonElement;\n    const combinationActionContainer = document.getElementById('combinationActionContainer') as HTMLElement;\n    const videoGrid = document.getElementById('videoGrid') as HTMLElement;\n\n    const isSelectToolActive = videoGrid && videoGrid.dataset.activeTool === 'select';\n    const showSelectionActions = selectionCount > 0 && isSelectToolActive;\n    \n    if (thumbUpBtn && thumbDownBtn) {\n        thumbUpBtn.classList.toggle('hidden', !showSelectionActions);\n        thumbDownBtn.classList.toggle('hidden', !showSelectionActions);\n    }\n    \n    if (combinationActionContainer) {\n        combinationActionContainer.classList.toggle('hidden', !(selectionCount >= 2 && isSelectToolActive));\n    }\n\n    if (feedbackBtn) {\n        if (showSelectionActions) {\n            feedbackBtn.textContent = `Kommentera (${selectionCount})`;\n            feedbackBtn.dataset.tooltipText = 'L√§mna en gemensam kommentar f√∂r alla valda tecken.';\n            feedbackBtn.disabled = false;\n            // Dynamic import to avoid circular dependency with modals.ts\n            feedbackBtn.onclick = (e) => import('../../components/modals').then(m => m.openGroupCommentModal(e.currentTarget as HTMLElement));\n        } else {\n            feedbackBtn.textContent = 'Ge Feedback';\n            feedbackBtn.dataset.tooltipText = 'L√§mna en √∂vergripande kommentar om hela meningen.';\n            \n            const sentenceForFeedback = appState.isShowingAllSentences \n                ? appState.sentences.flat() // Provide all words if all are shown\n                : appState.sentences[appState.currentSentenceIndex];\n\n            if (sentenceForFeedback && sentenceForFeedback.length > 0) {\n                 feedbackBtn.disabled = false;\n                 feedbackBtn.onclick = (e) => import('../../components/modals').then(m => m.openSentenceFeedbackModal(sentenceForFeedback, e.currentTarget as HTMLElement));\n            } else {\n                feedbackBtn.disabled = true;\n                feedbackBtn.onclick = null;\n            }\n        }\n    }\n    \n    document.querySelectorAll<HTMLElement>('.video-card[data-card-id]').forEach(card => {\n        const cardId = card.dataset.cardId;\n        if (cardId) {\n            card.classList.toggle('is-selected', appState.selection.includes(cardId));\n        }\n    });\n}\n","path":null,"size_bytes":2715,"size_tokens":null},"index.tsx":{"content":"// Core Styles\nimport './src/styles/variables.css';\nimport './src/styles/base.css';\nimport './src/styles/components.css';\nimport './src/styles/style.css';\nimport './src/styles/core/layout.css';\nimport './src/styles/core/grids.css';\n\n// Component Styles\nimport './src/styles/components/cards.css';\nimport './src/styles/components/modals.css';\nimport './src/styles/components/navigation.css';\nimport './src/styles/components/chat.css';\n\n// Feature Styles\nimport './src/styles/features/robot-report.css';\nimport './src/styles/features/linguistic.css';\nimport './src/styles/features/grammar.css';\n\n// UI Styles\nimport './src/styles/ui/progress.css';\n\nimport { initializeApp } from './src/App';\n\nfunction main() {\n  // Starta applikationen\n  initializeApp();\n}\n\nmain();\n","path":null,"size_bytes":765,"size_tokens":null},"src/components/__tests__/chat.full.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as chat from '../chat';\n\ndescribe('chat module (full test)', () => {\n  it('should export setupChatEventListeners', () => {\n    expect(typeof chat.setupChatEventListeners).toBe('function');\n  });\n\n  it('should export handleOpenChat', () => {\n    expect(typeof chat.handleOpenChat).toBe('function');\n  });\n\n  // L√§gg till tester f√∂r chatlogik, event och rendering h√§r\n});\n","path":null,"size_bytes":429,"size_tokens":null},"src/services/data/lexiconUrlService.ts":{"content":"\nexport const LEXICON_ORD_URL = \"https://teckensprakslexikon.su.se/ord/\";\nexport const LEXICON_SEARCH_URL = \"https://teckensprakslexikon.su.se/?q=\";\n\nexport function getLexiconUrl(type: 'ord' | 'search', value: string): string {\n    if (type === 'ord') {\n        let cleanId = value;\n        // Pad ID to 5 digits if it is numeric to match lexicon URL structure\n        if (/^\\d+$/.test(cleanId)) {\n            cleanId = cleanId.padStart(5, '0');\n        }\n        return `${LEXICON_ORD_URL}${cleanId}/`;\n    }\n    if (type === 'search') {\n        return `${LEXICON_SEARCH_URL}${encodeURIComponent(value)}`;\n    }\n    return '';\n}\n","path":null,"size_bytes":631,"size_tokens":null},"src/components/GlosaSearch.tsx":{"content":"import React, { useState } from 'react';\nimport Loader from './Loader';\n\n// Ladda in genuina_tecken.json (kr√§ver att du anv√§nder t.ex. import assertion eller fetch beroende p√• setup)\n// H√§r anv√§nds dynamisk import f√∂r enkelhet\n\nconst GlosaSearch = () => {\n  const [input, setInput] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [result, setResult] = useState(null);\n  const [error, setError] = useState('');\n  const [glosaResult, setGlosaResult] = useState('');\n  // Glosa-knappens logik\n  const [debugInput, setDebugInput] = useState('');\n  const handleGlosa = async () => {\n    setIsLoading(true);\n    setGlosaResult('');\n    setError('');\n    setDebugInput(input); // Spara vad som skickas till glossningsmotorn\n    try {\n      const { offlineEngine } = await import('../modules/sts-glossing/offlineGlosaEngine');\n      if (offlineEngine.initializeLists) {\n        await offlineEngine.initializeLists();\n      }\n      const glossed = offlineEngine.translateToGlosaOffline(input);\n      setGlosaResult(glossed);\n    } catch (e) {\n      setError('Fel vid glossning.');\n    }\n    setIsLoading(false);\n  };\n\n  // S√∂kfunktion kopplad till offline lexikon och glossningsmotor\n  const handleSearch = async () => {\n    setIsLoading(true);\n    setError('');\n    setResult(null);\n    try {\n      const { offlineEngine } = await import('../modules/sts-glossing/offlineGlosaEngine');\n      if (offlineEngine.initializeLists) {\n        await offlineEngine.initializeLists();\n      }\n      // Lemmatize input\n      const lemmaInput = offlineEngine.lemmatizeWord ? offlineEngine.lemmatizeWord(input) : input;\n      // S√∂k i ALLA lexikonfiler del_1-6\n      const lexFiles = [1,2,3,4,5,6].map(n => `/data/lexikon/offline/snabb/lexikon_sammanslagen_del_${n}.json`);\n      let match = null;\n      for (const file of lexFiles) {\n        const lexData = await fetch(file).then(res => res.json());\n        match = lexData.find(entry => entry.word && entry.word.toLowerCase() === lemmaInput.toLowerCase());\n        if (match) break;\n      }\n      setResult(match || null);\n      if (!match) setError('Ingen tr√§ff i lexikon.');\n    } catch (e) {\n      setError('Fel vid s√∂kning.');\n    }\n    setIsLoading(false);\n  };\n\n  return (\n    <div style={{ maxWidth: 400, margin: '2em auto', textAlign: 'center' }}>\n      <input\n        type=\"text\"\n        value={input}\n        onChange={e => setInput(e.target.value)}\n        placeholder=\"Skriv tecken eller synonym...\"\n        style={{ padding: '0.5em', width: '70%' }}\n      />\n      <button onClick={handleSearch} style={{ marginLeft: 8, padding: '0.5em 1em' }}>S√∂k</button>\n      <button onClick={handleGlosa} style={{ marginLeft: 8, padding: '0.5em 1em', background: '#e0e0ff' }}>Glosa</button>\n      <div style={{ margin: '2em 0' }}>\n        {isLoading && <Loader />}\n        {result && !isLoading && (\n          <div style={{ marginTop: 16 }}>\n            <h3>{result.word}</h3>\n            {result.id && (\n              <div style={{ color: '#666', fontSize: '0.95em' }}>\n                ID: {result.id}\n              </div>\n            )}\n            {/* Visa video om id finns */}\n            {result.id && (\n              <video src={`https://teckensprakslexikon.su.se/movies/${result.id.substring(0,2)}/180x180/${result.word}-${result.id}-tecken.mp4`} controls style={{ marginTop: 16, maxWidth: '100%' }} />\n            )}\n          </div>\n        )}\n        {/* Visa glossningsresultat */}\n        {/* Debug: visa input som skickas till glossningsmotorn */}\n        {debugInput && !isLoading && (\n          <div style={{ marginTop: 8, color: '#888', fontSize: '0.9em' }}>\n            <div><b>Debug input till glossning:</b> \"{debugInput}\"</div>\n          </div>\n        )}\n        {!isLoading && (\n          <div style={{ marginTop: 16, color: glosaResult ? '#2a2' : '#a22', fontWeight: 'bold' }}>\n            <div>Glossning:</div>\n            <div>{glosaResult ? glosaResult : 'Ingen glossning kunde genereras.'}</div>\n          </div>\n        )}\n        {error && !isLoading && <div style={{ color: 'red', marginTop: 16 }}>{error}</div>}\n      </div>\n    </div>\n  );\n};\n\nexport default GlosaSearch;\n","path":null,"size_bytes":4178,"size_tokens":null},"src/components/__tests__/GlosaSearch.full.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport GlosaSearch from '../GlosaSearch';\nimport { render, fireEvent, screen } from '@testing-library/react';\n\ndescribe('GlosaSearch component (full test)', () => {\n  it('should render input and buttons', () => {\n    render(<GlosaSearch />);\n    expect(screen.getByPlaceholderText('Skriv tecken eller synonym...')).toBeInTheDocument();\n    expect(screen.getByText('S√∂k')).toBeInTheDocument();\n    expect(screen.getByText('Glosa')).toBeInTheDocument();\n  });\n\n  it('should update input value', () => {\n    render(<GlosaSearch />);\n    const input = screen.getByPlaceholderText('Skriv tecken eller synonym...');\n    fireEvent.change(input, { target: { value: 'hund' } });\n    expect((input as HTMLInputElement).value).toBe('hund');\n  });\n\n  it('should show error if no match found', async () => {\n    render(<GlosaSearch />);\n    const input = screen.getByPlaceholderText('Skriv tecken eller synonym...');\n    fireEvent.change(input, { target: { value: 'xyz' } });\n    fireEvent.click(screen.getByText('S√∂k'));\n    // Eftersom fetch √§r mockad eller offline, kan vi bara testa att error visas\n    expect(await screen.findByText(/Ingen tr√§ff i lexikon.|Fel vid s√∂kning./)).toBeInTheDocument();\n  });\n\n  it('should show glossning result after clicking Glosa', async () => {\n    render(<GlosaSearch />);\n    const input = screen.getByPlaceholderText('Skriv tecken eller synonym...');\n    fireEvent.change(input, { target: { value: 'jag beh√∂ver hj√§lp' } });\n    fireEvent.click(screen.getByText('Glosa'));\n    expect(await screen.findByText(/JAG BEH√ñVA HJ√ÑLP.|Ingen glossning kunde genereras./)).toBeInTheDocument();\n  });\n});\n","path":null,"size_bytes":1676,"size_tokens":null},"src/services/system/devModeService.ts":{"content":"/**\n * Dev Mode Service - Check if developer mode is enabled\n * Dev mode is activated via secret URL parameter: ?dev=hemlig\n * Puter.js only loads in dev mode\n */\n\nlet devModeActive = false;\nlet puterLoaded = false;\n\nexport function initDevMode(): void {\n    const urlParams = new URLSearchParams(window.location.search);\n    const devParam = urlParams.get('dev');\n    \n    if (devParam === 'hemlig') {\n        devModeActive = true;\n        localStorage.setItem('devMode', 'true');\n        console.log('üîß Dev mode activated via URL parameter');\n    } else if (localStorage.getItem('devMode') === 'true') {\n        devModeActive = true;\n        console.log('üîß Dev mode active from localStorage');\n    }\n    \n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n            applyDevModeVisibility();\n            if (devModeActive) loadPuterJs();\n        });\n    } else {\n        applyDevModeVisibility();\n        if (devModeActive) loadPuterJs();\n    }\n    \n    setTimeout(() => applyDevModeVisibility(), 100);\n}\n\nfunction loadPuterJs(): void {\n    if (puterLoaded) return;\n    \n    console.log('üîß Loading Puter.js for dev mode...');\n    \n    const script1 = document.createElement('script');\n    script1.src = 'https://js.puter.com/v2/';\n    script1.onload = () => {\n        console.log('‚úÖ Puter.js v2 loaded');\n        puterLoaded = true;\n    };\n    document.head.appendChild(script1);\n    \n    const script2 = document.createElement('script');\n    script2.src = 'https://cdn.jsdelivr.net/npm/@puter/puter@latest/dist/puter.min.js';\n    script2.onload = () => {\n        console.log('‚úÖ Puter SDK loaded');\n    };\n    document.head.appendChild(script2);\n}\n\nexport function isDevMode(): boolean {\n    return devModeActive;\n}\n\nexport function toggleDevMode(enabled: boolean): void {\n    devModeActive = enabled;\n    localStorage.setItem('devMode', enabled ? 'true' : 'false');\n    applyDevModeVisibility();\n    \n    if (enabled && !puterLoaded) {\n        loadPuterJs();\n    }\n}\n\nexport function exitDevMode(): void {\n    devModeActive = false;\n    localStorage.removeItem('devMode');\n    applyDevModeVisibility();\n}\n\nexport function applyDevModeVisibility(): void {\n    console.log('üîß Applying dev mode visibility:', devModeActive ? 'ON' : 'OFF');\n    \n    const devOnlyElements = document.querySelectorAll('.dev-only');\n    devOnlyElements.forEach(el => {\n        (el as HTMLElement).style.display = devModeActive ? '' : 'none';\n    });\n    \n    const aiContainer = document.getElementById('aiModeContainer');\n    if (aiContainer) {\n        aiContainer.style.display = devModeActive ? 'flex' : 'none';\n    }\n    \n    const askAiBtn = document.getElementById('askAiAboutStsBtn');\n    if (askAiBtn) {\n        askAiBtn.style.display = devModeActive ? 'flex' : 'none';\n    }\n    \n    const devModeToggle = document.getElementById('devModeToggle');\n    if (devModeToggle) {\n        const container = devModeToggle.closest('.border-t');\n        if (container) (container as HTMLElement).style.display = devModeActive ? 'block' : 'none';\n        (devModeToggle as HTMLInputElement).checked = devModeActive;\n    }\n}\n","path":null,"size_bytes":3175,"size_tokens":null},"src/services/ui/feedbackNotificationService.ts":{"content":"\nexport const FEEDBACK_SUMMARY_PREFIX = \"Inl√§rningssammanfattning f√∂r STS-helper:\";\n\nexport function activateFeedbackButton() {\n    updateFeedbackBadge();\n    \n    const feedbackBtn = document.getElementById('feedbackNavBtn');\n    if (feedbackBtn) {\n        feedbackBtn.classList.add('glow-attention');\n    }\n}\n\nexport function updateFeedbackBadge(count?: number) {\n    const badge = document.getElementById('feedbackBadge');\n    if (!badge) return;\n    \n    let feedbackCount = count;\n    \n    if (feedbackCount === undefined) {\n        try {\n            const stored = localStorage.getItem('sts-feedback-collection');\n            if (stored) {\n                const items = JSON.parse(stored);\n                feedbackCount = Array.isArray(items) ? items.length : 0;\n            } else {\n                feedbackCount = 0;\n            }\n        } catch {\n            feedbackCount = 0;\n        }\n    }\n    \n    if (feedbackCount > 0) {\n        badge.textContent = feedbackCount > 99 ? '99+' : feedbackCount.toString();\n        badge.classList.remove('hidden');\n    } else {\n        badge.classList.add('hidden');\n    }\n}\n\nexport function clearFeedbackGlow() {\n    const feedbackBtn = document.getElementById('feedbackNavBtn');\n    if (feedbackBtn) {\n        feedbackBtn.classList.remove('glow-attention');\n    }\n}\n","path":null,"size_bytes":1318,"size_tokens":null},"src/modules/features/playback.ts":{"content":"\nimport { appState } from '../../state';\n\nconst playAllBtn = document.getElementById('playAllBtn') as HTMLButtonElement;\nconst videoGrid = document.getElementById('videoGrid') as HTMLElement;\n\nlet stopPlayAllFn = () => {};\n\nexport async function playSequence(cards: HTMLElement[]) {\n    appState.isPlayingAll = true;\n    if (playAllBtn) playAllBtn.textContent = 'Stoppa';\n    \n    let shouldStop = false;\n    stopPlayAllFn = () => { shouldStop = true; };\n\n    for (const card of cards) {\n        if (shouldStop) break;\n\n        const video = card.querySelector('video');\n        if (video) {\n            video.muted = true; \n            card.scrollIntoView({ behavior: 'smooth', block: 'center' });\n            video.currentTime = 0;\n            \n            const playPromise = video.play();\n            \n            const endedPromise = new Promise(resolve => {\n                const onEnded = () => {\n                    video.removeEventListener('ended', onEnded);\n                    resolve(true);\n                };\n                video.addEventListener('ended', onEnded);\n                \n                // Update the stopper to also resolve this promise\n                const originalStopper = stopPlayAllFn;\n                stopPlayAllFn = () => {\n                    originalStopper(); // call the flag setter\n                    video.pause();\n                    video.currentTime = 0;\n                    card.classList.remove('is-playing-all');\n                    video.removeEventListener('ended', onEnded);\n                    resolve(false); \n                };\n            });\n            \n            card.classList.add('is-playing-all');\n            await playPromise;\n            await endedPromise;\n\n            card.classList.remove('is-playing-all');\n        }\n    }\n    \n    appState.isPlayingAll = false;\n    if (playAllBtn) playAllBtn.textContent = 'Spela Alla';\n    stopPlayAllFn = () => {}; \n}\n\nexport function handlePlayAll() {\n    if (appState.isPlayingAll) {\n        stopPlayAllFn();\n    } else {\n        if (!videoGrid) return;\n        const visibleCards = Array.from(videoGrid.querySelectorAll<HTMLElement>('.video-card:not(.video-card-no-sign)'));\n        if (visibleCards.length > 0) {\n            playSequence(visibleCards);\n        }\n    }\n}\n\nexport function stopPlayAll() {\n    stopPlayAllFn();\n}\n","path":null,"size_bytes":2340,"size_tokens":null},"src/styles/ui/progress.css":{"content":"\n/* --- DUAL PROGRESS BARS (MAIN & HEADER) --- */\n.progress-bar-wrapper {\n    width: 100%;\n    background-color: var(--border-color);\n    border-radius: 9999px;\n    height: 0.6rem;\n    overflow: hidden;\n}\n\n.progress-bar-inner {\n    height: 100%;\n    width: 0%;\n    background-color: var(--primary-blue);\n    border-radius: 9999px;\n    transition: width var(--transition-normal) ease;\n}\n.progress-bar-inner.completed {\n    background-color: var(--green-vote);\n}\n.status-icon svg {\n    width: 1rem;\n    height: 1rem;\n    color: var(--green-vote);\n}\n\n/* Header-specific progress bars */\n.progress-row-header {\n    display: flex;\n    align-items: center;\n    gap: 0.35rem;\n}\n.progress-label-header {\n    font-size: 0.65rem;\n    font-weight: 600;\n    color: var(--text-secondary);\n    width: 30px; /* Fixed width for alignment */\n}\n.progress-bar-wrapper-header {\n    flex-grow: 1;\n    height: 0.4rem;\n    background-color: var(--border-color);\n    border-radius: 9999px;\n    overflow: hidden;\n}\n.progress-bar-inner-header {\n    height: 100%;\n    width: 0%;\n    background-color: var(--primary-blue);\n    border-radius: 9999px;\n    transition: width 0.3s ease;\n}\n.progress-bar-inner-header.completed {\n    background-color: var(--green-vote);\n}\n.progress-percentage-header {\n    font-size: 0.65rem;\n    font-family: monospace;\n    color: var(--text-secondary);\n    width: 25px; /* Fixed width for alignment */\n    text-align: right;\n}\n","path":null,"size_bytes":1429,"size_tokens":null},"eslint.config.js":{"content":"import tseslint from \"@typescript-eslint/eslint-plugin\";\nimport tsParser from \"@typescript-eslint/parser\";\nexport default [\n  {\n    files: [\"**/*.{ts,tsx}\"],\n    languageOptions: {\n      parser: tsParser,\n      ecmaVersion: \"latest\",\n      sourceType: \"module\"\n    },\n    plugins: { \"@typescript-eslint\": tseslint },\n    rules: {\n      \"@typescript-eslint/no-unused-vars\": \"warn\"\n    }\n  }\n];\n","path":null,"size_bytes":393,"size_tokens":null},"vite.config.ts":{"content":"import path from 'path';\nimport { defineConfig } from 'vite';\n\nexport default defineConfig(({ command }) => {\n    // Anv√§nd PORT fr√•n milj√∂variabel, annars 5000 (user) som default\n    const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 5000;\n    return {\n      server: {\n        port,\n        host: '0.0.0.0',\n        allowedHosts: true,\n        middlewareMode: false,\n      },\n      plugins: [\n        {\n          name: 'api-middleware',\n          configureServer(server) {\n            server.middlewares.use('/api/config/anthropic-key', (req, res) => {\n              const key = process.env.ANTHROPIC_API_KEY;\n              res.setHeader('Content-Type', 'application/json');\n              res.end(JSON.stringify({ apiKey: key || '' }));\n            });\n            server.middlewares.use('/api/config/google-key', (req, res) => {\n              const key = process.env.GOOGLE_GENAI_API_KEY;\n              res.setHeader('Content-Type', 'application/json');\n              res.end(JSON.stringify({ apiKey: key || '' }));\n            });\n            server.middlewares.use('/api/config/openai-key', (req, res) => {\n              const key = process.env.OPENAI_API_KEY;\n              res.setHeader('Content-Type', 'application/json');\n              res.end(JSON.stringify({ apiKey: key || '' }));\n            });\n            server.middlewares.use('/api/config/groq-key', (req, res) => {\n              const key = process.env.GROQ_API_KEY;\n              res.setHeader('Content-Type', 'application/json');\n              res.end(JSON.stringify({ apiKey: key || '' }));\n            });\n            server.middlewares.use('/api/config/mistral-key', (req, res) => {\n              const key = process.env.MISTRAL_API_KEY;\n              res.setHeader('Content-Type', 'application/json');\n              res.end(JSON.stringify({ apiKey: key || '' }));\n            });\n          }\n        }\n      ],\n      resolve: {\n        alias: {\n          '@': path.resolve(__dirname, '.'),\n        }\n      }\n    };\n});\n","path":null,"size_bytes":2010,"size_tokens":null},"src/modules/core/__tests__/reset.full.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport { resetApp } from '../reset';\n\ndescribe('resetApp (full test)', () => {\n  it('should be a function', () => {\n    expect(typeof resetApp).toBe('function');\n  });\n\n  // L√§gg till tester f√∂r state-reset och DOM-manipulation h√§r\n});\n","path":null,"size_bytes":286,"size_tokens":null},"src/modules/features/glossingEngine.ts":{"content":"// src/modules/features/glossingEngine.ts\n\nconst QUESTION_WORDS = [\"vad\", \"hur\", \"vem\", \"var\", \"n√§r\", \"varf√∂r\", \"vilken\", \"vilket\", \"vilka\"];\nconst STOPWORDS = [\"att\", \"och\", \"en\", \"ett\", \"den\", \"det\", \"som\", \"p√•\", \"i\", \"av\", \"till\", \"f√∂r\", \"med\", \"om\", \"fr√•n\"];\nconst LEMMA_MAP: Record<string, string> = {\n    \"heter\": \"HETA\",\n    \"√§r\": \"VARA\",\n    \"gick\": \"G√Ö\",\n    \"barnen\": \"BARN\",\n    \"vill\": \"VILL\",\n    \"ska\": \"SKA\",\n    \"har\": \"HA\",\n    \"gjorde\": \"G√ñRA\",\n    \"kommer\": \"KOMMA\",\n    \"m√•r\": \"M√Ö\",\n    \"bor\": \"BO\",\n    \"√•ker\": \"√ÖKA\",\n    \"s√§ger\": \"S√ÑGA\",\n    \"finns\": \"FINNAS\"\n    // ...l√§gg till fler vid behov\n};\nconst NUMBER_WORDS: Record<string, string> = {\n    \"ett\": \"1\", \"tv√•\": \"2\", \"tre\": \"3\", \"fyra\": \"4\", \"fem\": \"5\", \"sex\": \"6\", \"sju\": \"7\", \"√•tta\": \"8\", \"nio\": \"9\", \"tio\": \"10\"\n};\n\nfunction glossBasic(svenska: string): { standard: string, alternative: string } {\n    let words = svenska.trim().replace(/[?!.]/g, \"\").split(/\\s+/);\n\n    // Lemmatisera, hantera siffror, filtrera sm√•ord\n    let glossWords = words\n        .filter(w => !STOPWORDS.includes(w.toLowerCase()))\n        .map(w => {\n            if (NUMBER_WORDS[w.toLowerCase()]) return NUMBER_WORDS[w.toLowerCase()];\n            if (LEMMA_MAP[w.toLowerCase()]) return LEMMA_MAP[w.toLowerCase()];\n            return w.toUpperCase();\n        });\n\n    // Hitta fr√•geord\n    const qIndex = glossWords.findIndex(w => QUESTION_WORDS.includes(w.toLowerCase()));\n    let standard, alternative;\n    if (qIndex !== -1) {\n        const qWord = glossWords.splice(qIndex, 1)[0];\n        glossWords.push(qWord); // Fr√•geord sist\n        standard = glossWords.join(\" \");\n        alternative = [qWord, ...glossWords.slice(0, -1)].join(\" \");\n    } else {\n        standard = glossWords.join(\" \");\n        alternative = standard;\n    }\n\n    return { standard, alternative };\n}\n\nexport { glossBasic };\n","path":null,"size_bytes":1876,"size_tokens":null},"src/hooks/useAI.ts":{"content":"\n// import { generateTextHuggingFace } from '../services/huggingFaceApi'; // Borttagen, endast offline glossning\nimport { quotaTracker } from '../services/quotaTracker';\nimport { appState } from '../state';\nimport { showMessage, updateButtonProgress } from '../ui';\nimport { WordMapEntry } from '../types';\n\n// Inline prompts (prompts.ts removed)\nconst ANALYSIS_SYSTEM_INSTRUCTION = `Du √§r expert p√• svenskt teckenspr√•k (STS). Returnera BARA base form-ord. VARJE MENING SLUTAR MED PUNKT.`;\nconst IMAGE_ANALYSIS_PROMPT = `Analysera bilden. Om den inneh√•ller text, returnera ENDAST texten. Annars, identifiera huvudobjekt.`;\nconst FEEDBACK_SUMMARY_INSTRUCTION = `Analysera feedback f√∂r teckenspr√•ksappen. Generera koncis sammanfattning i punktform.`;\nconst FEEDBACK_CONVERSION_INSTRUCTION = `Omvandla JSON-rapport med feedback till strukturerad JSON-uppdatering.`;\nconst createSentenceGenerationPrompt = (count: number, words: string[]) => `Generera ${count} intressanta meningar med dessa ord: ${words.join(', ')}`;\n\nimport { clearLocalSearchCache } from '../modules/search/localSearchWithFallback';\nimport { offlineEngine } from '../modules/sts-glossing/offlineGlosaEngine';\n// import { aiLearningSystem } from '../modules/sts-glossing/aiLearningSystem'; // Borttagen, endast offline glossning\n\n// Alla AI-modeller och online-tj√§nster √§r borttagna. Endast offline glossning anv√§nds.\n\n// NOTE: Using Puter.js and HuggingFace APIs - no client initialization needed\n\nexport function updateAIStatusIndicator() {\n    const indicator = document.getElementById('aiStatusIndicator') as HTMLElement;\n    if (!indicator) return;\n    \n    if (appState.usePuter) {\n        indicator.classList.remove('ai-offline', 'ai-loading');\n        indicator.classList.add('ai-online');\n        indicator.title = '‚úÖ AI Online - Puter.js available';\n    } else {\n        indicator.classList.remove('ai-online', 'ai-loading');\n        indicator.classList.add('ai-offline');\n        indicator.title = '‚ö†Ô∏è AI Offline - Using local GLOSA only';\n    }\n}\n\nexport async function initializeAI(resetApp: () => void) {\n    clearLocalSearchCache();\n    \n    try {\n        // Check if Puter.js is available\n        if (typeof (window as any).puter !== 'undefined') {\n            console.log('‚úÖ Puter.js loaded and ready');\n            appState.usePuter = true;\n            appState.aiReady = true;\n            showMessage('‚úÖ AI-systemet √§r redo (Puter)', 'success', 3000);\n            \n            // Ladda cloud-data vid start\n            try {\n                const { puterCloudSync } = await import('../modules/cloud/puterCloudSync');\n                const loaded = await puterCloudSync.loadFromCloud();\n                if (loaded) {\n                    console.log('‚òÅÔ∏è Cloud data loaded successfully');\n                }\n            } catch (cloudError) {\n                console.warn('Cloud sync not available:', cloudError);\n            }\n        } else {\n            console.warn('‚ö†Ô∏è Puter.js not available');\n            appState.usePuter = false;\n        }\n    } catch (error) {\n        console.error('AI initialization failed:', error);\n        showMessage('‚ùå AI kunde inte initieras', 'error', 5000);\n        appState.aiReady = false;\n    }\n    \n    // Update AI Status Indicator\n    updateAIStatusIndicator();\n}\n\nexport function handleAIError(error: any, context: string) {\n    const errorMessage = error?.message || (typeof error === 'string' ? error : 'Ett ok√§nt fel intr√§ffade.');\n    console.error(`AI ${context} misslyckades:`, error);\n    let userMessage = `AI-analys misslyckades.`;\n    if (errorMessage.includes('429') || /quota|rate limit/i.test(errorMessage)) {\n        userMessage = \"AI-analys misslyckades: F√∂r m√•nga anrop. V√§nta en stund.\";\n    } else if (errorMessage.includes('401') || errorMessage.includes('authentication')) {\n        userMessage = \"AI-nyckel ogiltig. F√∂rs√∂ker n√§sta API...\";\n    } else {\n        userMessage += ` ${errorMessage}`;\n    }\n    showMessage(userMessage, 'error', 8000);\n    if (context === 'analysis' || context === 'sentence-generation') {\n        updateButtonProgress('idle');\n    }\n}\n\n// Importera STS-glossing-modulen f√∂r rent teckenspr√•ksglosning\n\nexport async function refineTextWithAI(textContent: string, wordsToRefine: string[]): Promise<WordMapEntry[] | null> {\n    const { aiAnalysisCache } = await import('../state');\n    const cacheKey = `${textContent.trim()}_${wordsToRefine.join(',')}`;\n    \n    if (aiAnalysisCache.has(cacheKey)) {\n        console.log('üì¶ Cache hit - skipping API call');\n        return aiAnalysisCache.get(cacheKey)!;\n    }\n\n    appState.abortController = new AbortController();\n    const systemInstruction = ANALYSIS_SYSTEM_INSTRUCTION;\n    const prompt = textContent;\n\n    try {\n        // TRY OFFLINE FIRST\n        console.log('üü£ Trying offline GLOSA engine first...');\n        const offlineConfidence = offlineEngine.getConfidence(textContent);\n        console.log(`üìä Offline confidence: ${(offlineConfidence * 100).toFixed(0)}%`);\n        \n        if (offlineConfidence > 0.6) {\n            try {\n                const offlineResult = offlineEngine.translateToGlosaOffline(textContent);\n                console.log('‚úÖ Offline GLOSA successful:', offlineResult);\n                return [{\n                    original: textContent,\n                    base: textContent,\n                    isWord: true,\n                    pos: 'noun',\n                    signs: null,\n                    gloss: offlineResult\n                }];\n            } catch (e) {\n                console.warn('Offline GLOSA failed, trying Puter...', e);\n            }\n        }\n\n        // FALLBACK TO HUGGINGFACE API (with token if available)\n        try {\n            console.log('üü¢ Calling HuggingFace for GLOSA translation...');\n            const hfEndpoint = 'https://api-inference.huggingface.co/models/TheBloke/CapybaraHermes-2.5-Mistral-7B-GGUF';\n            const hfToken = import.meta.env.VITE_HUGGINGFACE_TOKEN || '';\n            \n            const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n            if (hfToken) headers['Authorization'] = `Bearer ${hfToken}`;\n            \n            const response = await fetch(hfEndpoint, {\n                method: 'POST',\n                headers,\n                body: JSON.stringify({\n                    inputs: `${systemInstruction}\\n\\nSvenska: ${prompt}\\n\\nReturna BARA base form-ord. VARJE MENING SLUTAR MED PUNKT.`,\n                    parameters: { max_new_tokens: 200 }\n                })\n            });\n            \n            if (response.ok && appState.abortController?.signal.aborted === false) {\n                const data = await response.json();\n                const result = data[0]?.generated_text || '';\n                if (result && result.length > 20) {\n                    console.log('‚úÖ HuggingFace GLOSA translation successful');\n                    aiLearningSystem.recordLearning(textContent, result.trim(), 'huggingface-glosa', 0.85);\n                    appState.abortController = null;\n                    return [{\n                        original: textContent,\n                        base: textContent,\n                        isWord: true,\n                        pos: 'noun',\n                        signs: null,\n                        gloss: result.trim()\n                    }];\n                }\n            }\n        } catch (error: any) {\n            console.warn('HuggingFace GLOSA failed:', error?.message || error);\n        }\n    } catch (error: any) {\n        console.error('GLOSA error:', error);\n        handleAIError(error, 'glosa');\n    }\n\n    appState.abortController = null;\n    return null;\n}\n\nexport async function generateSentencesWithAI(count: number): Promise<string[] | null> {\n    const { searchableLexicon } = await import('../state');\n    const lexiconSample = [...searchableLexicon].sort(() => 0.5 - Math.random()).slice(0, 10);\n    const prompt = createSentenceGenerationPrompt(count, lexiconSample);\n\n    try {\n        if (appState.usePuter && (window as any).puter?.ai?.chat) {\n            console.log('üîµ Calling Puter AI for sentence generation...');\n            const response = await (window as any).puter.ai.chat({\n                messages: [\n                    { role: 'system', content: 'Du √§r en kreativ svensk skribent. Generera enkla, vardagliga meningar p√• svenska.' },\n                    { role: 'user', content: `${prompt}\\n\\nGenerera exakt ${count} meningar som JSON-lista. Format: [\"mening1\", \"mening2\", ...]` }\n                ],\n                model: 'gpt-4o-mini'\n            });\n            \n            const result = response.message?.content || response || '';\n            \n            if (result) {\n                try {\n                    const jsonMatch = result.match(/\\[[\\s\\S]*?\\]/);\n                    const jsonStr = jsonMatch ? jsonMatch[0] : result;\n                    const sentences = JSON.parse(jsonStr);\n                    \n                    if (Array.isArray(sentences)) {\n                        console.log('‚úÖ Puter AI generated sentences:', sentences.length);\n                        return sentences.slice(0, count);\n                    }\n                } catch (parseError) {\n                    console.warn('Failed to parse Puter AI JSON response:', parseError);\n                }\n            }\n        } else {\n            console.warn('‚ö†Ô∏è Puter AI not available for sentence generation');\n            showMessage('AI inte tillg√§nglig. Aktivera dev mode f√∂rst.', 'error');\n        }\n    } catch (error: any) {\n        console.warn('Puter sentence generation failed:', error?.message || error);\n        handleAIError(error, 'puter-sentences');\n    }\n\n    return null;\n}\n\nexport async function analyzeImageWithAI(base64Data: string, mimeType: string): Promise<string | null> {\n    try {\n        if (appState.usePuter && (window as any).puter?.ai?.chat) {\n            try {\n                console.log('üîµ Calling Puter Gemini 2.5 Pro for image analysis...');\n                const response = await (window as any).puter.ai.chat({\n                    messages: [\n                        {\n                            role: 'user',\n                            content: [\n                                {\n                                    type: 'image',\n                                    src: `data:${mimeType};base64,${base64Data}`\n                                },\n                                {\n                                    type: 'text',\n                                    content: IMAGE_ANALYSIS_PROMPT\n                                }\n                            ]\n                        }\n                    ],\n                    model: aiModelSettings.imagePuter\n                });\n                \n                return response.message?.content || response || \"(Bildanalys misslyckades)\";\n            } catch (error) {\n                console.warn('Puter image analysis failed:', error);\n                handleAIError(error, 'puter-image');\n            }\n        }\n    } catch (error) {\n        console.error('Image analysis error:', error);\n    }\n\n    return \"(Bildanalys kr√§ver Puter AI.)\";\n}\n\nexport async function generateLearningSummaryAI(feedbackJson: string): Promise<string | null> {\n    const systemInstruction = FEEDBACK_SUMMARY_INSTRUCTION;\n    \n    try {\n        if (appState.usePuter && (window as any).puter?.ai?.chat) {\n            try {\n                console.log('üîµ Calling Puter Claude Opus 4.5 for feedback summary...');\n                const response = await (window as any).puter.ai.chat({\n                    messages: [\n                        { role: 'system', content: systemInstruction },\n                        { role: 'user', content: `Skapa en inl√§rningssammanfattning fr√•n: ${feedbackJson}` }\n                    ],\n                    model: aiModelSettings.summaryPuter\n                });\n                \n                return response.message?.content || response || null;\n            } catch (error) {\n                console.warn('Puter feedback summary failed:', error);\n                handleAIError(error, 'puter-summary');\n            }\n        }\n    } catch (error) {\n        console.error('Feedback summary error:', error);\n    }\n\n    return null;\n}\n\nexport async function convertSummaryToJsonAI(feedbackJson: string): Promise<any | null> {\n    const systemInstruction = FEEDBACK_CONVERSION_INSTRUCTION;\n    const prompt = `Analysera denna feedback-JSON och konvertera den enligt schemat:\\n\\n${feedbackJson}\n\nDu M√ÖSTE returnera ENDAST en giltig JSON-struktur med f√§lten: newWords, learnedPreferences, homonymResolutions (alla kan vara null/arrays).`;\n\n    try {\n        if (appState.usePuter && (window as any).puter?.ai?.chat) {\n            try {\n                console.log('üîµ Calling Puter GPT-5.1 for JSON conversion...');\n                const response = await (window as any).puter.ai.chat({\n                    messages: [\n                        { role: 'system', content: systemInstruction },\n                        { role: 'user', content: prompt }\n                    ],\n                    model: aiModelSettings.jsonPuter\n                });\n                \n                const responseText = response.message?.content || response;\n                const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n                const jsonStr = jsonMatch ? jsonMatch[0] : responseText;\n                return JSON.parse(jsonStr);\n            } catch (error) {\n                console.warn('Puter JSON conversion failed:', error);\n                handleAIError(error, 'puter-json');\n            }\n        }\n    } catch (error) {\n        console.error('JSON conversion error:', error);\n    }\n\n    return null;\n}\n\nexport async function translateToGlosa(swedishText: string): Promise<string | null> {\n    if (!swedishText.trim()) return null;\n\n    let offlineResult: string | null = null;\n    let offlineConfidence = 0;\n\n    try {\n        // F√∂rs√∂k alltid offline glossning f√∂rst\n        offlineConfidence = offlineEngine.getConfidence(swedishText);\n        // Offline confidence log\n        console.log('Offline confidence: ' + (offlineConfidence * 100).toFixed(0) + '%');\n        if (offlineConfidence > 0.6) {\n            offlineResult = offlineEngine.translateToGlosaOffline(swedishText);\n            if (offlineResult && offlineResult.length > 0) {\n                console.log('‚úÖ Offline GLOSA successful:', offlineResult);\n                return offlineResult;\n            }\n        }\n\n        // Fallback: tokenisering och lookup som s√∂kfunktionen\n        const tokens = swedishText.split(/([,\\.\"!\\?\\n\\s]+)/g).filter(token => token.length > 0);\n        const { findCandidatesForToken } = await import('../modules/search/localSearchWithFallback');\n        const promises = tokens.map(async (token) => {\n            if (/^[\\s,\\.\"!\\?\\n]+$/.test(token)) {\n                return token;\n            }\n            const cand = await findCandidatesForToken(token);\n            return cand?.base?.toUpperCase() || token.toUpperCase();\n        });\n        const results = await Promise.all(promises);\n        const glosaStr = results.join(' ');\n        console.log('üîÑ Fallback glosa:', glosaStr);\n        return glosaStr.trim();\n    } catch (error: any) {\n        console.error('GLOSA translation error:', error);\n        showMessage('GLOSA-√∂vers√§ttning misslyckades', 'error');\n        return null;\n    }\n}\n","path":null,"size_bytes":15514,"size_tokens":null},"src/components/chat.ts":{"content":"\nimport { appState, learnedPreferences, localUserSigns, homonymMap, feedbackMap, sentenceFeedbackMap, positiveFeedbackMap, negativeFeedbackMap, questionClarifications, localLexiconMap } from '../state';\nimport { showMessage, isDevMode, FEEDBACK_SUMMARY_PREFIX, buildVideoUrl } from '../ui';\nimport { ChatHistoryMessage, Sign } from '../types';\nimport { convertSummaryToJsonAI, generateLearningSummaryAI } from '../hooks/useAI';\nimport { openModal, clearFeedbackData } from './modals';\nimport { saveUserData, handleExportBackup } from '../hooks/useLexicon'; // Import save functions\nimport { populateVideoGrid, renderCurrentSentence } from './VideoGrid'; \nimport { getSortedSearchResults, fileToBase64 } from '../utils';\nimport { markdownToHtml } from '../utils/textUtils';\n\n// Inline prompts (prompts.ts removed)\nconst CHAT_SYSTEM_INSTRUCTION = `Du √§r expert p√• svenskt teckenspr√•k (STS). Svara p√• anv√§ndarens fr√•gor om tecken, grammatik och d√∂vkultur.`;\nconst createFeedbackChatPrompt = (jsonReport: string, userText: string) => `Feedback: ${jsonReport}\\n\\nSvar p√•: ${userText}`;\n\n// --- DOM ELEMENTS (Initialized in setup) ---\nlet aiChatModal: HTMLElement;\n// General Chat Elements\nlet aiChatView: HTMLElement;\nlet aiChatHistory: HTMLElement;\nlet aiChatInput: HTMLTextAreaElement;\nlet aiChatSendBtn: HTMLButtonElement;\nlet aiChatFileUploadBtn: HTMLButtonElement;\nlet aiChatFileInput: HTMLInputElement;\nlet aiChatFilePreviewContainer: HTMLElement;\n\n// Feedback/System Chat Elements\nlet aiFeedbackView: HTMLElement;\nlet aiFeedbackHistory: HTMLElement;\nlet aiFeedbackInput: HTMLTextAreaElement;\nlet aiFeedbackSendBtn: HTMLButtonElement;\nlet feedbackTabBadge: HTMLElement;\nlet showJsonBtn: HTMLButtonElement; // NEW\n\n// Tabs\nlet tabAiChat: HTMLButtonElement;\nlet tabAiFeedback: HTMLButtonElement;\n\n// Internal Search Elements\nlet aiChatSearchToggleBtn: HTMLButtonElement;\nlet aiChatSearchContainer: HTMLElement;\nlet aiChatSearchInput: HTMLInputElement;\nlet aiChatCloseSearchBtn: HTMLButtonElement;\nlet aiChatSearchResults: HTMLElement;\n\n// --- STATE ---\ntype ActiveTab = 'chat' | 'feedback';\nlet activeTab: ActiveTab = 'chat';\nlet feedbackLocalHistory: ChatHistoryMessage[] = [];\n\nfunction switchTab(tab: ActiveTab) {\n    activeTab = tab;\n    \n    if (tab === 'chat') {\n        aiChatView.classList.remove('hidden');\n        aiFeedbackView.classList.add('hidden');\n        \n        tabAiChat.classList.add('border-blue-500', 'text-blue-400');\n        tabAiChat.classList.remove('border-transparent', 'text-gray-400');\n        \n        tabAiFeedback.classList.remove('border-blue-500', 'text-blue-400');\n        tabAiFeedback.classList.add('border-transparent', 'text-gray-400');\n        \n        renderChatHistory(appState.chatHistory, aiChatHistory);\n    } else {\n        aiChatView.classList.add('hidden');\n        aiFeedbackView.classList.remove('hidden');\n        \n        tabAiFeedback.classList.add('border-blue-500', 'text-blue-400');\n        tabAiFeedback.classList.remove('border-transparent', 'text-gray-400');\n        \n        tabAiChat.classList.remove('border-blue-500', 'text-blue-400');\n        tabAiChat.classList.add('border-transparent', 'text-gray-400');\n        \n        renderChatHistory(feedbackLocalHistory, aiFeedbackHistory);\n    }\n}\n\nfunction renderChatHistory(messages: ChatHistoryMessage[], container: HTMLElement) {\n    if (!container) return;\n    container.innerHTML = '';\n    const fragment = document.createDocumentFragment();\n\n    messages.forEach(message => {\n        if (message.role === 'user' && message.file) {\n             const attachmentContainer = document.createElement('div');\n             attachmentContainer.className = 'chat-attachment';\n             let attachmentHtml = '';\n             if (message.file.type.startsWith('image/')) {\n                 attachmentHtml = `<img src=\"${message.file.base64}\" alt=\"${message.file.name}\" />`;\n             } else {\n                 attachmentHtml = `<span>${message.file.name}</span>`;\n             }\n             attachmentContainer.innerHTML = attachmentHtml;\n             fragment.appendChild(attachmentContainer);\n        }\n\n        if (message.text) {\n            const bubble = document.createElement('div');\n            bubble.className = `chat-bubble ${message.role === 'user' ? 'chat-bubble-user' : 'chat-bubble-ai'}`;\n            bubble.innerHTML = markdownToHtml(message.text);\n            fragment.appendChild(bubble);\n        }\n    });\n    container.appendChild(fragment);\n    container.scrollTop = container.scrollHeight;\n}\n\nfunction renderChatFilePreview() {\n    if (!aiChatFilePreviewContainer) return;\n\n    if (appState.chatFile) {\n        const file = appState.chatFile.file;\n        let previewHtml = '';\n\n        if (file.type.startsWith('image/')) {\n            previewHtml = `<img src=\"${appState.chatFile.base64}\" alt=\"${file.name}\" />`;\n        } else {\n            previewHtml = `\n                <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-gray-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\" stroke-width=\"2\">\n                  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                </svg>\n                <span>${file.name}</span>\n            `;\n        }\n        \n        aiChatFilePreviewContainer.innerHTML = `\n            <div class=\"chat-file-preview\">\n                ${previewHtml}\n                <button id=\"removeChatFileBtn\" aria-label=\"Ta bort fil\">&times;</button>\n            </div>\n        `;\n        \n        document.getElementById('removeChatFileBtn')?.addEventListener('click', () => {\n            appState.chatFile = null;\n            aiChatFileInput.value = ''; // Reset file input\n            renderChatFilePreview();\n        });\n    } else {\n        aiChatFilePreviewContainer.innerHTML = '';\n    }\n}\n\nasync function applyFeedbackFromJson(feedbackJsonString: string): Promise<any | null> {\n    try {\n        const learningUpdate = await convertSummaryToJsonAI(feedbackJsonString);\n        if (learningUpdate) {\n            if (learningUpdate.learnedPreferences) {\n                learningUpdate.learnedPreferences.forEach((pref: { lookupKey: string; signId: string; vote: number; }) => {\n                    const { lookupKey, signId, vote } = pref;\n                    const votes = learnedPreferences.get(lookupKey) || new Map();\n                    votes.set(signId, (votes.get(signId) || 0) + vote);\n                    learnedPreferences.set(lookupKey, votes);\n                });\n            }\n            if (learningUpdate.newWords) {\n                    learningUpdate.newWords.forEach((word: { lookupKey: string; signs: Sign[]; }) => {\n                        localUserSigns.set(word.lookupKey, { signs: word.signs });\n                    });\n            }\n            if (learningUpdate.homonymResolutions) {\n                    learningUpdate.homonymResolutions.forEach((res: { word: string; pos: string; signId: string; signWord: string; }) => {\n                        const { word, pos, signId, signWord } = res;\n                        const posMap = homonymMap.get(word) || new Map();\n                        posMap.set(pos, { id: signId, word: signWord });\n                        homonymMap.set(word, posMap);\n                    });\n            }\n            \n            // Clear underlying data\n            clearFeedbackData();\n            \n            // Remove glow from AI button\n            const aiBtn = document.getElementById('askAiAboutStsBtn') as HTMLButtonElement;\n            if (aiBtn) {\n                aiBtn.classList.remove('glow-attention');\n            }\n            \n            // Save to IndexedDB (browser memory)\n            if (isDevMode()) {\n                await saveUserData();\n            }\n            return learningUpdate;\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error applying feedback:\", error);\n        return null;\n    }\n}\n\n// --- Main Chat Send Handler ---\nasync function handleSendChatMessage() {\n    // If in feedback mode, use the feedback handler\n    if (activeTab === 'feedback') {\n        handleSendFeedbackMessage();\n        return;\n    }\n\n    if (!appState.aiReady && !appState.usePuter) return;\n\n    const text = aiChatInput.value.trim();\n    const fileInfo = appState.chatFile;\n\n    if (!text && !fileInfo) return;\n\n    aiChatInput.value = '';\n    aiChatInput.style.height = 'auto'; \n    aiChatSendBtn.disabled = true;\n    \n    appState.chatFile = null;\n    if (aiChatFileInput) aiChatFileInput.value = '';\n    renderChatFilePreview();\n\n    const userMessage: ChatHistoryMessage = {\n        role: 'user',\n        text: text,\n        file: fileInfo ? {\n            name: fileInfo.file.name,\n            type: fileInfo.mimeType,\n            base64: fileInfo.base64\n        } : null\n    };\n    appState.chatHistory.push(userMessage);\n    renderChatHistory(appState.chatHistory, aiChatHistory);\n\n    const aiBubble = document.createElement('div');\n    aiBubble.className = 'chat-bubble chat-bubble-ai is-thinking';\n    aiBubble.textContent = '';\n    aiChatHistory.appendChild(aiBubble);\n    aiChatHistory.scrollTop = aiChatHistory.scrollHeight;\n\n    // Build message for Puter.js\n    const systemPrompt = 'Du √§r en hj√§lpsam expert p√• svenskt teckenspr√•k (STS). Svara p√• anv√§ndarens fr√•gor om tecken, grammatik och d√∂vkultur. Var koncis och pedagogisk.';\n    \n    // Build conversation history for multi-turn chat\n    const messages = appState.chatHistory\n        .filter(m => m.role === 'user' || m.role === 'model')\n        .map(m => ({\n            role: m.role === 'user' ? 'user' : 'assistant',\n            content: m.text || ''\n        }));\n    \n    // Add current message\n    messages.push({ role: 'user', content: text });\n    \n    try {\n        const puter = (window as any).puter;\n        if (puter && puter.ai) {\n            // Use Claude Sonnet 4.5 for better Swedish conversation\n            const response = await puter.ai.chat(messages, { \n                model: 'claude-sonnet-4-5',\n                system: systemPrompt\n            });\n            \n            // Handle different response formats\n            let fullResponse = '';\n            if (typeof response === 'string') {\n                fullResponse = response;\n            } else if (response?.message?.content) {\n                // Claude format: response.message.content[0].text or response.message.content\n                if (Array.isArray(response.message.content)) {\n                    fullResponse = response.message.content[0]?.text || '';\n                } else {\n                    fullResponse = response.message.content;\n                }\n            } else if (response?.text) {\n                fullResponse = response.text;\n            } else {\n                fullResponse = response?.toString() || '';\n            }\n            \n            aiBubble.innerHTML = markdownToHtml(fullResponse);\n            aiChatHistory.scrollTop = aiChatHistory.scrollHeight;\n            aiBubble.classList.remove('is-thinking');\n            appState.chatHistory.push({ role: 'model', text: fullResponse });\n        } else {\n            throw new Error('Puter.js AI not available');\n        }\n    } catch (error) {\n        console.error(\"Chat error:\", error);\n        const errorMessage = \"Urs√§kta, ett fel intr√§ffade. Kontrollera att du √§r inloggad p√• Puter.\";\n        aiBubble.textContent = errorMessage;\n        aiBubble.classList.remove('is-thinking');\n        appState.chatHistory.push({ role: 'model', text: errorMessage });\n    } finally {\n        aiChatSendBtn.disabled = false;\n        aiChatInput.focus();\n    }\n}\n\n// --- Feedback Chat Send Handler ---\nasync function handleSendFeedbackMessage() {\n    const text = aiFeedbackInput.value.trim();\n    if (!text) return;\n\n    aiFeedbackInput.value = '';\n    aiFeedbackSendBtn.disabled = true;\n\n    // Add user message locally\n    feedbackLocalHistory.push({ role: 'user', text: text });\n    renderChatHistory(feedbackLocalHistory, aiFeedbackHistory);\n\n    const aiBubble = document.createElement('div');\n    aiBubble.className = 'chat-bubble chat-bubble-ai is-thinking';\n    aiFeedbackHistory.appendChild(aiBubble);\n\n    // The JSON is now automatically updated in state\n    const jsonReport = appState.latestFeedbackJson || \"{}\";\n\n    const isConfirming = /^(ja|jo|spara|k√∂r|fixa|ok|okej)$/i.test(text);\n    const isRejecting = /^(nej|avbryt|sluta)$/i.test(text);\n    \n    if (isConfirming) {\n         aiBubble.textContent = \"Bearbetar din feedback...\";\n         const learningUpdate = await applyFeedbackFromJson(jsonReport);\n\n        if (learningUpdate) {\n            const jsonOutput = JSON.stringify(learningUpdate, null, 2);\n            const confirmationText = `Klart! Jag har uppdaterat appens lokala minne.\\n\\nH√§r √§r JSON-koden f√∂r dina √§ndringar:\\n\\n\\`\\`\\`json\\n${jsonOutput}\\n\\`\\`\\``;\n            \n            aiBubble.innerHTML = markdownToHtml(confirmationText);\n            feedbackLocalHistory.push({ role: 'model', text: confirmationText });\n            feedbackTabBadge.classList.add('hidden'); // Hide badge\n        } else {\n            const errorText = \"N√•got gick fel n√§r jag f√∂rs√∂kte spara √§ndringarna. F√∂rs√∂k igen senare.\";\n            aiBubble.innerHTML = markdownToHtml(errorText);\n            feedbackLocalHistory.push({ role: 'model', text: errorText });\n        }\n    } else if (isRejecting) {\n        const responseText = \"Okej, jag sparar inget just nu. √Öterkom om du √§ndrar dig!\";\n        aiBubble.textContent = responseText;\n        feedbackLocalHistory.push({ role: 'model', text: responseText });\n    } else {\n        // User is asking a question or discussing the feedback\n        // We use Puter.js AI\n        const puter = (window as any).puter;\n        if (!puter?.ai) {\n             aiBubble.textContent = \"AI-tj√§nsten √§r inte tillg√§nglig. K√∂r appen p√• puter.com f√∂r full funktionalitet.\";\n             feedbackLocalHistory.push({ role: 'model', text: \"AI-tj√§nsten √§r inte tillg√§nglig.\" });\n        } else {\n            try {\n                // Use the new factory function for the prompt\n                const prompt = createFeedbackChatPrompt(jsonReport, text);\n                \n                const response = await puter.ai.chat(prompt, { model: 'claude-sonnet-4-5' });\n                \n                // Handle different response formats\n                let responseText = '';\n                if (typeof response === 'string') {\n                    responseText = response;\n                } else if (response?.message?.content) {\n                    if (Array.isArray(response.message.content)) {\n                        responseText = response.message.content[0]?.text || '';\n                    } else {\n                        responseText = response.message.content;\n                    }\n                } else if (response?.text) {\n                    responseText = response.text;\n                } else {\n                    responseText = response?.toString() || '';\n                }\n                \n                aiBubble.innerHTML = markdownToHtml(responseText);\n                feedbackLocalHistory.push({ role: 'model', text: responseText });\n\n            } catch (e) {\n                console.error(e);\n                aiBubble.textContent = \"Kunde inte analysera din fr√•ga just nu.\";\n                feedbackLocalHistory.push({ role: 'model', text: \"Kunde inte analysera din fr√•ga just nu.\" });\n            }\n        }\n    }\n    \n    aiBubble.classList.remove('is-thinking');\n    aiFeedbackSendBtn.disabled = false;\n    aiFeedbackInput.focus();\n}\n\nfunction handleShowJson() {\n    // Add user-like message\n    feedbackLocalHistory.push({ role: 'user', text: \"Visa JSON med alla √§ndringar\" });\n    renderChatHistory(feedbackLocalHistory, aiFeedbackHistory);\n\n    const jsonReport = appState.latestFeedbackJson || \"Inga √§ndringar registrerade.\";\n    const formattedMessage = `H√§r √§r den aktuella JSON-datan f√∂r dina √§ndringar:\\n\\n\\`\\`\\`json\\n${jsonReport}\\n\\`\\`\\``;\n\n    feedbackLocalHistory.push({ role: 'model', text: formattedMessage });\n    \n    // Delay slightly to make it feel like a response\n    setTimeout(() => {\n        const bubble = document.createElement('div');\n        bubble.className = 'chat-bubble chat-bubble-ai';\n        bubble.innerHTML = markdownToHtml(formattedMessage);\n        aiFeedbackHistory.appendChild(bubble);\n        aiFeedbackHistory.scrollTop = aiFeedbackHistory.scrollHeight;\n    }, 300);\n}\n\n\nexport async function handleOpenChat(e: Event) {\n    // Always open the modal\n    openModal(aiChatModal, e.currentTarget as HTMLElement);\n    \n    // Check if Puter.js is available\n    const puter = (window as any).puter;\n    const aiAvailable = puter?.ai;\n    \n    // Update usePuter state\n    if (puter?.ai) {\n        appState.usePuter = true;\n        appState.aiReady = true;\n    }\n\n    // Initialize standard greeting if empty\n    if (appState.chatHistory.length === 0) {\n        if (aiAvailable) {\n            const greeting = \"Hej! Jag √§r din AI-assistent f√∂r STS-helper. St√§ll fr√•gor om svenskt teckenspr√•k, grammatik eller tecken!\";\n            appState.chatHistory.push({ role: 'model', text: greeting });\n        } else {\n            const greeting = \"Hej! AI-chatten √§r gratis via Puter.js. Du kan fortfarande ge feedback p√• tecken och spara √§ndringar i ditt personliga lexikon.\";\n            appState.chatHistory.push({ role: 'model', text: greeting });\n        }\n    }\n\n    // CHECK FOR PENDING FEEDBACK\n    const changeCount = feedbackMap.size + positiveFeedbackMap.size + negativeFeedbackMap.size + sentenceFeedbackMap.size; \n    \n    if (changeCount > 0) {\n        // Setup the feedback specific message\n        feedbackLocalHistory = []; // Reset local session for this specific interaction\n        const proactiveGreeting = `Hej! üëã Jag ser att du har gjort cirka ${changeCount} √§ndringar i tecknen (tumme upp/ner/byten).\\n\\nVill du att jag sparar dessa √§ndringar till ditt personliga lexikon i minnet nu? (Svara 'Ja' eller 'Spara').`;\n        \n        feedbackLocalHistory.push({ role: 'model', text: proactiveGreeting });\n        \n        // Update Badge\n        feedbackTabBadge.textContent = changeCount.toString();\n        feedbackTabBadge.classList.remove('hidden');\n        \n        // Auto-switch to Feedback Tab\n        switchTab('feedback');\n    } else {\n        feedbackTabBadge.classList.add('hidden');\n        switchTab('chat');\n    }\n}\n\n// --- INTERNAL SEARCH FUNCTIONALITY ---\n\nfunction createMiniVideoCard(sign: Sign): HTMLElement {\n    const card = document.createElement('div');\n    card.className = 'video-card alternative-item text-xs';\n    card.style.cssText = 'aspect-ratio: 1/1; border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; cursor: pointer; background: var(--bg-dark);';\n    \n    const playerWrapper = document.createElement('div');\n    playerWrapper.style.cssText = 'position: relative; width: 100%; height: 100%;';\n\n    const video = document.createElement('video');\n    video.className = 'video-card-player';\n    video.src = buildVideoUrl(sign.id, sign.word);\n    video.loop = true;\n    video.muted = true;\n    video.playsInline = true;\n    video.disablePictureInPicture = true;\n    video.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';\n\n    const title = document.createElement('div');\n    title.textContent = sign.word.toUpperCase();\n    title.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: white; padding: 4px; text-align: center; font-weight: bold; pointer-events: none;';\n\n    // Action button overlay\n    const actionOverlay = document.createElement('div');\n    actionOverlay.style.cssText = 'position: absolute; top: 4px; right: 4px; background: rgba(0,0,0,0.5); border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; color: white; opacity: 0.8;';\n    actionOverlay.innerHTML = '+';\n    \n    playerWrapper.append(video, title, actionOverlay);\n    card.appendChild(playerWrapper);\n\n    // Hover to play\n    card.onmouseenter = () => video.play().catch(() => {});\n    card.onmouseleave = () => {\n        video.pause();\n        video.currentTime = 0;\n    };\n\n    // Click to insert\n    card.onclick = (e) => {\n        e.stopPropagation();\n        // Insert formatted text into chat input\n        const textToInsert = ` [Tecken: ${sign.word.toUpperCase()} (ID: ${sign.id})] `;\n        aiChatInput.value += textToInsert;\n        aiChatInput.focus();\n        closeInternalSearch();\n        showMessage(`Infogade \"${sign.word}\" i chatten.`, 'success');\n    };\n\n    return card;\n}\n\nfunction openInternalSearch() {\n    aiChatSearchContainer.classList.remove('hidden');\n    aiChatSearchContainer.classList.add('flex');\n    aiChatSearchInput.focus();\n}\n\nfunction closeInternalSearch() {\n    aiChatSearchContainer.classList.add('hidden');\n    aiChatSearchContainer.classList.remove('flex');\n    aiChatSearchInput.value = '';\n    aiChatSearchResults.innerHTML = '';\n}\n\nfunction handleInternalSearchInput() {\n    const query = aiChatSearchInput.value.trim().toLowerCase();\n    aiChatSearchResults.innerHTML = '';\n\n    if (query.length < 1) return;\n\n    const words = getSortedSearchResults(query, 50);\n    const fragment = document.createDocumentFragment();\n    \n    words.forEach(word => {\n        const signs = localLexiconMap.get(word);\n        if (signs) {\n            signs.forEach(sign => {\n                fragment.appendChild(createMiniVideoCard(sign));\n            });\n        }\n    });\n\n    if (fragment.children.length === 0) {\n        aiChatSearchResults.innerHTML = '<p class=\"col-span-full text-center text-gray-400 mt-4\">Inga tr√§ffar.</p>';\n    } else {\n        aiChatSearchResults.appendChild(fragment);\n    }\n}\n\nexport function setupChatEventListeners() {\n    // Initialize DOM elements\n    aiChatModal = document.getElementById('askAiAboutStsModal') as HTMLElement;\n    \n    // Views\n    aiChatView = document.getElementById('aiChatView') as HTMLElement;\n    aiFeedbackView = document.getElementById('aiFeedbackView') as HTMLElement;\n    \n    // Tabs\n    tabAiChat = document.getElementById('tabAiChat') as HTMLButtonElement;\n    tabAiFeedback = document.getElementById('tabAiFeedback') as HTMLButtonElement;\n    feedbackTabBadge = document.getElementById('feedbackTabBadge') as HTMLElement;\n    \n    // General Chat\n    aiChatHistory = document.getElementById('aiChatHistory') as HTMLElement;\n    aiChatInput = document.getElementById('aiChatInput') as HTMLTextAreaElement;\n    aiChatSendBtn = document.getElementById('aiChatSendBtn') as HTMLButtonElement;\n    aiChatFileUploadBtn = document.getElementById('aiChatFileUploadBtn') as HTMLButtonElement;\n    aiChatFileInput = document.getElementById('aiChatFileInput') as HTMLInputElement;\n    aiChatFilePreviewContainer = document.getElementById('aiChatFilePreviewContainer') as HTMLElement;\n    \n    // Feedback Chat\n    aiFeedbackHistory = document.getElementById('aiFeedbackHistory') as HTMLElement;\n    aiFeedbackInput = document.getElementById('aiFeedbackInput') as HTMLTextAreaElement;\n    aiFeedbackSendBtn = document.getElementById('aiFeedbackSendBtn') as HTMLButtonElement;\n    showJsonBtn = document.getElementById('showJsonBtn') as HTMLButtonElement;\n    \n    // Search\n    aiChatSearchToggleBtn = document.getElementById('aiChatSearchToggleBtn') as HTMLButtonElement;\n    aiChatSearchContainer = document.getElementById('aiChatSearchContainer') as HTMLElement;\n    aiChatSearchInput = document.getElementById('aiChatSearchInput') as HTMLInputElement;\n    aiChatCloseSearchBtn = document.getElementById('aiChatCloseSearchBtn') as HTMLButtonElement;\n    aiChatSearchResults = document.getElementById('aiChatSearchResults') as HTMLElement;\n\n    const aiChatBtn = document.getElementById('askAiAboutStsBtn') as HTMLButtonElement;\n    aiChatBtn?.addEventListener('click', handleOpenChat);\n\n    // Clear History Button\n    const clearChatBtn = document.getElementById('clearChatHistoryBtn');\n    clearChatBtn?.addEventListener('click', () => {\n        if(confirm(\"Vill du rensa chatthistoriken?\")) {\n            appState.chatHistory = [];\n            renderChatHistory([], aiChatHistory);\n            // Re-add greeting\n            const greeting = \"Hej! Jag √§r din AI-assistent f√∂r STS-helper. Hur kan jag hj√§lpa dig idag?\";\n            appState.chatHistory.push({ role: 'model', text: greeting });\n            renderChatHistory(appState.chatHistory, aiChatHistory);\n        }\n    });\n\n    // Tab Switch Listeners\n    tabAiChat?.addEventListener('click', () => switchTab('chat'));\n    tabAiFeedback?.addEventListener('click', () => switchTab('feedback'));\n\n    // Chat Input Listeners\n    aiChatSendBtn?.addEventListener('click', handleSendChatMessage);\n    aiChatInput?.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSendChatMessage();\n        }\n    });\n    aiChatInput?.addEventListener('input', () => {\n        aiChatInput.style.height = 'auto';\n        aiChatInput.style.height = (aiChatInput.scrollHeight) + 'px';\n    });\n    \n    // Feedback Input Listeners\n    aiFeedbackSendBtn?.addEventListener('click', handleSendFeedbackMessage);\n    aiFeedbackInput?.addEventListener('keydown', (e) => {\n         if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            handleSendFeedbackMessage();\n        }\n    });\n\n    // Show JSON Button Listener\n    showJsonBtn?.addEventListener('click', handleShowJson);\n\n    aiChatFileUploadBtn?.addEventListener('click', () => aiChatFileInput.click());\n    aiChatFileInput?.addEventListener('change', async (e) => {\n        const target = e.target as HTMLInputElement;\n        const file = target.files?.[0];\n        if (file) {\n            try {\n                const base64 = await fileToBase64(file);\n                appState.chatFile = { file, base64, mimeType: file.type };\n                renderChatFilePreview();\n            } catch (error) {\n                console.error(\"Fel vid filinl√§sning:\", error);\n                showMessage(\"Kunde inte l√§sa filen.\", \"error\");\n            }\n        }\n    });\n\n    // Internal Search Listeners\n    aiChatSearchToggleBtn?.addEventListener('click', openInternalSearch);\n    aiChatCloseSearchBtn?.addEventListener('click', closeInternalSearch);\n    aiChatSearchInput?.addEventListener('input', handleInternalSearchInput);\n\n    // Global delegation for dynamically created Copy Buttons in Chat\n    aiChatModal?.addEventListener('click', async (e) => {\n        const target = e.target as HTMLElement;\n        const btn = target.closest('.code-copy-btn');\n        \n        if (btn) {\n            const wrapper = btn.closest('.code-block-wrapper');\n            const codeEl = wrapper?.querySelector('code');\n            if (codeEl && codeEl.textContent) {\n                try {\n                    await navigator.clipboard.writeText(codeEl.textContent);\n                    const originalHtml = btn.innerHTML;\n                    btn.innerHTML = `<span>Kopierad!</span>`;\n                    setTimeout(() => {\n                        btn.innerHTML = originalHtml;\n                    }, 2000);\n                    showMessage(\"Kopierat till urklipp!\", \"success\");\n                } catch (err) {\n                    console.error(\"Copy failed\", err);\n                    showMessage(\"Kunde inte kopiera.\", \"error\");\n                }\n            }\n        }\n    });\n}","path":null,"size_bytes":27628,"size_tokens":null},"src/components/__tests__/modals.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as modals from '../modals';\n\ndescribe('modals module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(modals).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r modal-logik h√§r\n});\n","path":null,"size_bytes":374,"size_tokens":null},"src/modules/core/reset.ts":{"content":"\nimport { appState } from '../../state';\nimport { updateButtonProgress, originalTextDisplay, isDevMode } from '../../ui';\nimport { saveUserData } from '../../hooks/useLexicon';\nimport { closeModal } from '../../components/modals';\nimport { resetAndShowGrammarPlaceholder } from '../../components/VideoGrid';\nimport { initializePlaceholder } from '../ui/textDisplay';\n\nexport async function resetApp() {\n    // DOM Elements\n    const videoDisplayContainer = document.getElementById('videoDisplayContainer') as HTMLElement;\n    const toolsAndActionsContainer = document.getElementById('tools-and-actions-container') as HTMLElement;\n    const videoNavControls = document.getElementById('videoNavControls') as HTMLElement;\n    const videoGrid = document.getElementById('videoGrid') as HTMLElement;\n    const alphabetGrid = document.getElementById('alphabetGrid') as HTMLElement;\n    const playAllBtn = document.getElementById('playAllBtn') as HTMLButtonElement;\n    const clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\n    const toolsContainer = document.getElementById('tools-container') as HTMLElement;\n    const glosaPane = document.getElementById('glosaPane') as HTMLElement;\n    const glosaPreview = document.getElementById('glosaPreview') as HTMLTextAreaElement;\n    const glosaStatus = document.getElementById('glosaStatus') as HTMLElement;\n    const saveGlosaBtn = document.getElementById('saveGlosaBtn') as HTMLButtonElement;\n\n    appState.videoObserver?.disconnect();\n    appState.alphabetObserver?.disconnect();\n\n    document.querySelectorAll('.modal.show').forEach(modal => {\n        closeModal(modal as HTMLElement);\n    });\n\n    if(originalTextDisplay) originalTextDisplay.innerHTML = '';\n    if(videoDisplayContainer) videoDisplayContainer.classList.add('hidden');\n    if(toolsAndActionsContainer) toolsAndActionsContainer.classList.add('hidden');\n    if(videoNavControls) videoNavControls.classList.add('hidden');\n    if(videoGrid) videoGrid.innerHTML = '';\n    \n    // Reset GLOSA panel\n    if(glosaPane) glosaPane.classList.add('hidden');\n    if(glosaPreview) glosaPreview.value = '';\n    if(saveGlosaBtn) saveGlosaBtn.classList.add('hidden');\n    if(glosaStatus) {\n        glosaStatus.className = 'glosa-status';\n        glosaStatus.textContent = '';\n    }\n    \n    resetAndShowGrammarPlaceholder();\n    \n    appState.isClickableMode = true; \n    appState.wordMap = [];\n    appState.videoSuggestions = [];\n    appState.selection = [];\n    appState.combinationSelection = [];\n    appState.chat = null;\n    appState.chatHistory = [];\n    appState.chatFile = null;\n    \n    if (isDevMode()) {\n        await saveUserData();\n    }\n\n    if (toolsContainer) {\n        toolsContainer.querySelectorAll('button.tool-btn').forEach(btn => {\n            (btn as HTMLButtonElement).disabled = true;\n            btn.classList.remove('active');\n        });\n    }\n    \n    if(videoGrid) videoGrid.dataset.activeTool = 'none';\n    if(alphabetGrid) alphabetGrid.dataset.activeTool = 'none';\n\n    appState.latestReportContent = null;\n    appState.latestFeedbackJson = \"\";\n    appState.sentences = [];\n    appState.currentSentenceIndex = 0;\n    appState.currentGrammarSentenceIndex = 0;\n    appState.aiTranslatedSentences.clear();\n    appState.isShowingAllSentences = false;\n    appState.isPlayingAll = false;\n    if (playAllBtn) playAllBtn.textContent = 'Spela Alla';\n    updateButtonProgress('idle');\n    initializePlaceholder();\n\n    if (clearBtn) {\n        clearBtn.classList.add('glow-once-feedback');\n        setTimeout(() => {\n            clearBtn.classList.remove('glow-once-feedback');\n        }, 800);\n    }\n}\n","path":null,"size_bytes":3636,"size_tokens":null},"src/components/__tests__/Loader.full.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport Loader from '../Loader';\nimport { render } from '@testing-library/react';\n\ndescribe('Loader component (full test)', () => {\n  it('should render without crashing', () => {\n    const { container } = render(<Loader />);\n    expect(container).toBeTruthy();\n  });\n\n  // L√§gg till tester f√∂r loader-animation och tillst√•nd h√§r\n});\n","path":null,"size_bytes":383,"size_tokens":null},"src/App.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport App from './App';\nimport { render } from '@testing-library/react';\n\ndescribe('App component', () => {\n  it('should render without crashing', () => {\n    const { container } = render(<App />);\n    expect(container).toBeTruthy();\n  });\n\n  // L√§gg till tester f√∂r appens huvudfunktioner och navigation h√§r\n});\n","path":null,"size_bytes":364,"size_tokens":null},"src/styles/base.css":{"content":"body { \n    font-family: 'Inter', system-ui, -apple-system, sans-serif; \n    background-color: var(--bg-body);\n    background-image: var(--bg-gradient);\n    background-attachment: fixed;\n    background-size: cover;\n    color: var(--text-primary);\n    font-size: var(--text-body);\n    line-height: 1.5;\n    padding-top: 5.5rem; \n    padding-bottom: 7rem;\n    transition: background-color 0.3s, color 0.3s;\n    min-height: 100vh;\n    -webkit-font-smoothing: antialiased;\n    touch-action: pan-x pan-y pinch-zoom;\n}\n\nh1 { font-size: var(--text-h1); font-weight: 700; line-height: 1.2; }\nh2 { font-size: var(--text-h2); font-weight: 700; line-height: 1.3; }\nh3 { font-size: var(--text-h3); font-weight: 600; line-height: 1.4; }\np, span, label { font-size: var(--text-body); }\nsmall, .caption { font-size: var(--text-caption); }\n\n/* Mobile Responsive */\n@media (max-width: 640px) {\n    body {\n        padding-top: 4rem;\n        padding-bottom: 5rem;\n        font-size: 16px; /* Prevent iOS zoom */\n    }\n}\n\n/* Mobile Landscape Orientation */\n@media (max-width: 640px) and (orientation: landscape) {\n    body {\n        padding-top: 3rem;\n        padding-bottom: 3.5rem;\n    }\n}\n\n*:focus-visible {\n    outline: 2px solid var(--primary-blue);\n    outline-offset: 2px;\n    border-radius: var(--border-radius-sm);\n}\n\n/* Custom Scrollbar */\n::-webkit-scrollbar {\n    width: 10px;\n    height: 10px;\n}\n::-webkit-scrollbar-track {\n    background: rgba(0, 0, 0, 0.05);\n}\n::-webkit-scrollbar-thumb {\n    background: var(--border-light);\n    border-radius: 5px;\n    border: 2px solid transparent;\n    background-clip: content-box;\n}\n::-webkit-scrollbar-thumb:hover {\n    background-color: var(--text-tertiary);\n}\n","path":null,"size_bytes":1696,"size_tokens":null},"start_ai_diff.sh":{"content":"#!/bin/bash\n# Detta script g√∂r din AI \"smart\" direkt genom att mata den med prompt + minne + diff\n\nPROMPT_FILE=\"ai_prompts/mega_prompt.txt\"\nMEMORY_FILE=\".ai_project_memory.txt\"\n\necho \"==================================================\"\necho \"ü§ñ LADDAR REPLIT-MODE F√ñR COPILOT...\"\necho \"==================================================\"\necho \"\"\necho \"--- [1] DIN MEGA PROMPT ---\"\ncat \"$PROMPT_FILE\"\necho \"\"\necho \"--------------------------------------------------\"\necho \"\"\necho \"--- [2] PROJEKTETS MINNE (FILSTRUKTUR) ---\"\nif [ -f \"$MEMORY_FILE\" ]; then\n    cat \"$MEMORY_FILE\"\nelse\n    echo \"‚ö†Ô∏è Ingen minnesfil hittad. AI kommer skapa en ny.\"\n    # Generera en lista nu om den saknas\n    find . -maxdepth 3 -not -path '*/.*' -not -path './node_modules*'\nfi\necho \"\"\necho \"--------------------------------------------------\"\necho \"\"\necho \"‚úÖ KLART! Markera allt ovanf√∂r denna rad, kopiera och klistra in i Copilot Chat.\"\necho \"==================================================\"\n","path":null,"size_bytes":988,"size_tokens":null},"src/services/ui/notificationService.ts":{"content":"\n// Constants\nexport const ICON_LOADING_SVG = '<svg class=\"animate-spin h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\"><circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle><path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path></svg>';\n\n// DOM Elements (Internal usage for this service)\nexport const messageBox = document.getElementById('messageBox') as HTMLElement;\n\nexport function showMessage(message: string, type: 'success' | 'error' = 'success', duration: number = 4000) {\n    if (!messageBox) return;\n    \n    messageBox.textContent = message;\n    messageBox.className = 'message-box p-4 rounded-xl font-bold text-center text-lg backdrop-blur-md shadow-lg';\n    if (type === 'success') {\n        messageBox.style.backgroundColor = 'rgba(16, 185, 129, 0.9)';\n        messageBox.style.color = 'white';\n        messageBox.style.border = '1px solid rgba(255,255,255,0.2)';\n    } else {\n        messageBox.style.backgroundColor = 'rgba(239, 68, 68, 0.9)';\n        messageBox.style.color = 'white';\n        messageBox.style.border = '1px solid rgba(255,255,255,0.2)';\n    }\n    messageBox.classList.add('show');\n    setTimeout(() => {\n        messageBox.classList.remove('show');\n    }, duration);\n}\n\nexport function showProgressStartup(progress: number, source: 'local' | 'online') {\n    const messageBox = document.getElementById('messageBox') as HTMLElement;\n    if (!messageBox) return;\n    \n    const sourceText = source === 'local' ? 'üìç Laddar lokalt' : '‚òÅÔ∏è Laddar online';\n    messageBox.innerHTML = `<div class=\"text-center\">\n        <div>${sourceText}</div>\n        <div class=\"text-sm mt-1\">${progress}% f√§rdigt</div>\n        <div class=\"w-full bg-gray-600 rounded-full h-2 mt-2 overflow-hidden\">\n            <div class=\"h-full bg-blue-500\" style=\"width: ${progress}%\"></div>\n        </div>\n    </div>`;\n    messageBox.style.backgroundColor = 'rgba(59, 130, 246, 0.9)';\n    messageBox.style.color = 'white';\n    messageBox.classList.add('show');\n}\n\nexport function updateButtonProgress(\n    state: 'idle' | 'loading' | 'local_search' | 'ai_refine' | 'success'\n) {\n    const convertBtn = document.getElementById('convertBtn') as HTMLButtonElement;\n    const analysisStatus = document.getElementById('analysisStatus') as HTMLElement;\n    const clearBtn = document.getElementById('clearBtn') as HTMLButtonElement;\n    const cancelSearchBtn = document.getElementById('cancelSearchBtn') as HTMLButtonElement;\n    const analysisContainer = document.getElementById('analysisContainer') as HTMLElement;\n    const originalTextDisplay = document.getElementById('originalTextDisplay') as HTMLElement;\n    const wrapper = document.querySelector('.input-aurora-wrapper');\n\n    if (!convertBtn || !analysisStatus || !clearBtn || !cancelSearchBtn) return;\n\n    const originalText = 'S√∂k';\n    const states = {\n        idle: { html: `<span>${originalText}</span>`, disabled: false, showStatus: false, searching: false },\n        loading: { html: `${ICON_LOADING_SVG} <span>Startar...</span>`, disabled: true, showStatus: true, searching: true },\n        local_search: { html: `${ICON_LOADING_SVG} <span>Snabbs√∂ker...</span>`, disabled: true, showStatus: true, searching: true },\n        ai_refine: { html: `${ICON_LOADING_SVG} <span>F√∂rfinar med AI...</span>`, disabled: true, showStatus: true, searching: true },\n        success: { html: `<span>Klart!</span>`, disabled: true, showStatus: false, searching: false }\n    };\n    \n    const currentState = states[state];\n    \n    convertBtn.disabled = currentState.disabled;\n    clearBtn.disabled = currentState.disabled;\n    convertBtn.innerHTML = currentState.html;\n\n    // Toggle Aurora Animation\n    if (wrapper) {\n        if (currentState.searching) {\n            wrapper.classList.add('is-searching');\n        } else {\n            wrapper.classList.remove('is-searching');\n        }\n    }\n\n    if (currentState.showStatus) {\n        analysisStatus.innerHTML = currentState.html; // Use the same html\n        if (analysisContainer) analysisContainer.classList.remove('hidden');\n        cancelSearchBtn.classList.remove('hidden');\n    } else {\n        if (analysisContainer) analysisContainer.classList.add('hidden');\n        cancelSearchBtn.classList.add('hidden');\n    }\n\n    if (state === 'success') {\n        setTimeout(() => updateButtonProgress('idle'), 1500);\n    } else if (state === 'idle') {\n        const isOnline = navigator.onLine;\n        const btnSpan = convertBtn.querySelector('span');\n        if (!isOnline) {\n            convertBtn.disabled = true;\n            if (btnSpan) btnSpan.textContent = 'Offline';\n        } else {\n             const hasText = originalTextDisplay && originalTextDisplay.innerText?.trim() && originalTextDisplay.innerText !== originalTextDisplay.dataset.placeholder;\n             convertBtn.disabled = !hasText;\n             if (btnSpan) btnSpan.textContent = originalText;\n        }\n    }\n}\n","path":null,"size_bytes":5080,"size_tokens":null},"src/components/__tests__/Loader.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport Loader from '../Loader';\nimport { render } from '@testing-library/react';\n\ndescribe('Loader component', () => {\n  it('should render without crashing', () => {\n    const { container } = render(<Loader />);\n    expect(container).toBeTruthy();\n  });\n\n  // L√§gg till tester f√∂r loader-animation och tillst√•nd h√§r\n});\n","path":null,"size_bytes":371,"size_tokens":null},"src/components/__tests__/modalsystem.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as ModalSystem from './ModalSystem';\n\ndescribe('ModalSystem module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(ModalSystem).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r modalsystem-logik h√§r\n});\n","path":null,"size_bytes":399,"size_tokens":null},"src/styles/components/cards.css":{"content":"\n/* --- VIDEO CARDS LAYOUT --- */\n.video-card {\n    aspect-ratio: 1 / 1;\n    overflow: hidden;\n    display: block;\n    position: relative;\n    border-radius: var(--border-radius-md);\n    border: 2px solid transparent;\n}\n.video-card-player-wrapper {\n    aspect-ratio: 1 / 1;\n    width: 100%;\n    position: relative;\n    overflow: hidden; /* Ensure video corners are rounded */\n    border-radius: var(--border-radius-md);\n}\n.video-card-player {\n     width: 100%;\n     height: 100%;\n     object-fit: cover;\n}\n.video-card-title {\n    position: absolute;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    padding: 1.5rem var(--space-sm) var(--space-sm);\n    text-align: center;\n    z-index: 5;\n    pointer-events: none;\n    font-size: 1rem;\n    font-weight: 600;\n    line-height: 1.3;\n}\n.video-card-no-sign {\n     padding: var(--space-md);\n     display: flex;\n     align-items: center;\n     justify-content: center;\n     text-align: center;\n     flex-direction: column;\n     gap: var(--space-md);\n     aspect-ratio: 1/1;\n     border-radius: var(--border-radius-md);\n}\n\n.video-card-placeholder {\n    background-color: var(--bg-dark);\n    border-color: var(--border-light);\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    padding: var(--space-sm);\n}\n.placeholder-content {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    gap: var(--space-sm);\n    color: var(--text-secondary);\n    text-align: center;\n    font-size: 0.8rem;\n}\n\n.action-buttons {\n    position: absolute;\n    top: var(--space-sm);\n    right: var(--space-sm);\n    z-index: 10;\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-xs);\n    opacity: 1;\n}\n.video-card-btn {\n    width: 2.25rem;\n    height: 2.25rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: var(--border-radius-md);\n}\n\n.combination-order-badge {\n    position: absolute;\n    top: var(--space-sm);\n    left: var(--space-sm);\n    z-index: 10;\n    width: 1.75rem;\n    height: 1.75rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-radius: 50%;\n    font-weight: bold;\n}\n\n/* Styles for Lexicon Explorer word-only cards */\n.video-card.word-only-card {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-direction: column;\n    background-color: var(--bg-dark);\n    cursor: pointer;\n    text-align: center;\n    border: 2px solid var(--border-light);\n    position: relative; /* For the overlay */\n}\n\n.video-card.word-only-card:hover {\n    border-color: var(--primary-blue);\n    background-color: var(--border-color);\n}\n\n.video-card.word-only-card .video-card-title {\n    position: static; /* Override absolute positioning */\n    background: none;\n    text-shadow: none;\n    color: var(--text-tertiary);\n    padding: var(--space-xs);\n    font-size: 0.9rem;\n    font-weight: 600;\n    line-height: 1.2;\n}\n\n.play-icon-overlay {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    opacity: 0.15;\n    transition: opacity var(--transition-fast);\n    pointer-events: none; /* Make sure it doesn't block clicks */\n}\n\n.video-card.word-only-card:hover .play-icon-overlay {\n    opacity: 0.7;\n}\n\n.video-card.word-only-card .play-icon-overlay svg {\n    color: var(--text-secondary);\n}\n","path":null,"size_bytes":3367,"size_tokens":null},"src/modules/handlers/navHandlers.ts":{"content":"\nimport { appState } from '../../state';\nimport { renderCurrentSentence, populateVideoGrid, updateNavControls, renderGrammarGrid } from '../../components/VideoGrid';\nimport { handlePlayAll } from '../features/playback';\nimport { translateToGlosa } from '../../hooks/useAI';\nimport { showMessage, getLexiconUrl } from '../../ui';\nimport { findCandidatesForToken } from '../search/localSearchWithFallback';\nimport { renderGlossesOnly } from '../features/renderGlosses';\nimport { renderAnalyzedText } from '../ui/textDisplay';\nimport { openSignDetailsModal } from '../../components/modals';\nimport { displayWordInfo } from '../features/wordInfo';\nimport { splitTextIntoSentences } from '../logic/textProcessing';\nimport { enrichWordMapDataInBackground } from '../../hooks/useDataEnrichment';\nimport { WordMapEntry } from '../../types';\nimport { openFeedbackPreviewModal } from '../feedback/feedbackPreviewModal';\nimport { updateFeedbackBadge, clearFeedbackGlow } from '../../services/ui/feedbackNotificationService';\n\n// DOM Elements for video display\nconst videoDisplayContainer = document.getElementById('videoDisplayContainer') as HTMLElement;\nconst toolsAndActionsContainer = document.getElementById('tools-and-actions-container') as HTMLElement;\nconst showAllVideosBtn = document.getElementById('showAllVideosBtn') as HTMLButtonElement;\n\n/**\n * GLOSA Video Update Function\n * Anv√§nder EXAKT samma fl√∂de som Search:\n * tokeniserar ‚Üí findCandidates ‚Üí renderCurrentSentence ‚Üí populateVideoGrid\n */\nexport async function updateGlosaVideos(glossaResult: string) {\n    try {\n        // Splitta GLOSA exakt som Search g√∂r\n        const tokens = glossaResult.split(/([,.\"!?\\n\\s]+)/g).filter(token => token.length > 0);\n        \n        if (tokens.length === 0) {\n            console.warn('‚ö†Ô∏è Inga GLOSA-token att visa');\n            return;\n        }\n        \n        console.log(`üìç GLOSA processerar ${tokens.length} token exakt som Search`);\n        \n        // Anv√§nd samma tokeniseringsprocess som Search\n        const promises = tokens.map(async (token): Promise<WordMapEntry> => {\n            // Om token bara √§r skiljetecken, radbrytningar eller mellanslag\n            if (/^[\\s,.\"!?\\n]+$/.test(token)) {\n                return { original: token, base: token, isWord: false, pos: 'PUNCT', signs: null };\n            }\n\n            // S√∂k i lokalt lexikon - SAMMA som Search\n            const cand = await findCandidatesForToken(token);\n            \n            if (cand) {\n                return {\n                    original: token,\n                    base: cand.base,\n                    isWord: true,\n                    pos: '',\n                    signs: cand.signs,\n                    isCompound: !!cand.isCompound,\n                    rationale: cand.method\n                };\n            } else {\n                return {\n                    original: token,\n                    base: token.toLowerCase().trim(),\n                    isWord: true,\n                    pos: '',\n                    signs: null,\n                    isCompound: false,\n                    rationale: 'Ingen lokalt tecken hittades'\n                };\n            }\n        });\n\n        const glosaWordMap = await Promise.all(promises);\n        \n        if (glosaWordMap.length > 0) {\n            console.log(`‚úÖ GLOSA: ${glosaWordMap.length} ord, anropar renderCurrentSentence ‚Üí populateVideoGrid`);\n            \n            // Uppdatera appState - SAMMA som Search\n            appState.wordMap = glosaWordMap;\n            appState.sentences = splitTextIntoSentences(glosaWordMap);\n            appState.currentSentenceIndex = 0;\n            appState.currentGrammarSentenceIndex = 0;\n            \n            if(showAllVideosBtn) showAllVideosBtn.textContent = 'Visa Alla';\n            appState.isShowingAllSentences = false;\n            appState.aiTranslatedSentences.clear();\n            \n            // Funktionen f√∂r att hantera ord-klick - SAMMA som Search\n            const handleWordClick = (wordData: WordMapEntry, openerElement: HTMLElement) => {\n                if (wordData.signs && wordData.signs.length > 0) {\n                    appState.modalContexts.signDetailsContext = wordData;\n                    openSignDetailsModal(wordData, openerElement);\n                    displayWordInfo(wordData.base);\n                } else {\n                    const targetUrl = getLexiconUrl('search', wordData.base);\n                    if (targetUrl) {\n                        window.open(targetUrl, '_blank');\n                    }\n                }\n            };\n            \n            // Visa videokontroller - SAMMA som Search\n            if (videoDisplayContainer) videoDisplayContainer.classList.remove('hidden');\n            if (toolsAndActionsContainer) toolsAndActionsContainer.classList.remove('hidden');\n            \n            // GLOSA FL√ñDE (svenskan bevaras i originalTextDisplay):\n            // 1. Visa GLOSA-orden √∂verst (svenskan finns redan kvar)\n            renderGlossesOnly(glosaWordMap);\n            \n            // 3. Anropa renderCurrentSentence (samma som Search)\n            renderCurrentSentence();\n            \n            // populateVideoGrid anropas inuti renderCurrentSentence, s√• vi f√•r videorna automatiskt\n            \n            updateNavControls();\n            \n            // 4. Starta bakgrundsbearbetning - SAMMA som Search\n            enrichWordMapDataInBackground(glosaWordMap);\n            \n            // Scroll till videorna\n            const videoGrid = document.getElementById('videoGrid');\n            if (videoGrid) {\n                setTimeout(() => {\n                    videoGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });\n                }, 100);\n            }\n        } else {\n            console.warn('‚ö†Ô∏è Inga GLOSA-ord att visa');\n        }\n    } catch (error) {\n        console.error('‚ùå Fel vid GLOSA-uppdatering:', error);\n    }\n}\n\nexport function setupNavHandlers() {\n    const prevSentenceBtn = document.getElementById('prevSentenceBtn') as HTMLButtonElement;\n    const nextSentenceBtn = document.getElementById('nextSentenceBtn') as HTMLButtonElement;\n    const showAllVideosBtn = document.getElementById('showAllVideosBtn') as HTMLButtonElement;\n    const playAllBtn = document.getElementById('playAllBtn') as HTMLButtonElement;\n    const askAiAboutStsBtn = document.getElementById('askAiAboutStsBtn') as HTMLButtonElement;\n    const feedbackNavBtn = document.getElementById('feedbackNavBtn') as HTMLButtonElement;\n\n    feedbackNavBtn?.addEventListener('click', () => {\n        clearFeedbackGlow();\n        openFeedbackPreviewModal();\n    });\n    \n    updateFeedbackBadge();\n\n    // Main Sentence Navigation\n    prevSentenceBtn?.addEventListener('click', () => {\n        if (appState.currentSentenceIndex > 0) {\n            appState.currentSentenceIndex--;\n            renderCurrentSentence();\n        }\n    });\n\n    nextSentenceBtn?.addEventListener('click', () => {\n        if (appState.currentSentenceIndex < appState.sentences.length - 1) {\n            appState.currentSentenceIndex++;\n            renderCurrentSentence();\n        }\n    });\n\n    // Show All / Show Individual\n    showAllVideosBtn?.addEventListener('click', () => {\n        appState.isShowingAllSentences = !appState.isShowingAllSentences;\n        showAllVideosBtn.textContent = appState.isShowingAllSentences ? 'Visa Enskilda' : 'Visa Alla';\n        if (appState.isShowingAllSentences) {\n             const allWords = appState.sentences.flat();\n            populateVideoGrid(allWords);\n        } else {\n            renderCurrentSentence();\n        }\n        updateNavControls();\n    });\n\n    // Play All\n    playAllBtn?.addEventListener('click', handlePlayAll);\n\n    // GLOSA Button - Ask AI about Swedish Sign Language\n    askAiAboutStsBtn?.addEventListener('click', async () => {\n        const textDisplay = document.getElementById('originalTextDisplay');\n        if (!textDisplay || !textDisplay.textContent?.trim()) {\n            showMessage('‚ùå Skriv eller klistra in text f√∂rst', 'error', 3000);\n            return;\n        }\n\n        const textContent = textDisplay.textContent.trim();\n        askAiAboutStsBtn.disabled = true;\n        askAiAboutStsBtn.classList.add('glow-attention');\n\n        try {\n            showMessage('üîµ √ñvers√§tter till GLOSA...', 'success', 2000);\n            const glossaResult = await translateToGlosa(textContent);\n\n            if (glossaResult) {\n                showMessage('‚úÖ GLOSA-translation klar!', 'success', 2000);\n                const glossaDisplay = document.getElementById('glossaDisplay') || (() => {\n                    const div = document.createElement('div');\n                    div.id = 'glossaDisplay';\n                    div.style.cssText = 'margin-top: 1rem; padding: 1rem; background: #a5e7ef; border-radius: 0.5rem; font-family: FreeSans-SWL, monospace; font-size: 1.2rem; line-height: 1.8;';\n                    textDisplay.parentElement?.insertAdjacentElement('afterend', div);\n                    return div;\n                })();\n                // Format GLOSA: STORA BOKST√ÑVER + grundform\n                glossaDisplay.textContent = glossaResult.toUpperCase().trim();\n                \n                // NYTT: Uppdatera videor f√∂r GLOSA-orden\n                await updateGlosaVideos(glossaResult);\n            } else {\n                showMessage('‚ö†Ô∏è GLOSA-translation misslyckades', 'error', 3000);\n            }\n        } catch (error) {\n            console.error('GLOSA error:', error);\n            showMessage('‚ùå N√•got gick fel vid GLOSA-translation', 'error', 5000);\n        } finally {\n            askAiAboutStsBtn.disabled = false;\n            askAiAboutStsBtn.classList.remove('glow-attention');\n        }\n    });\n}\n","path":null,"size_bytes":9784,"size_tokens":null},"src/components/__tests__/VideoGrid.full.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport * as VideoGrid from '../VideoGrid';\n\ndescribe('VideoGrid (full test)', () => {\n  it('should export createNoSignCardElement', () => {\n    expect(typeof VideoGrid.createNoSignCardElement).toBe('function');\n  });\n\n  it('should create a no-sign card element', () => {\n    const el = VideoGrid.createNoSignCardElement('test', [{ base: 'test', isWord: true }], 'card1');\n    expect(el).toBeInstanceOf(HTMLElement);\n    expect(el.className).toContain('video-card-no-sign');\n  });\n\n  // L√§gg till tester f√∂r event, rendering och grid-logik h√§r\n});\n","path":null,"size_bytes":597,"size_tokens":null},"src/hooks/useGrammarRules.ts":{"content":"// Grammar Rules Hook - Anv√§nder teckenspr√•ks-grammatik f√∂r bessre √∂ver√§ttning\n\ninterface FilterRules {\n  ignoreWords: {\n    stopwords: string[];\n    articles: string[];\n    copula: string[];\n    prepositions: string[];\n    conjunctions: string[];\n  };\n  priorityWords: {\n    categories: {\n      nouns: boolean;\n      verbs: boolean;\n      adjectives: boolean;\n      adverbs: boolean;\n      questionWords: string[];\n    };\n  };\n  contextWords: {\n    timeWords: string[];\n    locationWords: string[];\n    negationWords: string[];\n    quantifiers: string[];\n  };\n  addWords: {\n    facial_markers: string[];\n    emphasizers: string[];\n    clarifiers: string[];\n  };\n}\n\ninterface GrammarRules {\n  wordOrder: {\n    rules: Array<{\n      id: string;\n      name: string;\n      priority: number;\n    }>;\n  };\n  wordRemoval: {\n    categories: {\n      articles: string[];\n      copula: string[];\n      prepositions_optional: string[];\n      conjunctions_optional: string[];\n      pronouns_implied: string[];\n    };\n  };\n}\n\nlet filterRules: FilterRules | null = null;\nlet grammarRules: GrammarRules | null = null;\n\nexport async function loadGrammarRules() {\n  try {\n    if (!filterRules) {\n      const res = await fetch('/data/word-filters.json');\n      const data = await res.json();\n      filterRules = data.filterRules;\n    }\n    if (!grammarRules) {\n      const res = await fetch('/data/glosa/god_glossing.json');\n      const data = await res.json();\n      grammarRules = data.grammarRules;\n    }\n  } catch (error) {\n    console.warn('Kunde inte ladda grammar-regler:', error);\n  }\n}\n\nexport function filterWordsForSignLanguage(words: string[]): string[] {\n  if (!filterRules) return words;\n\n  const ignoreSet = new Set<string>(\n    filterRules.ignoreWords.stopwords.map(w => w.toLowerCase())\n  );\n  const contextWords = new Set<string>(\n    [\n      ...filterRules.contextWords.timeWords,\n      ...filterRules.contextWords.locationWords,\n      ...filterRules.contextWords.negationWords,\n      ...filterRules.contextWords.quantifiers\n    ].map(w => w.toLowerCase())\n  );\n\n  return words.filter(word => {\n    const lowerWord = word.toLowerCase();\n    // Beh√•ll kontext-ord och fr√•geord\n    if (contextWords.has(lowerWord)) return true;\n    if (filterRules!.priorityWords.categories.questionWords.includes(lowerWord))\n      return true;\n    // Filtrera bort stopwords\n    if (ignoreSet.has(lowerWord)) return false;\n    // Beh√•ll allt annat\n    return true;\n  });\n}\n\nexport function reorderForSignLanguage(words: string[]): string[] {\n  // Enkelt exempel: Placera tidsord f√∂rst\n  if (!filterRules) return words;\n\n  const timeWords: string[] = [];\n  const contextWords: string[] = [];\n  const otherWords: string[] = [];\n\n  const timeSet = new Set(\n    filterRules.contextWords.timeWords.map(w => w.toLowerCase())\n  );\n  const contextSet = new Set(\n    filterRules.contextWords.locationWords.map(w => w.toLowerCase())\n  );\n\n  words.forEach(word => {\n    const lowerWord = word.toLowerCase();\n    if (timeSet.has(lowerWord)) timeWords.push(word);\n    else if (contextSet.has(lowerWord)) contextWords.push(word);\n    else otherWords.push(word);\n  });\n\n  // Ordf√∂ljd f√∂r teckenspr√•k: TIDSORD -> KONTEXT -> √ñVRIGA\n  return [...timeWords, ...contextWords, ...otherWords];\n}\n\nexport function applySignLanguageTransformation(\n  swedishText: string\n): { filtered: string[]; reordered: string[] } {\n  const words = swedishText.split(/\\s+/).filter(w => w.length > 0);\n  const filtered = filterWordsForSignLanguage(words);\n  const reordered = reorderForSignLanguage(filtered);\n\n  return {\n    filtered: words.filter(w =>\n      filtered.some(f => f.toLowerCase() === w.toLowerCase())\n    ),\n    reordered\n  };\n}\n\nexport type { FilterRules, GrammarRules };\n","path":null,"size_bytes":3744,"size_tokens":null},"src/components/modals/ModalSystem.ts":{"content":"\nimport { appState } from '../../state';\nimport { delay } from '../../utils';\n\n/**\n * √ñppnar ett modalf√∂nster och hanterar fokus.\n * @param modalElement HTML-elementet f√∂r modalen som ska √∂ppnas.\n * @param openerElement Elementet som √∂ppnade modalen, f√∂r att √•terst√§lla fokus vid st√§ngning.\n */\nexport function openModal(modalElement: HTMLElement, openerElement: HTMLElement | null = null) {\n    if (!modalElement) return;\n    \n    // Spara elementet som √∂ppnade modalen f√∂r att kunna √•terst√§lla fokus\n    appState.activeModalOpener = openerElement || (document.activeElement as HTMLElement);\n    \n    modalElement.classList.add('show');\n    modalElement.setAttribute('aria-hidden', 'false');\n\n    // Hitta f√∂rsta fokuserbara elementet i modalen och ge det fokus.\n    // Vi v√§ntar en kort stund f√∂r att s√§kerst√§lla att modalen √§r synlig och CSS-√∂verg√•ngar har startat.\n    delay(100).then(() => {\n        const focusableElements = modalElement.querySelectorAll<HTMLElement>(\n            'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        );\n        const firstFocusable = Array.from(focusableElements).find(\n            el => !el.closest('.modal-close-btn') && !el.classList.contains('hidden') && el.offsetParent !== null\n        );\n        \n        firstFocusable?.focus();\n    });\n}\n\n/**\n * St√§nger ett aktivt modalf√∂nster och √•terst√§ller fokus till elementet som √∂ppnade det.\n * @param modalElement HTML-elementet f√∂r modalen som ska st√§ngas.\n */\nexport function closeModal(modalElement: HTMLElement) {\n    if (!modalElement || !modalElement.classList.contains('show')) return;\n\n    modalElement.classList.remove('show');\n    modalElement.setAttribute('aria-hidden', 'true');\n\n    // √Öterst√§ll fokus till det ursprungliga elementet om det finns.\n    if (appState.activeModalOpener && typeof appState.activeModalOpener.focus === 'function') {\n        // En liten f√∂rdr√∂jning s√§kerst√§ller att modalen √§r helt st√§ngd innan fokus flyttas tillbaka.\n        delay(150).then(() => {\n            appState.activeModalOpener?.focus();\n            appState.activeModalOpener = null;\n        });\n    }\n}\n\n/**\n * Initierar det globala modalsystemet. S√§tter upp event listeners f√∂r att\n * st√§nga modaler via Escape-tangenten eller specifika st√§ngningsknappar.\n */\nexport function initializeModalSystem() {\n    // Hantera klick p√• st√§ngningsknappar\n    document.body.addEventListener('click', (e) => {\n        const closeButton = (e.target as HTMLElement).closest('[data-modal-close]');\n        if (closeButton) {\n            const modalElement = closeButton.closest('.modal') as HTMLElement;\n            if (modalElement) {\n                closeModal(modalElement);\n            }\n        }\n    });\n\n    // Hantera Escape-tangenten f√∂r att st√§nga den √∂versta modalen\n    document.addEventListener('keydown', (e) => {\n        if (e.key === 'Escape') {\n            const openModalElement = document.querySelector('.modal.show') as HTMLElement;\n            if (openModalElement) {\n                closeModal(openModalElement);\n            }\n        }\n    });\n}\n","path":null,"size_bytes":3123,"size_tokens":null},"src/styles/core/layout.css":{"content":"\n/* --- GENERAL LAYOUT & POSITIONING --- */\n.message-box {\n    position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); z-index: 1000;\n    min-width: 300px; max-width: 90%;\n}\n\n/* --- TEST MODE --- */\n/* Disables transitions and animations when tests are running for stability */\n.test-mode, .test-mode * {\n    transition: none !important;\n    animation: none !important;\n}\n","path":null,"size_bytes":389,"size_tokens":null},"src/modules/core/__tests__/init.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as init from '../init';\n\ndescribe('init module', () => {\n  it('should export at least one function', () => {\n    const exportedFunctions = Object.values(init).filter(v => typeof v === 'function');\n    expect(exportedFunctions.length).toBeGreaterThan(0);\n  });\n\n  // L√§gg till tester f√∂r init-logik h√§r\n});\n","path":null,"size_bytes":365,"size_tokens":null},"src/modules/features/renderGlosses.ts":{"content":"import { WordMapEntry } from '../../types';\nimport { ICON_LOADING_SVG } from '../../ui';\n\nexport function renderGlossesOnly(wordMap: WordMapEntry[], isLoading = false) {\n    const grid = document.getElementById('grammarGrid');\n    const container = document.getElementById('grammarDisplayContainer');\n    \n    if (!grid) return;\n    \n    // Show container if hidden\n    if (container) container.classList.remove('hidden');\n    \n    grid.innerHTML = '';\n    grid.className = 'gloss-grid';\n    \n    if (isLoading) {\n        grid.innerHTML = `<div class=\"flex items-center justify-center h-48 col-span-full\">${ICON_LOADING_SVG} <span class=\"ml-2\">√ñvers√§tter...</span></div>`;\n        return;\n    }\n    \n    if (!wordMap || wordMap.length === 0) {\n        grid.innerHTML = '';\n        return;\n    }\n    \n    wordMap.forEach((word) => {\n        if (!word.isWord) return;\n        \n        const gloss = (word.gloss || word.base || word.original || '').toUpperCase();\n        \n        const card = document.createElement('div');\n        card.className = 'gloss-card';\n        \n        const glossEl = document.createElement('div');\n        glossEl.className = 'gloss-text';\n        glossEl.textContent = gloss;\n        \n        card.appendChild(glossEl);\n        grid.appendChild(card);\n    });\n    \n    // Add CSS for gloss cards\n    if (!document.getElementById('glossCardStyles')) {\n        const style = document.createElement('style');\n        style.id = 'glossCardStyles';\n        style.textContent = `\n            .gloss-grid {\n                display: flex;\n                flex-wrap: wrap;\n                gap: 6px;\n                padding: 12px;\n                width: 100%;\n            }\n            \n            .gloss-card {\n                background: #667eea;\n                color: white;\n                padding: 6px 12px;\n                border-radius: 6px;\n                display: inline-flex;\n                align-items: center;\n                justify-content: center;\n                cursor: default;\n                font-weight: 600;\n            }\n            \n            .gloss-text {\n                font-size: 14px;\n                text-align: center;\n                text-transform: uppercase;\n                letter-spacing: 0.5px;\n                line-height: 1.2;\n            }\n            \n            .gloss-card:hover {\n                background: #764ba2;\n                transition: background 0.2s ease;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n}\n","path":null,"size_bytes":2513,"size_tokens":null},"src/modules/features/generator.ts":{"content":"\nimport { closeModal } from '../../components/modals';\nimport { showMessage, updateButtonProgress, originalTextDisplay } from '../../ui';\nimport { generateSentencesWithAI } from '../../hooks/useAI';\nimport { processAndRenderText } from './search';\n\nexport async function handleGenerateSentences(type: 'static' | 'ai', count: number) {\n    const modal = document.getElementById('generateTextModal') as HTMLElement;\n    if (!modal) return;\n\n    let sentences: string[] | null = null;\n    const oldTextContent = originalTextDisplay.textContent || '';\n    \n    closeModal(modal);\n\n    if (type === 'static') {\n        const staticSentences = [\n            \"Hej hur m√•r du idag?\",\n            \"Jag √§lskar att l√§ra mig teckenspr√•k.\",\n            \"Vad vill du √§ta till middag?\",\n            \"Solen skiner och f√•glarna sjunger.\",\n            \"Kan du hj√§lpa mig med den h√§r uppgiften?\",\n            \"Det √§r viktigt att kommunicera tydligt.\",\n            \"Har du sett min nya bok?\",\n            \"Jag gillar att promenera i skogen.\",\n            \"Varf√∂r √§r himlen bl√• p√• dagen?\",\n            \"Jag vill k√∂pa en stor glass.\",\n            \"Min familj bor i Stockholm.\",\n            \"Vad heter du?\",\n            \"Jag arbetar som l√§rare.\",\n            \"Hur gammal √§r du?\",\n            \"Var bor du n√•gonstans?\",\n            \"Jag tycker om att l√§sa b√∂cker.\",\n            \"Vilken f√§rg gillar du b√§st?\",\n            \"Kan du visa mig v√§gen?\",\n            \"Tack s√• mycket f√∂r hj√§lpen.\",\n            \"Jag f√∂rst√•r inte vad du menar.\",\n            \"Sn√§lla upprepa det igen.\",\n            \"Var ligger biblioteket?\",\n            \"Klockan √§r fem.\",\n            \"Jag √§r hungrig.\",\n            \"Vill du ha kaffe eller te?\",\n            \"Det regnar ute idag.\",\n            \"Jag har en hund som heter Max.\",\n            \"Vi ses imorgon!\",\n            \"God morgon!\",\n            \"God natt och sov gott.\",\n            \"Jag l√§r mig svenska.\",\n            \"Hur s√§ger man det p√• teckenspr√•k?\",\n            \"Kan du teckna l√•ngsammare?\",\n            \"Jag beh√∂ver hj√§lp.\",\n            \"Var √§r toaletten?\",\n            \"Hur mycket kostar det?\",\n            \"Jag kommer fr√•n Sverige.\",\n            \"Vad jobbar du med?\",\n            \"Vilken dag √§r det idag?\",\n            \"Jag gillar att titta p√• film.\",\n        ];\n        sentences = staticSentences.sort(() => 0.5 - Math.random()).slice(0, count);\n        showMessage(`Genererade ${count} exempel-meningar.`, 'success');\n    } else if (type === 'ai') {\n        const loadingMessage = `AI genererar ${count} meningar... Detta kan ta en stund.`;\n        if (originalTextDisplay) originalTextDisplay.textContent = loadingMessage;\n        updateButtonProgress('ai_refine');\n\n        try {\n            sentences = await generateSentencesWithAI(count);\n            if (sentences) {\n                showMessage(`AI genererade ${count} meningar.`, 'success');\n            } else {\n                if (originalTextDisplay) originalTextDisplay.textContent = oldTextContent;\n            }\n        } catch (error) {\n            if (originalTextDisplay) originalTextDisplay.textContent = oldTextContent;\n        }\n    }\n\n    if (sentences) {\n        const newText = sentences.join(' ');\n        if (originalTextDisplay) {\n            originalTextDisplay.textContent = newText;\n            originalTextDisplay.classList.add('text-area-editable');\n        }\n        await processAndRenderText(newText);\n    } else {\n        updateButtonProgress('idle');\n    }\n}\n","path":null,"size_bytes":3498,"size_tokens":null},"src/styles/components.css":{"content":"/* --- CORE UI COMPONENTS --- */\n\n.card { \n    background-color: var(--glass-bg); \n    backdrop-filter: blur(16px);\n    -webkit-backdrop-filter: blur(16px);\n    border: 1px solid var(--glass-border);\n    box-shadow: var(--shadow-glass);\n    border-radius: var(--border-radius-lg); \n    padding: var(--space-lg); \n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n/* Input Styling */\n#originalTextDisplay {\n    width: 100%; \n    min-height: 240px; \n    padding: var(--space-md); \n    padding-right: 2.75rem; \n    padding-left: 2.75rem; \n    border-radius: var(--border-radius-md);\n    background-color: var(--bg-dark); \n    color: var(--text-primary);\n    font-size: 1.15rem; \n    line-height: 1.7; \n    transition: all 0.2s ease;\n    box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);\n    -webkit-appearance: none;\n    appearance: none;\n}\n\n/* Mobile Input Sizing - Portrait */\n@media (max-width: 640px) and (orientation: portrait) {\n    #originalTextDisplay {\n        min-height: 180px;\n        font-size: 1rem;\n        padding: 0.75rem;\n        padding-right: 2.25rem;\n        padding-left: 2.25rem;\n    }\n    \n    .modal-input, .feedback-textarea {\n        font-size: 1rem;\n        padding: 0.5rem 0.75rem;\n    }\n}\n\n/* Mobile Input Sizing - Landscape */\n@media (max-width: 640px) and (orientation: landscape) {\n    #originalTextDisplay {\n        min-height: 100px;\n        font-size: 0.95rem;\n        padding: 0.5rem;\n        padding-right: 2rem;\n        padding-left: 2rem;\n    }\n    \n    .modal-input, .feedback-textarea {\n        font-size: 0.9rem;\n        padding: 0.4rem 0.6rem;\n    }\n}\n#originalTextDisplay:focus { \n    outline: none;\n}\n#originalTextDisplay:not(.text-area-editable) {\n    color: var(--text-placeholder);\n}\n\n/* Button Styling - Material Design Standard */\n.btn { \n    display: inline-flex; \n    align-items: center; \n    justify-content: center; \n    gap: var(--space-sm); \n    padding: var(--button-padding-v) var(--button-padding-h);\n    border-radius: var(--border-radius-md); \n    font-weight: 600; \n    font-size: var(--button-text);\n    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); \n    cursor: pointer; \n    border: 1px solid transparent; \n    letter-spacing: 0.01em;\n    min-height: var(--button-height);\n    min-width: var(--touch-min);\n    -webkit-tap-highlight-color: transparent;\n    touch-action: auto;\n}\n\n.btn-sm { \n    padding: 0.375rem 0.75rem;\n    font-size: 0.875rem;\n    min-height: var(--button-height-sm);\n}\n\n/* Mobile Button Sizing */\n@media (max-width: 640px) {\n    .btn {\n        padding: var(--button-padding-v) var(--button-padding-h);\n        font-size: var(--button-text);\n        min-height: var(--button-height);\n    }\n}\n\n.btn-primary { \n    background: var(--primary-gradient);\n    color: white; \n    border: none;\n    box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);\n}\n.btn-primary:hover:not(:disabled) { \n    filter: brightness(1.1);\n    transform: translateY(-1px);\n    box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);\n}\n.btn-primary:active:not(:disabled) {\n    transform: translateY(0);\n    box-shadow: 0 2px 10px rgba(99, 102, 241, 0.3);\n}\n\n.btn-secondary { \n    background-color: rgba(255, 255, 255, 0.03); \n    color: var(--text-primary); \n    border: 1px solid var(--border-color); \n    backdrop-filter: blur(4px);\n}\n.btn-secondary:hover:not(:disabled) { \n    background-color: rgba(255, 255, 255, 0.08); \n    border-color: var(--text-secondary);\n}\n\n.btn:disabled { \n    opacity: 0.5; \n    cursor: not-allowed; \n    filter: grayscale(0.8);\n    box-shadow: none;\n}\n\n/* Inputs & Textareas */\n.modal-input, .feedback-textarea {\n    background-color: var(--modal-input-bg); \n    border: 1px solid var(--modal-input-border); \n    color: var(--text-primary);\n    border-radius: var(--border-radius-md);\n    padding: 0.75rem 1rem;\n    width: 100%;\n    font-size: 1rem;\n    line-height: 1.5;\n    transition: all 0.2s ease;\n    box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);\n}\n\n.modal-input:focus, .feedback-textarea:focus { \n    border-color: var(--primary-blue); \n    outline: none;\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2); \n}\n\n.modal-input.suggestions-open {\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n/* Toggle Switch */\n.toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; }\n.toggle-switch input { opacity: 0; width: 0; height: 0; }\n.toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--bg-light); border: 1px solid var(--border-color); transition: .4s; border-radius: 24px; }\n.toggle-slider:before { position: absolute; content: \"\"; height: 18px; width: 18px; left: 3px; bottom: 2px; background-color: var(--text-secondary); transition: .4s; border-radius: 50%; }\ninput:checked + .toggle-slider { background-color: var(--primary-blue); border-color: var(--primary-blue); }\ninput:checked + .toggle-slider:before { transform: translateX(20px); background-color: white; }\n\n/* --- FLOATING COMPONENTS --- */\n\n/* Tooltip */\n#tooltip {\n    padding: 0.5rem 1rem;\n    background-color: var(--glass-bg);\n    border: 1px solid var(--glass-border);\n    backdrop-filter: blur(8px);\n    -webkit-backdrop-filter: blur(8px);\n    color: var(--text-primary);\n    border-radius: var(--border-radius-md);\n    font-size: 0.85rem;\n    font-weight: 500;\n    line-height: 1.4;\n    max-width: 280px;\n    box-shadow: var(--shadow-lg);\n    z-index: 10000;\n}\n\n/* Search Suggestions */\n#lexiconSuggestions, .suggestions-list {\n    background-color: var(--bg-dark);\n    border: 1px solid var(--border-color);\n    border-top: none;\n    border-radius: 0 0 var(--border-radius-md) var(--border-radius-md);\n    box-shadow: var(--shadow-lg);\n    overflow: hidden;\n}\n.suggestion-item {\n    display: block;\n    width: 100%;\n    text-align: left;\n    padding: 0.75rem 1rem;\n    cursor: pointer;\n    background: none;\n    border: none;\n    color: var(--text-secondary);\n    font-size: 0.95rem;\n    transition: background-color 0.15s;\n}\n\n.suggestion-item:hover, .suggestion-item:focus {\n    background-color: var(--bg-light);\n    color: var(--primary-blue);\n    outline: none;\n    padding-left: 1.25rem; \n}\n","path":null,"size_bytes":6171,"size_tokens":null},"src/services/media/videoService.ts":{"content":"\nimport { localVideoMap, fullLexiconMap } from '../../state';\n\nexport const VIDEO_BASE_URL = \"https://teckensprakslexikon.su.se/movies/\";\n\nexport function buildVideoUrl(\n    videoId: string, \n    baseWord: string, \n    type: 'tecken' | 'example' | 'related' = 'tecken', \n    phraseNumber?: number, \n    forceHyphens?: boolean,\n    keepSwedishChars: boolean = false \n): string {\n    if (videoId.startsWith('local-video-')) {\n        return localVideoMap.get(videoId) || '';\n    }\n\n    let cleanId = videoId;\n    if (/^\\d+$/.test(videoId)) {\n        cleanId = cleanId.padStart(5, '0');\n    }\n\n    const folder = cleanId.substring(0, 2);\n\n    let wordForUrl = baseWord;\n    if (baseWord.toLowerCase() === 'idag') {\n        wordForUrl = 'i-dag';\n    }\n    \n    let normalizedForDictionary = wordForUrl.toLowerCase();\n    \n    // Only replace Swedish chars if we are NOT keeping them\n    if (!keepSwedishChars) {\n        normalizedForDictionary = normalizedForDictionary\n            .replace(/√•|√§/g, 'a')\n            .replace(/√∂/g, 'o');\n    }\n\n    let normalizedWord;\n\n    // Strict URL construction based on forceHyphens flag\n    if (forceHyphens === true) {\n        // Force hyphens: replace spaces with hyphens\n        normalizedWord = encodeURIComponent(normalizedForDictionary.replace(/\\s+/g, '-'));\n    } else if (forceHyphens === false) {\n        // Force concatenated: remove spaces and hyphens\n        normalizedWord = encodeURIComponent(normalizedForDictionary.replace(/[\\s-]+/g, ''));\n    } else {\n        // Default behavior if not specified\n        if (type === 'example' || type === 'related') {\n             // For examples, default is usually concatenated in the wild, but inconsistent.\n             // We default to concatenated here, but playVideo will retry.\n             normalizedWord = encodeURIComponent(normalizedForDictionary.replace(/\\s+/g, ''));\n        } else {\n            // For main signs\n            const wordParts = normalizedForDictionary.split(/\\s+/).filter(p => p);\n            if (wordParts.length > 2) {\n                normalizedWord = encodeURIComponent(wordParts.join(''));\n            } else if (wordParts.length === 2) {\n                normalizedWord = encodeURIComponent(wordParts.join('-'));\n            } else {\n                normalizedWord = encodeURIComponent(normalizedForDictionary);\n            }\n        }\n    }\n    \n    const resolutionPath = '180x180/';\n    \n    let finalUrl: string;\n    if ((type === 'example' || type === 'related') && phraseNumber) {\n        finalUrl = `${VIDEO_BASE_URL}${folder}/${normalizedWord}-${cleanId}-fras-${phraseNumber}.mp4`;\n    } else {\n        finalUrl = `${VIDEO_BASE_URL}${folder}/${resolutionPath}${normalizedWord}-${cleanId}-tecken.mp4`;\n    }\n    \n    return finalUrl;\n}\n\nexport function playVideo(\n    player: HTMLVideoElement, \n    errorEl: HTMLElement, \n    container: HTMLElement, \n    id: string, \n    word: string, \n    type: 'tecken' | 'example' | 'related' = 'tecken', \n    phraseNumber?: number,\n    contextSentence?: string \n) {\n    if (!player || !errorEl || !container) return;\n    container.classList.remove('hidden');\n    errorEl.classList.add('hidden');\n    player.classList.remove('hidden');\n\n    // Prepare candidate URLs\n    const candidates = new Set<string>();\n\n    // Helper to add variations\n    const addVariants = (keepSwedish: boolean) => {\n         // Default logic\n         candidates.add(buildVideoUrl(id, word, type, phraseNumber, undefined, keepSwedish));\n         // Force hyphens\n         candidates.add(buildVideoUrl(id, word, type, phraseNumber, true, keepSwedish));\n         // Force concatenated\n         candidates.add(buildVideoUrl(id, word, type, phraseNumber, false, keepSwedish));\n    };\n\n    // Try normalized first (usually correct for main signs)\n    addVariants(false);\n    // Try keeping Swedish chars (sometimes correct, especially for examples)\n    addVariants(true);\n    \n    const urlsToTry = Array.from(candidates);\n    let currentUrlIndex = 0;\n\n    // Function to attempt rescue search in full lexicon\n    const attemptRescue = (): { id: string, word: string, phraseNumber?: number } | null => {\n        if (!contextSentence) return null;\n        console.log(`F√∂rs√∂ker hitta r√§ddningsvideo f√∂r mening: \"${contextSentence}\"`);\n        \n        for (const [lexiconWord, entries] of fullLexiconMap.entries()) {\n            for (const entry of entries) {\n                 if (entry.examples) {\n                     // Exact match for sentence\n                     const match = entry.examples.find((ex: any) => ex.sentence && ex.sentence.trim() === contextSentence.trim());\n                     if (match) {\n                         console.log(`Hittade matchande mening under ordet: \"${entry.word}\" (ID: ${entry.id})`);\n                         return { id: entry.id, word: entry.word, phraseNumber: match.phraseNumber };\n                     }\n                     \n                     // Fallback: partial match (first few words) if exact doesn't work\n                     const sentenceStart = contextSentence.trim().split(' ').slice(0, 3).join(' ');\n                     const partialMatch = entry.examples.find((ex: any) => \n                         ex.sentence && ex.sentence.trim().startsWith(sentenceStart) && sentenceStart.length > 5\n                     );\n                     if (partialMatch) {\n                         console.log(`Hittade delvis matchande mening under ordet: \"${entry.word}\" (ID: ${entry.id})`);\n                         return { id: entry.id, word: entry.word, phraseNumber: partialMatch.phraseNumber };\n                     }\n                 }\n            }\n        }\n        return null;\n    };\n\n    // Error handler that iterates through candidates\n    player.onerror = () => {\n        currentUrlIndex++;\n        \n        if (currentUrlIndex < urlsToTry.length) {\n            console.warn(`Video URL misslyckades: ${player.src}. Testar alternativ: ${urlsToTry[currentUrlIndex]}`);\n            player.src = urlsToTry[currentUrlIndex];\n        } else {\n            // All standard candidates failed. Try rescue if applicable.\n            // Only try rescue once per play request to avoid loops.\n            if ((type === 'example' || type === 'related') && contextSentence && !player.dataset.rescueAttempted) {\n                player.dataset.rescueAttempted = \"true\";\n                const rescueMatch = attemptRescue();\n                if (rescueMatch) {\n                     const newPhraseNumber = rescueMatch.phraseNumber || phraseNumber;\n                     // For rescue, we also just try the default URL construction first\n                     const rescueUrl = buildVideoUrl(rescueMatch.id, rescueMatch.word, type, newPhraseNumber);\n                     console.warn(`Alla standard-URL:er misslyckades. Byter till r√§ddnings-URL: ${rescueUrl}`);\n                     player.src = rescueUrl;\n                     return;\n                }\n            }\n            \n            // If we reach here, everything failed.\n            console.error(`Kunde inte spela video f√∂r \"${word}\". Testade: ${urlsToTry.join(', ')}`);\n            player.classList.add('hidden');\n            errorEl.classList.remove('hidden');\n            errorEl.textContent = `Video saknas.`;\n        }\n    };\n\n    // Start playing the first candidate\n    delete player.dataset.rescueAttempted; // Clear previous rescue flag\n    player.src = urlsToTry[0];\n    player.load();\n    player.play().catch(e => {\n        if (e.name !== 'AbortError') {\n            console.warn(\"Autoplay was prevented:\", e);\n        }\n    });\n}\n","path":null,"size_bytes":7585,"size_tokens":null},"src/styles/components/chat.css":{"content":"\n/* --- AI CHAT LAYOUT --- */\n#aiChatHistory {\n    display: flex;\n    flex-direction: column;\n    gap: var(--space-md); /* Added gap for airiness */\n}\n.chat-bubble {\n    max-width: 85%;\n    padding: var(--space-sm) var(--space-md);\n    border-radius: var(--border-radius-lg);\n    line-height: 1.5;\n}\n.chat-bubble-user {\n    align-self: flex-end;\n    border-bottom-right-radius: var(--border-radius-sm);\n}\n.chat-bubble-ai {\n    align-self: flex-start;\n    border-bottom-left-radius: var(--border-radius-sm);\n}\n.chat-bubble-ai.is-thinking::after {\n    content: '‚óè';\n    animation: pulse 1.5s infinite;\n    margin-left: 0.5rem;\n}\n.chat-bubble code { \n    background-color: color-mix(in srgb, var(--bg-dark) 50%, transparent); \n    color: var(--selection-yellow); \n}\n","path":null,"size_bytes":765,"size_tokens":null},"src/style.css":{"content":"\n/* Tooltip styling for status dots */\n[title] {\n    cursor: help;\n    position: relative;\n}\n\ndiv[title]::after {\n    content: attr(title);\n    position: absolute;\n    bottom: 120%;\n    left: 50%;\n    transform: translateX(-50%);\n    background: rgba(0, 0, 0, 0.9);\n    color: #fff;\n    padding: 4px 8px;\n    border-radius: 4px;\n    font-size: 11px;\n    white-space: nowrap;\n    pointer-events: none;\n    opacity: 0;\n    transition: opacity 0.2s;\n    z-index: 1000;\n}\n\ndiv[title]:hover::after {\n    opacity: 1;\n}\n","path":null,"size_bytes":513,"size_tokens":null},"src/components/__tests__/GlosaSearch.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport GlosaSearch from '../GlosaSearch';\nimport { render } from '@testing-library/react';\n\ndescribe('GlosaSearch component', () => {\n  it('should render without crashing', () => {\n    const { container } = render(<GlosaSearch />);\n    expect(container).toBeTruthy();\n  });\n\n  // L√§gg till tester f√∂r s√∂k- och glosa-funktionalitet h√§r\n});\n","path":null,"size_bytes":390,"size_tokens":null},"src/modules/cloud/puterCloudSync.ts":{"content":"/**\n * PUTER CLOUD SYNC - Synkar anv√§ndardata till Puter.js Cloud (100% GRATIS)\n * \n * Synkar:\n * - GLOSA-korrigeringar (AI Learning)\n * - Tumme upp/ner feedback\n * - \"√Ñndra tecken\" val\n * - Meningsfeedback\n */\n\nimport { \n    feedbackMap, \n    positiveFeedbackMap, \n    negativeFeedbackMap, \n    sentenceFeedbackMap,\n    learnedPreferences,\n    questionClarifications \n} from '../../state';\nimport { aiLearningSystem } from '../sts-glossing/aiLearningSystem';\n\nconst CLOUD_KEYS = {\n    AI_LEARNING: 'sts_ai_learning',\n    FEEDBACK: 'sts_feedback',\n    POSITIVE_FEEDBACK: 'sts_positive_feedback',\n    NEGATIVE_FEEDBACK: 'sts_negative_feedback',\n    SENTENCE_FEEDBACK: 'sts_sentence_feedback',\n    LEARNED_PREFERENCES: 'sts_learned_preferences',\n    QUESTION_CLARIFICATIONS: 'sts_question_clarifications',\n    LAST_SYNC: 'sts_last_sync'\n};\n\nfunction mapToObject(map: Map<any, any>): Record<string, any> {\n    const obj: Record<string, any> = {};\n    for (const [key, value] of map) {\n        if (value instanceof Map) {\n            obj[key] = mapToObject(value);\n        } else {\n            obj[key] = value;\n        }\n    }\n    return obj;\n}\n\nfunction objectToNestedMap(obj: Record<string, any>): Map<string, Map<string, any>> {\n    const outerMap = new Map<string, Map<string, any>>();\n    for (const [outerKey, innerObj] of Object.entries(obj)) {\n        if (typeof innerObj === 'object' && innerObj !== null && !Array.isArray(innerObj)) {\n            const innerMap = new Map<string, any>();\n            for (const [innerKey, value] of Object.entries(innerObj)) {\n                innerMap.set(innerKey, value);\n            }\n            outerMap.set(outerKey, innerMap);\n        }\n    }\n    return outerMap;\n}\n\nfunction ensureString(data: any): string {\n    if (typeof data === 'string') {\n        return data;\n    }\n    return JSON.stringify(data);\n}\n\nfunction safeJsonParse(data: any): any {\n    if (typeof data === 'string') {\n        try {\n            return JSON.parse(data);\n        } catch {\n            return null;\n        }\n    }\n    return data;\n}\n\nclass PuterCloudSync {\n    private syncInProgress = false;\n    private syncDebounceTimer: number | null = null;\n    private DEBOUNCE_MS = 2000;\n\n    private getPuter(): any {\n        return (window as any).puter;\n    }\n\n    public async isAuthenticated(): Promise<boolean> {\n        const puter = this.getPuter();\n        if (!puter?.auth) return false;\n        \n        try {\n            return puter.auth.isSignedIn();\n        } catch {\n            return false;\n        }\n    }\n\n    public async ensureAuthenticated(): Promise<boolean> {\n        const puter = this.getPuter();\n        if (!puter?.auth) {\n            console.warn('‚ö†Ô∏è Puter.js not available for cloud sync');\n            return false;\n        }\n\n        try {\n            if (!puter.auth.isSignedIn()) {\n                console.log('üîê Signing in to Puter for cloud sync...');\n                await puter.auth.signIn();\n            }\n            return true;\n        } catch (error) {\n            console.warn('Cloud auth failed:', error);\n            return false;\n        }\n    }\n\n    public async syncToCloud(): Promise<boolean> {\n        if (this.syncInProgress) {\n            console.log('‚è≥ Sync already in progress, skipping...');\n            return false;\n        }\n\n        const puter = this.getPuter();\n        if (!puter?.kv) {\n            console.warn('‚ö†Ô∏è Puter KV not available');\n            return false;\n        }\n\n        this.syncInProgress = true;\n        console.log('‚òÅÔ∏è Starting cloud sync...');\n\n        try {\n            const aiLearningData = aiLearningSystem.exportData();\n            await puter.kv.set(CLOUD_KEYS.AI_LEARNING, aiLearningData);\n            console.log('‚úÖ AI Learning synced to cloud');\n\n            if (feedbackMap.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.FEEDBACK, JSON.stringify(mapToObject(feedbackMap)));\n                console.log(`‚úÖ Feedback synced: ${feedbackMap.size} entries`);\n            }\n\n            if (positiveFeedbackMap.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.POSITIVE_FEEDBACK, JSON.stringify(mapToObject(positiveFeedbackMap)));\n                console.log(`‚úÖ Positive feedback synced: ${positiveFeedbackMap.size} entries`);\n            }\n\n            if (negativeFeedbackMap.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.NEGATIVE_FEEDBACK, JSON.stringify(mapToObject(negativeFeedbackMap)));\n                console.log(`‚úÖ Negative feedback synced: ${negativeFeedbackMap.size} entries`);\n            }\n\n            if (sentenceFeedbackMap.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.SENTENCE_FEEDBACK, JSON.stringify(mapToObject(sentenceFeedbackMap)));\n                console.log(`‚úÖ Sentence feedback synced: ${sentenceFeedbackMap.size} entries`);\n            }\n\n            if (learnedPreferences.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.LEARNED_PREFERENCES, JSON.stringify(mapToObject(learnedPreferences)));\n                console.log(`‚úÖ Learned preferences synced: ${learnedPreferences.size} entries`);\n            }\n\n            if (questionClarifications.size > 0) {\n                await puter.kv.set(CLOUD_KEYS.QUESTION_CLARIFICATIONS, JSON.stringify(mapToObject(questionClarifications)));\n                console.log(`‚úÖ Question clarifications synced: ${questionClarifications.size} entries`);\n            }\n\n            await puter.kv.set(CLOUD_KEYS.LAST_SYNC, new Date().toISOString());\n\n            console.log('‚òÅÔ∏è Cloud sync complete!');\n            return true;\n        } catch (error) {\n            console.error('‚ùå Cloud sync failed:', error);\n            return false;\n        } finally {\n            this.syncInProgress = false;\n        }\n    }\n\n    public async loadFromCloud(): Promise<boolean> {\n        const puter = this.getPuter();\n        if (!puter?.kv) {\n            console.warn('‚ö†Ô∏è Puter KV not available');\n            return false;\n        }\n\n        console.log('‚òÅÔ∏è Loading data from cloud...');\n\n        try {\n            const aiLearningData = await puter.kv.get(CLOUD_KEYS.AI_LEARNING);\n            if (aiLearningData) {\n                const dataString = ensureString(aiLearningData);\n                aiLearningSystem.importData(dataString);\n                console.log('‚úÖ AI Learning loaded from cloud');\n            }\n\n            const feedbackData = await puter.kv.get(CLOUD_KEYS.FEEDBACK);\n            if (feedbackData) {\n                const parsed = safeJsonParse(feedbackData);\n                if (parsed) {\n                    feedbackMap.clear();\n                    for (const [key, value] of Object.entries(parsed)) {\n                        feedbackMap.set(key, value as any);\n                    }\n                    console.log(`‚úÖ Feedback loaded: ${feedbackMap.size} entries`);\n                }\n            }\n\n            const positiveData = await puter.kv.get(CLOUD_KEYS.POSITIVE_FEEDBACK);\n            if (positiveData) {\n                const parsed = safeJsonParse(positiveData);\n                if (parsed) {\n                    const nestedMap = objectToNestedMap(parsed);\n                    positiveFeedbackMap.clear();\n                    for (const [key, innerMap] of nestedMap) {\n                        positiveFeedbackMap.set(key, innerMap);\n                    }\n                    console.log(`‚úÖ Positive feedback loaded: ${positiveFeedbackMap.size} entries`);\n                }\n            }\n\n            const negativeData = await puter.kv.get(CLOUD_KEYS.NEGATIVE_FEEDBACK);\n            if (negativeData) {\n                const parsed = safeJsonParse(negativeData);\n                if (parsed) {\n                    const nestedMap = objectToNestedMap(parsed);\n                    negativeFeedbackMap.clear();\n                    for (const [key, innerMap] of nestedMap) {\n                        negativeFeedbackMap.set(key, innerMap);\n                    }\n                    console.log(`‚úÖ Negative feedback loaded: ${negativeFeedbackMap.size} entries`);\n                }\n            }\n\n            const sentenceData = await puter.kv.get(CLOUD_KEYS.SENTENCE_FEEDBACK);\n            if (sentenceData) {\n                const parsed = safeJsonParse(sentenceData);\n                if (parsed) {\n                    sentenceFeedbackMap.clear();\n                    for (const [key, value] of Object.entries(parsed)) {\n                        sentenceFeedbackMap.set(key, value as string);\n                    }\n                    console.log(`‚úÖ Sentence feedback loaded: ${sentenceFeedbackMap.size} entries`);\n                }\n            }\n\n            const prefData = await puter.kv.get(CLOUD_KEYS.LEARNED_PREFERENCES);\n            if (prefData) {\n                const parsed = safeJsonParse(prefData);\n                if (parsed) {\n                    const nestedMap = objectToNestedMap(parsed);\n                    learnedPreferences.clear();\n                    for (const [key, innerMap] of nestedMap) {\n                        learnedPreferences.set(key, innerMap);\n                    }\n                    console.log(`‚úÖ Learned preferences loaded: ${learnedPreferences.size} entries`);\n                }\n            }\n\n            const clarData = await puter.kv.get(CLOUD_KEYS.QUESTION_CLARIFICATIONS);\n            if (clarData) {\n                const parsed = safeJsonParse(clarData);\n                if (parsed) {\n                    questionClarifications.clear();\n                    for (const [key, value] of Object.entries(parsed)) {\n                        questionClarifications.set(key, value as string);\n                    }\n                    console.log(`‚úÖ Question clarifications loaded: ${questionClarifications.size} entries`);\n                }\n            }\n\n            const lastSync = await puter.kv.get(CLOUD_KEYS.LAST_SYNC);\n            if (lastSync) {\n                console.log(`üìÖ Last cloud sync: ${lastSync}`);\n            }\n\n            console.log('‚òÅÔ∏è Cloud load complete!');\n            return true;\n        } catch (error) {\n            console.error('‚ùå Cloud load failed:', error);\n            return false;\n        }\n    }\n\n    public scheduleSyncToCloud(): void {\n        if (this.syncDebounceTimer) {\n            clearTimeout(this.syncDebounceTimer);\n        }\n\n        this.syncDebounceTimer = window.setTimeout(async () => {\n            const puter = this.getPuter();\n            if (!puter?.kv) return;\n            \n            const isAuth = await this.isAuthenticated();\n            if (isAuth) {\n                await this.syncToCloud();\n            } else {\n                console.log('‚òÅÔ∏è Not signed in to Puter, skipping cloud sync');\n            }\n        }, this.DEBOUNCE_MS);\n    }\n\n    public async getLastSyncTime(): Promise<string | null> {\n        const puter = this.getPuter();\n        if (!puter?.kv) return null;\n\n        try {\n            return await puter.kv.get(CLOUD_KEYS.LAST_SYNC);\n        } catch {\n            return null;\n        }\n    }\n\n    public async clearCloudData(): Promise<boolean> {\n        const puter = this.getPuter();\n        if (!puter?.kv) return false;\n\n        try {\n            for (const key of Object.values(CLOUD_KEYS)) {\n                await puter.kv.del(key);\n            }\n            console.log('üóëÔ∏è Cloud data cleared');\n            return true;\n        } catch (error) {\n            console.error('Failed to clear cloud data:', error);\n            return false;\n        }\n    }\n}\n\nexport const puterCloudSync = new PuterCloudSync();\n","path":null,"size_bytes":11573,"size_tokens":null},"src/components/__tests__/VideoGrid.test.tsx":{"content":"import { describe, it, expect } from 'vitest';\nimport * as VideoGrid from '../VideoGrid';\n\ndescribe('VideoGrid', () => {\n  it('should export required functions', () => {\n    expect(typeof VideoGrid.createNoSignCardElement).toBe('function');\n    expect(typeof VideoGrid.createPlaceholderCardElement).toBe('function');\n    expect(typeof VideoGrid.createInteractiveCardElement).toBe('function');\n    expect(typeof VideoGrid.resetAndShowGrammarPlaceholder).toBe('function');\n  });\n\n  // L√§gg till fler tester f√∂r rendering, event och logik h√§r\n});\n","path":null,"size_bytes":547,"size_tokens":null},"src/modules/ui/tooltip.ts":{"content":"\nexport function showTooltip(text: string, target: HTMLElement) {\n    let tooltip = document.getElementById('tooltip');\n    if (!tooltip) {\n        tooltip = document.createElement('div');\n        tooltip.id = 'tooltip';\n        // Basic styles ensuring visibility, specific styling handled by CSS\n        tooltip.style.position = 'fixed';\n        tooltip.style.zIndex = '10000';\n        document.body.appendChild(tooltip);\n    }\n\n    tooltip.innerHTML = text;\n    tooltip.style.visibility = 'visible';\n    tooltip.style.opacity = '1';\n\n    const rect = target.getBoundingClientRect();\n    const tooltipRect = tooltip.getBoundingClientRect();\n\n    let top = rect.bottom + 8;\n    let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);\n\n    // Boundary checks to keep tooltip on screen\n    if (left < 4) left = 4;\n    if (left + tooltipRect.width > window.innerWidth - 4) {\n        left = window.innerWidth - tooltipRect.width - 4;\n    }\n    if (top + tooltipRect.height > window.innerHeight - 4) {\n        top = rect.top - tooltipRect.height - 8; // Flip to top if no space below\n    }\n\n    tooltip.style.top = `${top}px`;\n    tooltip.style.left = `${left}px`;\n}\n\nexport function hideTooltip() {\n    const tooltip = document.getElementById('tooltip');\n    if (tooltip) {\n        tooltip.style.visibility = 'hidden';\n        tooltip.style.opacity = '0';\n    }\n}\n\nexport function initializeTooltips() {\n    // Global delegation for performance and dynamic elements\n    document.body.addEventListener('mouseover', (e) => {\n        const target = (e.target as HTMLElement).closest('[data-tooltip-text]') as HTMLElement;\n        if (target) {\n            showTooltip(target.dataset.tooltipText || '', target);\n        }\n    });\n\n    document.body.addEventListener('mouseout', (e) => {\n        const target = (e.target as HTMLElement).closest('[data-tooltip-text]');\n        if (target) {\n            hideTooltip();\n        }\n    });\n    \n    // Hide on scroll/click/focus change to prevent stuck tooltips\n    window.addEventListener('scroll', hideTooltip, true);\n    document.addEventListener('click', hideTooltip);\n    document.addEventListener('focusin', hideTooltip);\n}\n","path":null,"size_bytes":2179,"size_tokens":null},"src/utils/sorting.ts":{"content":"\nimport { Sign } from '../types';\nimport { learnedPreferences } from '../state';\n\nexport function reorderSignsWithPreferences(signs: Sign[], lookupKey: string): Sign[] {\n    if (!signs || signs.length <= 1) return signs;\n    const preferences = learnedPreferences.get(lookupKey);\n    if (!preferences) return signs;\n    \n    return [...signs].sort((a, b) => {\n        const scoreA = preferences.get(a.id) || 0;\n        const scoreB = preferences.get(b.id) || 0;\n        return scoreB - scoreA;\n    });\n}\n","path":null,"size_bytes":504,"size_tokens":null},"src/ui.ts":{"content":"\n// --- CENTRAL UI EXPORT MODULE (FACADE) ---\n\n// Notification Service\nexport { showMessage, updateButtonProgress, showProgressStartup, ICON_LOADING_SVG, messageBox } from './services/ui/notificationService';\n\n// Video Service\nexport { buildVideoUrl, playVideo, VIDEO_BASE_URL } from './services/media/videoService';\n\n// Lexicon Data Service\nexport { getLexiconUrl, LEXICON_ORD_URL, LEXICON_SEARCH_URL } from './services/data/lexiconUrlService';\n\n// Dev Mode Service\nexport { isDevMode } from './services/system/devModeService';\n\n// Feedback Notification Service\nexport { activateFeedbackButton, FEEDBACK_SUMMARY_PREFIX } from './services/ui/feedbackNotificationService';\n\n// Tooltip Module\n// VIKTIGT: Anv√§nd relativ s√∂kv√§g h√§r, inte alias\nexport { initializeTooltips } from './modules/ui/tooltip';\n\n// Video Grid Selection Service\nexport { updateSelectionUI } from './services/ui/videoGridSelectionService';\n\n// DOM Elements\nexport { originalTextDisplay, voiceInputBtn, imageInputBtn, imageInputFile } from './modules/dom/elements';\n\n// Helper to delay (Utility re-export if needed by legacy consumers)\nexport { delay } from './utils';\n","path":null,"size_bytes":1142,"size_tokens":null},"src/components/__tests__/chat.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport * as chat from '../chat';\n\ndescribe('chat module', () => {\n  it('should export setupChatEventListeners', () => {\n    expect(typeof chat.setupChatEventListeners).toBe('function');\n  });\n\n  it('should export handleOpenChat', () => {\n    expect(typeof chat.handleOpenChat).toBe('function');\n  });\n\n  // L√§gg till fler tester f√∂r chatlogik, event och rendering h√§r\n});\n","path":null,"size_bytes":422,"size_tokens":null},"src/modules/features/grammar.ts":{"content":"\n// TECKENSPR√ÖKS√ñVERS√ÑTTNING BORTTAGEN - B√ñRJAR OM MED BARA \"BIL\"\n\nexport async function translateAndRenderCurrentGrammarSentence() {\n    // PLACEHOLDER - Kommer implementeras f√∂r enbart \"bil\"\n    console.log(\"STS-glossing removed. Starting over with only 'bil' example.\");\n}\n","path":null,"size_bytes":281,"size_tokens":null},"src/components/modals.ts":{"content":"import { appState, idToWordMap, feedbackMap, sentenceFeedbackMap, positiveFeedbackMap, negativeFeedbackMap, questionClarifications, learnedPreferences, localUserSigns, updateLatestFeedbackJson } from '../state';\nimport { WordMapEntry, Sign, ModalContexts, Example, RelatedSignInfo, PositiveFeedbackEntry, NegativeFeedbackEntry } from '../types';\nimport { showMessage, activateFeedbackButton, isDevMode, buildVideoUrl, playVideo, getLexiconUrl, ICON_LOADING_SVG, FEEDBACK_SUMMARY_PREFIX } from '../ui';\nimport { generateLearningSummaryAI, convertSummaryToJsonAI } from '../hooks/useAI';\nimport { openModal as openModalSystem, closeModal as closeModalSystem, initializeModalSystem } from './modals/ModalSystem';\nimport { ensureWordDataEnriched } from '../hooks/useDataEnrichment';\nimport { delay } from '../utils';\nimport { ensureFullLexiconLoaded, saveUserData } from '../hooks/useLexicon';\n// ARCHIVED: initializeLexiconExplorer - moved to _archived/LexiconExplorer.ts\nimport { updateGrammarCard } from './VideoGrid';\nimport { findCandidatesForToken } from '../modules/search/localSearchWithFallback';\nimport { initializeAlphabetModals } from '../modules/features/alphabetPlayer';\nimport { openSignDetailsModal } from '../modules/features/signDetails';\nimport { initializeSuggestionModalEventListeners, openSuggestionModal } from '../modules/features/recorder';\nimport { feedbackCollector } from '../modules/feedback/feedbackCollector';\n\nasync function triggerCloudSync() {\n    try {\n        const { puterCloudSync } = await import('../modules/cloud/puterCloudSync');\n        puterCloudSync.scheduleSyncToCloud();\n    } catch (e) {\n        // Cloud sync not available, ignore\n    }\n}\n\n// --- √Öter-exportera f√∂r att inte bryta API:et ---\nexport { openModalSystem as openModal, closeModalSystem as closeModal };\nexport { openSignDetailsModal }; // Re-export f√∂r bak√•tkompatibilitet\n\n// --- MODAL-SPECIFIK LOGIK ---\n\nexport function showFeedbackVideo(cardId: string, signId: string) {\n    const cardData = appState.cardIdDataMap.get(cardId);\n    let sign: Sign | undefined;\n    \n    if (cardData) {\n        sign = cardData.phraseTokens\n            .flatMap(t => t.signs || [])\n            .find(s => s.id === signId);\n    }\n    \n    if (!sign) {\n        const wordForSignId = idToWordMap.get(signId);\n        if (wordForSignId) {\n            sign = { id: signId, word: wordForSignId };\n        } else {\n            showMessage(`Kunde inte hitta tecken med ID: ${signId}`, 'error');\n            return;\n        }\n    }\n\n    const modal = document.getElementById('feedbackVideoModal') as HTMLElement;\n    const player = document.getElementById('feedbackVideoPlayer') as HTMLVideoElement;\n    const title = document.getElementById('feedbackVideoTitle') as HTMLElement;\n    const errorEl = document.getElementById('feedbackVideoError') as HTMLElement;\n\n    if (!modal || !player || !title || !errorEl) return;\n    \n    title.textContent = `Tecken f√∂r \"${cardData?.fullOriginalPhrase || sign.word}\" (ID: ${sign.id})`;\n    playVideo(player, errorEl, player.parentElement!, sign.id, sign.word);\n    \n    openModalSystem(modal);\n}\n\nexport function openGroupCommentModal(openerElement: HTMLElement) {\n    const modal = document.getElementById('groupCommentModal') as HTMLElement;\n    if (!modal) return;\n    appState.modalContexts.sentenceFeedback = { sentence: [] }; \n    openModalSystem(modal, openerElement);\n\n    const commentText = modal.querySelector('textarea') as HTMLTextAreaElement;\n    commentText.value = '';\n    \n    const saveBtn = modal.querySelector('#groupCommentSaveBtn') as HTMLButtonElement;\n    if(saveBtn) {\n        saveBtn.onclick = () => {\n            const comment = commentText.value.trim();\n            if (comment) {\n                appState.selection.forEach(cardId => {\n                    const cardData = appState.cardIdDataMap.get(cardId);\n                    if(cardData) {\n                        feedbackMap.set(cardId, {\n                            feedback: comment,\n                            originalWords: cardData.fullOriginalPhrase,\n                            groupId: 'group-comment-' + Date.now()\n                        });\n                        const cardElement = document.querySelector(`.video-card[data-card-id=\"${cardId}\"]`);\n                        cardElement?.classList.add('feedback-reported');\n                    }\n                });\n                updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n                triggerCloudSync(); // CLOUD SYNC\n                activateFeedbackButton();\n                showMessage(`${appState.selection.length} tecken har kommenterats.`, 'success');\n            }\n            closeModalSystem(modal);\n            appState.selection = [];\n            import('../ui').then(({ updateSelectionUI }) => { updateSelectionUI(); });\n        };\n    }\n}\n\nexport function openSentenceFeedbackModal(sentence: WordMapEntry[], openerElement: HTMLElement) {\n    const modal = document.getElementById('sentenceFeedbackModal') as HTMLElement;\n    if (!modal) return;\n    appState.modalContexts.sentenceFeedback = { sentence };\n    openModalSystem(modal, openerElement);\n    \n    const title = document.getElementById('sentenceFeedbackTitle');\n    const text = document.getElementById('sentenceFeedbackText');\n    if(title) title.textContent = 'Feedback p√• mening';\n    if(text) text.textContent = `\"${sentence.map(w => w.original).join('')}\"`;\n\n    const saveBtn = modal.querySelector('#sentenceFeedbackSaveBtn') as HTMLButtonElement;\n    if(saveBtn) {\n        saveBtn.onclick = () => {\n            const comment = (modal.querySelector('textarea') as HTMLTextAreaElement).value.trim();\n            const sentenceKey = sentence.map(w => w.original).join('');\n            if (comment) {\n                sentenceFeedbackMap.set(sentenceKey, comment);\n                updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n                triggerCloudSync(); // CLOUD SYNC\n                activateFeedbackButton();\n                showMessage('Tack f√∂r din feedback!', 'success');\n            }\n            closeModalSystem(modal);\n        };\n    }\n}\n\nexport function clearFeedbackData() {\n    feedbackMap.clear();\n    positiveFeedbackMap.clear();\n    negativeFeedbackMap.clear();\n    sentenceFeedbackMap.clear();\n    questionClarifications.clear();\n    \n    updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n    \n    import('./VideoGrid').then(({ renderCurrentSentence }) => {\n        import('../ui').then(({ updateSelectionUI }) => {\n             updateSelectionUI();\n             if (!appState.isShowingAllSentences) {\n                renderCurrentSentence();\n            }\n        });\n    });\n}\n\nasync function generateReport() {\n    const summaryText = document.getElementById('feedbackSummaryText') as HTMLTextAreaElement;\n    if (!summaryText) return;\n    \n    summaryText.value = \"Analyserar feedback...\";\n    \n    // NOTE: In the new flow, appState.latestFeedbackJson is already up-to-date thanks to updateLatestFeedbackJson()\n    // But for robustness in this specific legacy/manual reporting modal, we can ensure it's set.\n    if (!appState.latestFeedbackJson) {\n         updateLatestFeedbackJson();\n    }\n    const feedbackJson = appState.latestFeedbackJson;\n\n    const summary = await generateLearningSummaryAI(feedbackJson);\n    const finalReport = summary || \"Kunde inte generera sammanfattning. (AI svarade inte)\";\n    \n    // Add the magic prefix so AI recognizes it when pasted\n    const fullReport = FEEDBACK_SUMMARY_PREFIX + \"\\n\\n\" + finalReport;\n    \n    summaryText.value = fullReport;\n    appState.latestReportSummary = fullReport; // PERSIST REPORT TEXT\n}\n\nexport async function openFeedbackSummaryModal(openerElement: HTMLElement) {\n    const modal = document.getElementById('feedbackSummaryModal') as HTMLElement;\n    const summaryText = document.getElementById('feedbackSummaryText') as HTMLTextAreaElement;\n    const applyAndCopyJsonBtn = document.getElementById('applyAndCopyJsonBtn') as HTMLButtonElement;\n    const clearBtn = document.getElementById('feedbackSummaryClearBtn') as HTMLButtonElement;\n    const refreshBtn = document.getElementById('feedbackSummaryRefreshBtn') as HTMLButtonElement;\n    const copyBtn = document.getElementById('feedbackSummaryCopyBtn') as HTMLButtonElement;\n\n    if (!modal || !summaryText || !applyAndCopyJsonBtn) return;\n\n    if (clearBtn) {\n         clearBtn.onclick = () => {\n             clearFeedbackData();\n             appState.latestReportSummary = null;\n             summaryText.value = \"\";\n             closeModalSystem(modal);\n             showMessage(\"Feedback rensad.\", \"success\");\n         };\n    }\n    \n    if (refreshBtn) {\n        refreshBtn.onclick = () => generateReport();\n    }\n    \n    if (copyBtn) {\n        copyBtn.onclick = async () => {\n            if (!summaryText.value) return;\n            try {\n                await navigator.clipboard.writeText(summaryText.value);\n                showMessage(\"Text kopierad!\", \"success\");\n            } catch (err) {\n                // Fallback\n                summaryText.select();\n                document.execCommand('copy');\n                showMessage(\"Text kopierad!\", \"success\");\n            }\n        };\n    }\n\n    openModalSystem(modal, openerElement);\n\n    // Load persisted text if available, otherwise generate\n    if (appState.latestReportSummary) {\n        summaryText.value = appState.latestReportSummary;\n    } else {\n        // Check if there is any feedback to report on\n        const hasFeedback = feedbackMap.size > 0 || sentenceFeedbackMap.size > 0 || negativeFeedbackMap.size > 0 || positiveFeedbackMap.size > 0;\n        if (hasFeedback) {\n            generateReport();\n        } else {\n            summaryText.value = \"Ingen feedback registrerad √§n.\";\n        }\n    }\n\n    applyAndCopyJsonBtn.onclick = async () => {\n        if (!appState.latestFeedbackJson) {\n             updateLatestFeedbackJson();\n        }\n        \n        applyAndCopyJsonBtn.disabled = true;\n        applyAndCopyJsonBtn.innerText = \"Bearbetar...\";\n\n        const learningUpdate = await convertSummaryToJsonAI(appState.latestFeedbackJson);\n        \n        if (learningUpdate) {\n             if (learningUpdate.learnedPreferences) {\n                for (const pref of learningUpdate.learnedPreferences) {\n                     if (!learnedPreferences.has(pref.lookupKey)) {\n                         learnedPreferences.set(pref.lookupKey, new Map());\n                     }\n                     const currentVal = learnedPreferences.get(pref.lookupKey)!.get(pref.signId) || 0;\n                     learnedPreferences.get(pref.lookupKey)!.set(pref.signId, currentVal + pref.vote);\n                }\n             }\n             if (learningUpdate.newWords) {\n                 for (const word of learningUpdate.newWords) {\n                     // Naive update to localUserSigns\n                     localUserSigns.set(word.lookupKey, word.signs);\n                 }\n             }\n\n             const jsonString = JSON.stringify(learningUpdate, null, 2);\n             \n            // Copy to clipboard\n            try {\n                await navigator.clipboard.writeText(jsonString);\n                showMessage(\"Inl√§rning till√§mpad och JSON kopierad!\", \"success\");\n            } catch (e) {\n                const textarea = document.createElement('textarea');\n                textarea.value = jsonString;\n                document.body.appendChild(textarea);\n                textarea.select();\n                document.execCommand('copy');\n                document.body.removeChild(textarea);\n                showMessage(\"Inl√§rning till√§mpad och JSON kopierad!\", \"success\");\n            }\n\n            // Clear underlying data but KEEP the report text so user can see history\n            clearFeedbackData(); \n            \n            if (isDevMode()) {\n                await saveUserData();\n            }\n            // Do not close modal automatically, let user read\n        } else {\n            showMessage(\"Kunde inte konvertera feedback till JSON.\", \"error\");\n        }\n        applyAndCopyJsonBtn.disabled = false;\n        applyAndCopyJsonBtn.innerText = \"Till√§mpa Inl√§rning & Kopiera JSON\";\n    };\n}\n\nfunction setupFeedbackListeners() {\n    const goodChoiceModal = document.getElementById('goodChoiceReasonModal');\n    const thumbDownModal = document.getElementById('thumbDownReasonModal');\n\n    if (goodChoiceModal) {\n        const btnContext = document.getElementById('goodChoiceReasonContextBtn');\n        const btnPrimary = document.getElementById('goodChoiceReasonPrimaryBtn');\n\n        const handleGood = (isPrimary: boolean) => {\n            const context = appState.modalContexts.goodChoiceReason;\n            if (context && context.sign) {\n                const weight = isPrimary ? 999 : 1;\n                const lookup = context.lookupKey || \"\";\n                \n                if (!learnedPreferences.has(lookup)) {\n                    learnedPreferences.set(lookup, new Map());\n                }\n                const currentWeight = learnedPreferences.get(lookup)!.get(context.sign.id) || 0;\n                learnedPreferences.get(lookup)!.set(context.sign.id, currentWeight + weight);\n                \n                // Use the explicit cardId if available, or fallback to \"unknown\" if missing.\n                // This fixes the [object Object] bug in feedback reports.\n                const cardId = context.cardId || `card-${Date.now()}`;\n                \n                const map = positiveFeedbackMap.get(cardId) || new Map<string, PositiveFeedbackEntry>();\n                const entry = map.get(context.sign.id) || { sign: context.sign, originalWords: context.fullOriginalPhrase!, count: 0 };\n                entry.count += 1;\n                map.set(context.sign.id, entry);\n                positiveFeedbackMap.set(cardId, map);\n                \n                updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n                triggerCloudSync(); // CLOUD SYNC\n                \n                // Add to feedback collector for Google Forms\n                feedbackCollector.addThumbUp(context.sign.word, context.sign.id);\n\n                if(context.cardContainer) {\n                    context.cardContainer.classList.add('feedback-thumb-up');\n                    context.cardContainer.classList.remove('feedback-thumb-down');\n                }\n                activateFeedbackButton();\n                showMessage(isPrimary ? \"Sparat som prim√§rval!\" : \"Tack f√∂r din feedback!\", \"success\");\n                // Feedback sparas lokalt - anv√§ndaren kan skicka via Feedback-knappen n√§r de vill\n                closeModalSystem(goodChoiceModal);\n            }\n        };\n\n        btnContext?.addEventListener('click', () => handleGood(false));\n        btnPrimary?.addEventListener('click', () => handleGood(true));\n    }\n\n    if (thumbDownModal) {\n        const saveNegative = (reason: string) => {\n            const context = appState.modalContexts.thumbDownReason;\n            if (context && context.sign) {\n                // Use the explicit cardId if available\n                const cardId = context.cardId || `card-${Date.now()}`;\n                \n                const map = negativeFeedbackMap.get(cardId) || new Map<string, NegativeFeedbackEntry>();\n                map.set(context.sign.id, { sign: context.sign, originalWords: context.fullOriginalPhrase!, reason });\n                negativeFeedbackMap.set(cardId, map);\n                \n                updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n                triggerCloudSync(); // CLOUD SYNC\n                \n                // Add to feedback collector for Google Forms\n                feedbackCollector.addThumbDown(context.sign.word, context.sign.id, reason);\n\n                if (context.cardContainer) {\n                    context.cardContainer.classList.add('feedback-thumb-down');\n                    context.cardContainer.classList.remove('feedback-thumb-up');\n                }\n                activateFeedbackButton();\n                showMessage(\"Tack, vi ska se √∂ver detta.\", \"success\");\n                // Feedback sparas lokalt - anv√§ndaren kan skicka via Feedback-knappen n√§r de vill\n                closeModalSystem(thumbDownModal);\n            }\n        };\n\n        document.getElementById('thumbDownReasonIncorrectBtn')?.addEventListener('click', () => saveNegative(\"Fel tecken\"));\n        document.getElementById('thumbDownReasonContextBtn')?.addEventListener('click', () => saveNegative(\"Fel kontext\"));\n        document.getElementById('thumbDownReasonOldBtn')?.addEventListener('click', () => saveNegative(\"Gammalt tecken\"));\n        document.getElementById('thumbDownReasonRegionalBtn')?.addEventListener('click', () => saveNegative(\"Regionalt tecken\"));\n        \n        const otherBtn = document.getElementById('thumbDownReasonOtherBtn');\n        const otherContainer = document.getElementById('thumbDownOtherReasonContainer');\n        const saveOtherBtn = document.getElementById('saveThumbDownReasonBtn');\n        \n        otherBtn?.addEventListener('click', () => {\n            otherContainer?.classList.remove('hidden');\n        });\n        \n        saveOtherBtn?.addEventListener('click', () => {\n            const text = otherContainer?.querySelector('textarea')?.value || \"Annat\";\n            saveNegative(text);\n            otherContainer?.classList.add('hidden'); \n        });\n    }\n}\n\n\nexport function openGoodChoiceReasonModal(context: NonNullable<ModalContexts['goodChoiceReason']>, openerElement: HTMLElement) {\n    const modal = document.getElementById('goodChoiceReasonModal') as HTMLElement;\n    if (!modal) return;\n    appState.modalContexts.goodChoiceReason = context;\n    const title = document.getElementById('goodChoiceReasonTitle');\n    if(title) title.textContent = `Bra val f√∂r \"${context.sign?.word}\"?`;\n    openModalSystem(modal, openerElement);\n}\n\nexport function openThumbDownReasonModal(context: NonNullable<ModalContexts['thumbDownReason']>, openerElement: HTMLElement) {\n    const modal = document.getElementById('thumbDownReasonModal') as HTMLElement;\n    if (!modal) return;\n    appState.modalContexts.thumbDownReason = context;\n    const title = document.getElementById('thumbDownReasonTitle');\n    if(title) title.textContent = `Problem med \"${context.sign?.word}\"?`;\n    openModalSystem(modal, openerElement);\n}\n\nexport function openImproveSignMenuModal(context: NonNullable<ModalContexts['improveSign']>, openerElement: HTMLElement) {\n    const modal = document.getElementById('improveSignModal') as HTMLElement;\n    if (!modal) return;\n    appState.modalContexts.improveSign = context;\n    openModalSystem(modal, openerElement);\n}\n\nexport function openCreateCombinationModal(openerElement: HTMLElement) {\n    const modal = document.getElementById('createCombinationModal') as HTMLElement;\n    if (!modal) return;\n    \n    // Visa preview av valda tecken\n    const previewGrid = modal.querySelector('#combinationPreviewGrid') as HTMLElement;\n    if (previewGrid && appState.combinationSelection.length > 0) {\n        previewGrid.innerHTML = '';\n        appState.combinationSelection.forEach(({ sign }) => {\n            const previewCard = document.createElement('div');\n            previewCard.className = 'bg-gray-800 p-2 rounded text-sm';\n            previewCard.textContent = sign.word;\n            previewGrid.appendChild(previewCard);\n        });\n    }\n    \n    const searchInput = modal.querySelector('#newWordSearchInput') as HTMLInputElement;\n    const suggestionsList = modal.querySelector('#newWordSuggestions') as HTMLElement;\n    \n    if (searchInput && suggestionsList) {\n        searchInput.addEventListener('input', async (e) => {\n            const query = (e.target as HTMLInputElement).value.trim();\n            if (query.length < 1) {\n                suggestionsList.classList.add('hidden');\n                return;\n            }\n            \n            const { getSortedSearchResults } = await import('../utils');\n            const { localLexiconMap, idToWordMap } = await import('../state');\n            const words = getSortedSearchResults(query, 100);\n            \n            const allSigns: Sign[] = [];\n            if (words.length > 0) {\n                words.forEach(word => {\n                    const signs = localLexiconMap.get(word);\n                    if (signs) allSigns.push(...signs);\n                });\n                \n                if (/^\\d+$/.test(query) && idToWordMap.has(query.padStart(5, '0'))) {\n                    const id = query.padStart(5, '0');\n                    const word = idToWordMap.get(id)!;\n                    allSigns.unshift({ id, word });\n                }\n            }\n            \n            const uniqueSigns = Array.from(new Map(allSigns.map(sign => [sign.id, sign])).values()).slice(0, 8);\n            suggestionsList.classList.remove('hidden');\n            suggestionsList.innerHTML = '';\n            \n            if (uniqueSigns.length === 0) {\n                suggestionsList.innerHTML = '<div class=\"text-xs text-gray-500 px-3 py-2\">Inga tecken hittades</div>';\n                return;\n            }\n            \n            uniqueSigns.forEach(sign => {\n                const btn = document.createElement('button');\n                btn.className = 'w-full text-left px-3 py-2 hover:bg-gray-700 transition-colors text-sm';\n                btn.textContent = `${sign.word} (ID: ${sign.id})`;\n                btn.addEventListener('click', () => {\n                    searchInput.value = `${sign.word} ‚úì`;\n                    suggestionsList.classList.add('hidden');\n                });\n                suggestionsList.appendChild(btn);\n            });\n        });\n    }\n    \n    // Spara kombination\n    const saveBtn = modal.querySelector('#saveCombinationBtn') as HTMLButtonElement;\n    const wordInput = modal.querySelector('#newCombinationWordInput') as HTMLInputElement;\n    const commentInput = modal.querySelector('#newCombinationCommentInput') as HTMLTextAreaElement;\n    \n    if (saveBtn) {\n        // Ta bort gamla listeners f√∂rst\n        const newSaveBtn = saveBtn.cloneNode(true) as HTMLButtonElement;\n        saveBtn.parentNode?.replaceChild(newSaveBtn, saveBtn);\n        \n        newSaveBtn.addEventListener('click', async () => {\n            if (appState.combinationSelection.length === 0) {\n                showMessage('Inga tecken valda f√∂r kombination', 'error');\n                return;\n            }\n            \n            const newWord = wordInput?.value.trim();\n            if (!newWord) {\n                showMessage('Ange ett ord eller fras f√∂r kombinationen', 'error');\n                return;\n            }\n            \n            const combinedSigns = appState.combinationSelection.map(item => item.sign);\n            const comment = commentInput?.value.trim() || '';\n            \n            // Spara till localUserSigns\n            const lookupKey = newWord.toLowerCase();\n            localUserSigns.set(lookupKey, {\n                signs: combinedSigns,\n                isCompound: true\n            });\n            \n            // Spara till feedbackCollector\n            const originalWords = appState.combinationSelection.map(item => {\n                const cardData = appState.cardIdDataMap.get(item.cardId);\n                return cardData?.fullOriginalPhrase || '';\n            }).filter(w => w).join(' ');\n            \n            feedbackCollector.addNewSignSuggestion(originalWords || newWord, undefined, comment || `Kombination: ${combinedSigns.map(s => s.word).join(' + ')}`);\n            \n            // Uppdatera feedback JSON\n            updateLatestFeedbackJson();\n            triggerCloudSync();\n            activateFeedbackButton();\n            \n            // Spara anv√§ndardata\n            if (isDevMode()) {\n                await saveUserData();\n            }\n            \n            showMessage(`Kombination \"${newWord}\" sparad!`, 'success');\n            closeModalSystem(modal);\n            appState.combinationSelection = [];\n            \n            // Rensa inputs\n            if (wordInput) wordInput.value = '';\n            if (commentInput) commentInput.value = '';\n        });\n    }\n    \n    openModalSystem(modal, openerElement);\n}\n\nexport async function handleApplyNewSignFromSearch(newSign: Sign) {\n    const context = appState.modalContexts.changeReason;\n    if (!context) return;\n\n    if (appState.changeSignMode === 'grammar') {\n        const grammarCardIndex = context.grammarCardIndex;\n        if (typeof grammarCardIndex !== 'number') return;\n        \n        const translatedSentence = appState.aiTranslatedSentences.get(appState.currentGrammarSentenceIndex);\n        if (!translatedSentence) return;\n\n        const wordToUpdate = translatedSentence[grammarCardIndex];\n        wordToUpdate.signs = [newSign];\n        wordToUpdate.gloss = newSign.word; \n        updateGrammarCard(grammarCardIndex, wordToUpdate);\n\n        const cardId = `grammar-card-${grammarCardIndex}`;\n        feedbackMap.set(cardId, {\n            feedback: `Anv√§ndare √§ndrade AI:s val fr√•n '${context.originalSigns[0]?.word || 'inget'}' till '${newSign.word}'.`,\n            originalWords: wordToUpdate.original,\n            suggestedSigns: [newSign]\n        });\n        \n        updateLatestFeedbackJson(); // UPDATE JSON REALTIME\n        triggerCloudSync(); // CLOUD SYNC\n        \n        activateFeedbackButton();\n        showMessage(`Tecken f√∂r \"${wordToUpdate.original}\" √§ndrat till \"${newSign.word}\".`, 'success');\n    } else { \n        // Use the cardId stored in context to prevent [object Object] bug\n        const cardId = context.cardId; \n        \n        appState.modalContexts.goodChoiceReason = {\n            ...context,\n            sign: newSign,\n            cardId: cardId, \n            fullOriginalPhrase: context.phraseTokens.map(t => t.original).join(''),\n            cardContainer: cardId ? document.getElementById(cardId) as HTMLElement : undefined\n        };\n        openModalSystem(document.getElementById('goodChoiceReasonModal') as HTMLElement);\n    }\n\n    closeModalSystem(document.getElementById('changeSignModal') as HTMLElement);\n}\n\nexport function openChangeGrammarSignModal(cardId: string, index: number) {\n    const cardData = appState.cardIdDataMap.get(cardId);\n    if (!cardData) return;\n\n    const context: NonNullable<ModalContexts['improveSign']> = {\n        phraseTokens: cardData.phraseTokens,\n        lookupKey: cardData.phraseTokens[0].base,\n        fullOriginalPhrase: cardData.fullOriginalPhrase,\n        cardId: cardId,\n        isSpelledOut: false,\n        cardContainer: document.getElementById(cardId) as HTMLElement,\n        grammarCardIndex: index\n    };\n    \n    appState.changeSignMode = 'grammar';\n    openChangeSignModal(context);\n}\n\nfunction openChangeSignModal(context: NonNullable<ModalContexts['improveSign']>) {\n    const modal = document.getElementById('changeSignModal') as HTMLElement;\n    const searchInput = document.getElementById('changeSignSearchInput') as HTMLInputElement;\n    const alternativesGrid = document.getElementById('changeSignAlternativesGrid') as HTMLElement;\n    if (!modal || !searchInput || !alternativesGrid) return;\n\n    const createChangeSignCard = (sign: Sign): HTMLElement => {\n        const card = document.createElement('div');\n        card.className = 'video-card alternative-item';\n        card.dataset.signId = sign.id;\n        card.dataset.signWord = sign.word;\n\n        const playerWrapper = document.createElement('div');\n        playerWrapper.className = 'video-card-player-wrapper';\n    \n        const videoPlayer = document.createElement('video');\n        videoPlayer.className = 'video-card-player';\n        videoPlayer.src = buildVideoUrl(sign.id, sign.word);\n        videoPlayer.muted = true;\n        videoPlayer.playsInline = true;\n        videoPlayer.loop = true;\n        videoPlayer.disablePictureInPicture = true;\n\n        card.onmouseover = () => { videoPlayer.play().catch(() => {}); };\n        card.onmouseout = () => { videoPlayer.pause(); };\n    \n        const titleEl = document.createElement('p');\n        titleEl.className = 'video-card-title';\n        titleEl.textContent = sign.word.toUpperCase();\n        \n        playerWrapper.append(videoPlayer, titleEl);\n        card.append(playerWrapper);\n\n        return card;\n    };\n\n    const renderAlternatives = async (query: string) => {\n        alternativesGrid.innerHTML = `<div class=\"col-span-full flex justify-center p-8\">${ICON_LOADING_SVG}</div>`;\n        const { getSortedSearchResults } = await import('../utils');\n        const words = getSortedSearchResults(query, 100);\n        \n        const allSigns: Sign[] = [];\n        if (words.length > 0) {\n             const { localLexiconMap, idToWordMap } = await import('../state');\n             \n            words.forEach(word => {\n                const signs = localLexiconMap.get(word);\n                if (signs) allSigns.push(...signs);\n            });\n            \n             if (/^\\d+$/.test(query) && idToWordMap.has(query.padStart(5, '0'))) {\n                 const id = query.padStart(5, '0');\n                 const word = idToWordMap.get(id)!;\n                 allSigns.unshift({ id, word });\n            }\n        }\n        \n        const uniqueSigns = Array.from(new Map(allSigns.map(sign => [sign.id, sign])).values());\n        \n        alternativesGrid.innerHTML = '';\n        if (uniqueSigns.length === 0) {\n            alternativesGrid.innerHTML = '<p class=\"col-span-full text-center text-gray-400 p-4\">Inga tecken hittades.</p>';\n            return;\n        }\n\n        const fragment = document.createDocumentFragment();\n        uniqueSigns.forEach(sign => {\n            fragment.appendChild(createChangeSignCard(sign));\n        });\n        alternativesGrid.appendChild(fragment);\n    };\n    \n    appState.modalContexts.changeReason = {\n        phraseTokens: context.phraseTokens,\n        lookupKey: context.lookupKey,\n        newSign: { id: '', word: '' },\n        originalSigns: context.phraseTokens[0]?.signs || [],\n        grammarCardIndex: context.grammarCardIndex,\n        cardId: context.cardId \n    };\n    \n    searchInput.value = context.lookupKey;\n    renderAlternatives(context.lookupKey);\n    \n    const onInput = () => renderAlternatives(searchInput.value);\n    searchInput.removeEventListener('input', onInput);\n    searchInput.addEventListener('input', onInput);\n\n    const onClickAlternative = (e: MouseEvent) => {\n        const card = (e.target as HTMLElement).closest<HTMLElement>('.alternative-item');\n        if (card && card.dataset.signId && card.dataset.signWord) {\n            const newSign: Sign = { id: card.dataset.signId, word: card.dataset.signWord };\n            handleApplyNewSignFromSearch(newSign);\n        }\n    };\n    alternativesGrid.removeEventListener('click', onClickAlternative);\n    alternativesGrid.addEventListener('click', onClickAlternative);\n\n    openModalSystem(modal, context.cardContainer);\n}\n\nfunction initializeImproveSignModalEventListeners() {\n    const improveSignModal = document.getElementById('improveSignModal');\n    if (!improveSignModal) return;\n\n    const changeBtn = document.getElementById('improveActionChangeBtn');\n    const suggestBtn = document.getElementById('improveActionSuggestBtn');\n    const reportBtn = document.getElementById('improveActionReportBtn');\n\n    changeBtn?.addEventListener('click', () => {\n        const context = appState.modalContexts.improveSign;\n        if (!context) return;\n        closeModalSystem(improveSignModal);\n        appState.changeSignMode = 'main'; \n        openChangeSignModal(context); \n    });\n\n    suggestBtn?.addEventListener('click', () => {\n        const context = appState.modalContexts.improveSign;\n        if (!context) return;\n        closeModalSystem(improveSignModal);\n        openSuggestionModal(context);\n    });\n\n    reportBtn?.addEventListener('click', async () => {\n        const context = appState.modalContexts.improveSign;\n        if (!context) return;\n        const wordData = context.phraseTokens[0]; \n        if (!wordData) return;\n        closeModalSystem(improveSignModal);\n        await openSignDetailsModal(wordData, context.cardContainer);\n        const feedbackTextarea = document.getElementById('signFeedbackTextarea') as HTMLTextAreaElement;\n        feedbackTextarea?.focus();\n    });\n}\n\n// --- MULTI-SELECT FEEDBACK MODAL ---\nexport function openMultiSelectFeedbackModal(openerElement: HTMLElement) {\n    const modal = document.getElementById('multiSelectFeedbackModal') as HTMLElement;\n    if (!modal) return;\n    \n    const wordsList = Array.from(appState.selection)\n        .map((id: string) => appState.cardIdDataMap.get(id)?.fullOriginalPhrase || '')\n        .filter(w => w)\n        .join(', ');\n    \n    const title = modal.querySelector('#multiSelectFeedbackTitle');\n    if (title) title.textContent = `Feedback f√∂r: ${wordsList}`;\n    \n    openModalSystem(modal, openerElement);\n    \n    const changeBtn = modal.querySelector('#multiSelectChangeBtn') as HTMLButtonElement;\n    const suggestBtn = modal.querySelector('#multiSelectSuggestBtn') as HTMLButtonElement;\n    const reportBtn = modal.querySelector('#multiSelectReportBtn') as HTMLButtonElement;\n    \n    changeBtn?.addEventListener('click', () => {\n        showMessage(`‚úé √Ñndringsf√∂rslag f√∂r: ${wordsList}`, 'success');\n        closeModalSystem(modal);\n        appState.selection.forEach((id: string) => {\n            const card = document.querySelector(`.video-card[data-card-id=\"${id}\"]`);\n            card?.classList.add('feedback-reported');\n        });\n        appState.selection.length = 0;\n        updateMultiSelectUI();\n    });\n    \n    suggestBtn?.addEventListener('click', () => {\n        showMessage(`üí° F√∂rslag fr√•n anv√§ndar f√∂r: ${wordsList}`, 'success');\n        closeModalSystem(modal);\n        appState.selection.forEach((id: string) => {\n            const card = document.querySelector(`.video-card[data-card-id=\"${id}\"]`);\n            card?.classList.add('feedback-reported');\n        });\n        appState.selection.length = 0;\n        updateMultiSelectUI();\n    });\n    \n    reportBtn?.addEventListener('click', () => {\n        showMessage(`üìã Rapportering f√∂r: ${wordsList}`, 'success');\n        closeModalSystem(modal);\n        appState.selection.forEach((id: string) => {\n            const card = document.querySelector(`.video-card[data-card-id=\"${id}\"]`);\n            card?.classList.add('feedback-reported');\n        });\n        appState.selection.length = 0;\n        updateMultiSelectUI();\n    });\n}\n\n// --- CHANGE GROUP SIGNS MODAL ---\nexport function openChangeGroupSignsModal(openerElement: HTMLElement) {\n    const modal = document.getElementById('changeGroupSignsModal') as HTMLElement;\n    if (!modal) return;\n    \n    openModalSystem(modal, openerElement);\n    \n    const contentDiv = document.getElementById('changeGroupSignsContent') as HTMLElement;\n    if (!contentDiv) return;\n    \n    contentDiv.innerHTML = ''; // Clear previous content\n    \n    // F√∂r varje valt ord, skapa en sektion\n    const selectedCardData = Array.from(appState.selection).map(cardId => {\n        const cardData = appState.cardIdDataMap.get(cardId);\n        return { cardId, cardData };\n    }).filter(item => item.cardData);\n    \n    const changesToMake: Map<string, Sign | null> = new Map(); // cardId -> newSign or null to keep original\n    \n    selectedCardData.forEach(({ cardId, cardData }) => {\n        if (!cardData) return;\n        \n        const wordText = cardData.fullOriginalPhrase;\n        const originalSign = cardData.phraseTokens?.[0]?.signs?.[0];\n        \n        const section = document.createElement('div');\n        section.className = 'border border-gray-700 rounded-lg p-4 space-y-3';\n        section.innerHTML = `\n            <div class=\"flex items-center justify-between mb-2\">\n                <h4 class=\"font-semibold\">${wordText}</h4>\n                <button class=\"reset-btn-${cardId} text-xs text-gray-400 hover:text-white underline\">√Öterst√§ll</button>\n            </div>\n            <div class=\"relative\">\n                <input type=\"text\" class=\"modal-input search-input-${cardId}\" placeholder=\"S√∂k efter nytt tecken i lexikon...\">\n                <div class=\"suggestions-list-${cardId} suggestions-list hidden absolute top-full left-0 right-0 mt-1 z-50\"></div>\n            </div>\n            <div class=\"selected-video-${cardId} flex items-center gap-2 hidden\">\n                <span class=\"text-sm font-medium\">Valt tecken:</span>\n                <video class=\"selected-video-player-${cardId}\" style=\"height: 80px; width: auto;\" muted></video>\n            </div>\n        `;\n        \n        contentDiv.appendChild(section);\n        \n        // Search handler\n        const searchInput = section.querySelector(`.search-input-${cardId}`) as HTMLInputElement;\n        const suggestionsList = section.querySelector(`.suggestions-list-${cardId}`) as HTMLElement;\n        const selectedVideoDiv = section.querySelector(`.selected-video-${cardId}`) as HTMLElement;\n        const selectedVideoPlayer = section.querySelector(`.selected-video-player-${cardId}`) as HTMLVideoElement;\n        const resetBtn = section.querySelector(`.reset-btn-${cardId}`) as HTMLButtonElement;\n        \n        searchInput?.addEventListener('input', async (e) => {\n            const query = (e.target as HTMLInputElement).value.trim();\n            if (query.length < 1) {\n                suggestionsList?.classList.add('hidden');\n                return;\n            }\n            \n            const { getSortedSearchResults } = await import('../utils');\n            const { localLexiconMap, idToWordMap } = await import('../state');\n            const words = getSortedSearchResults(query, 100);\n            \n            const allSigns: Sign[] = [];\n            if (words.length > 0) {\n                words.forEach(word => {\n                    const signs = localLexiconMap.get(word);\n                    if (signs) allSigns.push(...signs);\n                });\n                \n                if (/^\\d+$/.test(query) && idToWordMap.has(query.padStart(5, '0'))) {\n                    const id = query.padStart(5, '0');\n                    const word = idToWordMap.get(id)!;\n                    allSigns.unshift({ id, word });\n                }\n            }\n            \n            const uniqueSigns = Array.from(new Map(allSigns.map(sign => [sign.id, sign])).values()).slice(0, 8);\n            suggestionsList?.classList.remove('hidden');\n            suggestionsList!.innerHTML = '';\n            \n            if (uniqueSigns.length === 0) {\n                suggestionsList!.innerHTML = '<div class=\"text-xs text-gray-500 px-3 py-2\">Inga tecken hittades</div>';\n                return;\n            }\n            \n            uniqueSigns.forEach(sign => {\n                const btn = document.createElement('button');\n                btn.className = 'w-full text-left px-3 py-2 hover:bg-gray-700 transition-colors text-sm';\n                btn.textContent = `${sign.word} (ID: ${sign.id})`;\n                btn.addEventListener('click', () => {\n                    changesToMake.set(cardId, sign);\n                    searchInput.value = `${sign.word} ‚úì`;\n                    suggestionsList.classList.add('hidden');\n                    \n                    // Show preview\n                    selectedVideoDiv.classList.remove('hidden');\n                    selectedVideoPlayer.src = buildVideoUrl(sign.id, sign.word);\n                    selectedVideoPlayer.load();\n                });\n                suggestionsList?.appendChild(btn);\n            });\n        });\n        \n        resetBtn?.addEventListener('click', () => {\n            changesToMake.delete(cardId);\n            searchInput.value = '';\n            selectedVideoDiv.classList.add('hidden');\n        });\n    });\n    \n    // Save button\n    const saveBtn = modal.querySelector('#changeGroupSignsSaveBtn') as HTMLButtonElement;\n    const cancelBtn = modal.querySelector('#changeGroupSignsCancelBtn') as HTMLButtonElement;\n    \n    saveBtn?.addEventListener('click', () => {\n        if (changesToMake.size > 0) {\n            showMessage(`${changesToMake.size} tecken bytt!`, 'success');\n        }\n        closeModalSystem(modal);\n        appState.selection = [];\n        import('../ui').then(({ updateSelectionUI }) => { updateSelectionUI(); });\n    });\n    \n    cancelBtn?.addEventListener('click', () => {\n        closeModalSystem(modal);\n    });\n}\n\nfunction updateMultiSelectUI() {\n    import('./VideoGrid').then(({ updateMultiSelectUI: updateUI }) => {\n        updateUI();\n    });\n}\n\n// --- HUVUDINITIALISERING F√ñR MODALER ---\n\nexport function initializeModals() {\n    initializeModalSystem();\n    (window as any).showFeedbackVideo = showFeedbackVideo;\n    // ARCHIVED: initializeLexiconExplorer() - moved to _archived/\n    initializeAlphabetModals();\n    initializeImproveSignModalEventListeners();\n    setupFeedbackListeners(); \n    initializeSuggestionModalEventListeners(); \n}","path":null,"size_bytes":41040,"size_tokens":null},"src/styles/variables.css":{"content":":root {\n    /* Material Design 8dp Grid Spacing Scale */\n    --space-xs: 0.5rem;      /* 8dp */\n    --space-sm: 1rem;        /* 16dp */\n    --space-md: 1.5rem;      /* 24dp */\n    --space-lg: 2rem;        /* 32dp */\n    --space-xl: 2.5rem;      /* 40dp */\n    --space-xxl: 4rem;       /* 64dp */\n\n    /* Material Design Button Dimensions */\n    --button-height: 3.5rem;     /* 56px (Material standard) */\n    --button-height-sm: 2.5rem;  /* 40px (Small buttons) */\n    --button-padding-h: 1rem;    /* 16px horizontal */\n    --button-padding-v: 0.5rem;  /* 8px vertical */\n    --button-text: 1rem;         /* 16px (Material standard) */\n\n    /* Material Design Touch Targets */\n    --touch-min: 3rem;  /* 48px minimum touch area */\n\n    /* Material Design Text Sizes */\n    --text-h1: 1.5rem;   /* 24px */\n    --text-h2: 1.25rem;  /* 20px */\n    --text-h3: 1.125rem; /* 18px */\n    --text-body: 1rem;   /* 16px */\n    --text-button: 1rem; /* 16px */\n    --text-caption: 0.75rem; /* 12px */\n\n    /* Border Radius */\n    --border-radius-sm: 0.5rem;  /* 8dp Material style */\n    --border-radius-md: 0.75rem;\n    --border-radius-lg: 1rem;\n    --border-radius-pill: 9999px;\n\n    /* Transitions */\n    --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);\n    --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);\n    --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);\n    /* New: Slower, silky smooth curve for modals */\n    --transition-modal: 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);\n\n    /* Shadows */\n    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.2);\n    --shadow-glow: 0 0 20px rgba(99, 102, 241, 0.4);\n    --shadow-glass: 0 8px 32px 0 rgba(0, 0, 0, 0.3);\n\n    /* Colors - Dark Mode (\"Midnight Aurora\") */\n    --bg-body: #0f172a;\n    --bg-gradient: radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.15) 0px, transparent 50%), \n                   radial-gradient(at 100% 100%, rgba(6, 182, 212, 0.15) 0px, transparent 50%);\n    \n    /* Glass Material */\n    --glass-bg: rgba(15, 23, 42, 0.6);\n    --glass-border: rgba(255, 255, 255, 0.08);\n    --glass-highlight: rgba(255, 255, 255, 0.05);\n\n    --bg-light: rgba(30, 41, 59, 0.4); \n    --bg-dark: #020617;      \n    \n    --border-color: rgba(255, 255, 255, 0.1);\n    --border-light: rgba(255, 255, 255, 0.2);\n\n    --text-primary: #f8fafc;\n    --text-secondary: #94a3b8;\n    --text-tertiary: #64748b;\n    --text-placeholder: #475569;\n    \n    /* Brand Gradients */\n    --primary-gradient: linear-gradient(135deg, #6366f1 0%, #06b6d4 100%);\n    --primary-blue: #6366f1;\n    --primary-blue-dark: #4f46e5;\n    --accent-cyan: #06b6d4;\n    \n    --header-bg: rgba(15, 23, 42, 0.8);\n    --clickable-has-video-text: #38bdf8;\n    \n    --modal-input-bg: rgba(2, 6, 23, 0.5);\n    --modal-input-border: rgba(255, 255, 255, 0.1);\n    \n    /* Action & Feedback Colors */\n    --green-vote: #10b981;\n    --red-vote: #ef4444;\n    --orange-feedback: #f97316;\n    --purple-multiple: #a855f7;\n    --selection-yellow: #eab308;\n    \n    --selection-glow: 0 0 15px rgba(234, 179, 8, 0.4);\n    --hover-bg: rgba(255, 255, 255, 0.07);\n}\n\nhtml[data-theme='light'] {\n    /* Colors - Light Mode (\"Daylight Aurora\") */\n    --bg-body: #f0f4f8;\n    --bg-gradient: radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.1) 0px, transparent 50%), \n                   radial-gradient(at 100% 100%, rgba(6, 182, 212, 0.1) 0px, transparent 50%);\n\n    --glass-bg: rgba(255, 255, 255, 0.75);\n    --glass-border: rgba(255, 255, 255, 0.5);\n    --glass-highlight: rgba(255, 255, 255, 0.8);\n\n    --bg-light: rgba(255, 255, 255, 0.8);\n    --bg-dark: #f8fafc;\n    \n    --border-color: #cbd5e1;\n    --border-light: #e2e8f0;\n\n    --text-primary: #0f172a;\n    --text-secondary: #475569;\n    --text-tertiary: #64748b;\n    --text-placeholder: #94a3b8;\n    \n    --primary-gradient: linear-gradient(135deg, #4f46e5 0%, #0891b2 100%);\n    --primary-blue: #4f46e5;\n    --primary-blue-dark: #4338ca;\n    \n    --header-bg: rgba(255, 255, 255, 0.8);\n    --clickable-has-video-text: #0284c7;\n    \n    --modal-input-bg: #ffffff;\n    --modal-input-border: #cbd5e1;\n}\n\nhtml.accessibility-mode {\n    /* Enhanced Contrast */\n    --bg-body: #000000;\n    --bg-gradient: none;\n    --glass-bg: #1a1a1a;\n    --glass-border: #ffffff;\n    --bg-light: #121212;\n    --bg-dark: #000000;\n    --border-color: #666666;\n    --text-primary: #ffffff;\n    --text-secondary: #dddddd;\n    --text-tertiary: #bbbbbb;\n    --primary-blue: #4dabf7;\n    --primary-gradient: #4dabf7;\n    --header-bg: #000000;\n    --modal-input-bg: #1a1a1a;\n    --modal-input-border: #ffffff;\n    \n    --space-sm: 0.7rem;\n    --space-md: 1.3rem;\n    font-size: 110%;\n}\n","path":null,"size_bytes":4769,"size_tokens":null},"src/modules/ui/progress.ts":{"content":"\nimport { appState } from '../../state';\n\nexport const ICON_STATUS_READY = `<svg class=\"w-7 h-7 text-green-500\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z\" /><path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 12.75L11.25 15L15 9.75\" class=\"text-white\" stroke-width=\"2.5\" /></svg>`;\n\nexport function updateHeaderLexiconProgress() {\n    const iconContainer = document.getElementById('lexicon-status-icon');\n    if (!iconContainer) return;\n\n    if (appState.localLexiconReady && appState.fullLexiconLoaded) {\n        iconContainer.innerHTML = ICON_STATUS_READY;\n        iconContainer.dataset.tooltipText = \"Lexikon fullst√§ndigt!\";\n        return;\n    }\n\n    // Simple loading spinner without percentage\n    iconContainer.innerHTML = '<svg class=\"w-6 h-6 text-blue-400 animate-spin\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\"><circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle><path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path></svg>';\n    iconContainer.dataset.tooltipText = \"Laddar lexikon...\";\n}\n\nexport function updateDualLexiconProgressUI() {\n    const statusContainer = document.getElementById('lexiconLoadingStatus');\n    if (!statusContainer) return;\n\n    if (appState.localLexiconReady && appState.fullLexiconLoaded) {\n        statusContainer.classList.add('hidden');\n    } else {\n        statusContainer.classList.remove('hidden');\n    }\n}\n","path":null,"size_bytes":1807,"size_tokens":null},"src/modules/core/__tests__/reset.test.ts":{"content":"import { describe, it, expect } from 'vitest';\nimport { resetApp } from '../reset';\n\ndescribe('resetApp', () => {\n  it('should be a function', () => {\n    expect(typeof resetApp).toBe('function');\n  });\n\n  // L√§gg till tester f√∂r state-reset och DOM-manipulation h√§r\n});\n","path":null,"size_bytes":274,"size_tokens":null},"src/utils.ts":{"content":"\nimport { searchableLexicon } from './state';\n\nexport async function delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function fileToBase64(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onload = () => resolve(reader.result as string);\n        reader.onerror = error => reject(error);\n    });\n}\n\n/**\n * Calculates the Levenshtein distance between two strings.\n * @param a The first string.\n * @param b The second string.\n * @returns The Levenshtein distance.\n */\nexport function levenshtein(a: string, b: string): number {\n    if (a.length === 0) return b.length;\n    if (b.length === 0) return a.length;\n    const matrix = [];\n\n    for (let i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= b.length; i++) {\n        for (let j = 1; j <= a.length; j++) {\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            } else {\n                matrix[i][j] = Math.min(\n                    matrix[i - 1][j - 1] + 1, // substitution\n                    matrix[i][j - 1] + 1,     // insertion\n                    matrix[i - 1][j] + 1      // deletion\n                );\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n}\n\n/**\n * Calculates Levenshtein distance but heavily penalizes substitutions between Swedish and non-accented vowels\n * to prevent incorrect fuzzy matches like \"g√∂ra\" -> \"gora\".\n * @param a The first string.\n * @param b The second string.\n * @returns The \"safe\" Levenshtein distance, or 99 if a forbidden substitution is likely.\n */\nexport function safeDistance(a: string, b: string): number {\n    // Om √•/√§/√∂ √§ndras ‚Üí returnera stort v√§rde (f√∂rbjudet)\n    const forbidden: [string, string][] = [\n        [\"√•\",\"a\"], [\"a\",\"√•\"],\n        [\"√§\",\"a\"], [\"a\",\"√§\"],\n        [\"√∂\",\"o\"], [\"o\",\"√∂\"],\n        [\"√§\",\"e\"], [\"e\",\"√§\"],\n        [\"√∂\",\"e\"], [\"e\",\"√∂\"]\n    ];\n\n    const getCharCounts = (str: string, char: string) => (str.match(new RegExp(char, 'g')) || []).length;\n    \n    for (const [x, y] of forbidden) {\n        const countX_a = getCharCounts(a, x);\n        const countY_a = getCharCounts(a, y);\n        const countX_b = getCharCounts(b, x);\n        const countY_b = getCharCounts(b, y);\n\n        if ((countX_a > countX_b && countY_b > countY_a) || (countX_b > countX_a && countY_a > countY_b)) {\n            return 99;\n        }\n    }\n\n    return levenshtein(a, b);\n}\n\n\n/**\n * Gets sorted search results for lexicon autocomplete.\n * Uses a simple, case-insensitive prefix search.\n * @param query The search query.\n * @param maxResults The maximum number of results to return.\n * @returns A sorted array of matching words.\n */\nexport function getSortedSearchResults(query: string, maxResults: number = 20): string[] {\n    const lowerQuery = query.toLowerCase().trim();\n    if (!lowerQuery) {\n        return [];\n    }\n    const results = searchableLexicon.filter(word => word.startsWith(lowerQuery));\n    return results.slice(0, maxResults);\n}\n","path":null,"size_bytes":3243,"size_tokens":null}},"version":2}